{
  "id": "exercise-034-cryptography-fundamentals",
  "lessonId": "lesson-034-cryptography-fundamentals",
  "title": "Cryptography Implementation and Key Management",
  "description": "Design cryptographic solutions for data protection. Compare symmetric vs asymmetric encryption, implement key management strategies, design certificate infrastructure, and address cryptographic failures. Work through real-world scenarios involving encryption standards, key rotation, and compliance requirements.",
  "difficulty": "intermediate",
  "points": 100,
  "language": "text",
  "starterCode": "# CRYPTOGRAPHY FUNDAMENTALS EXERCISE\n# Design encryption strategies and key management systems\n\n## SCENARIO: SecureBank is implementing enterprise-wide encryption\n## - 50,000 customer financial records stored in databases\n## - SSL/TLS encryption for website (HTTPS)\n## - Encrypted emails for sensitive communications\n## - Encrypted backups to cloud storage\n## - Mobile apps requiring secure communication\n\n## Current issues:\n## - Uses old SSL 2.0 (deprecated, vulnerable)\n## - Private keys stored on server (unencrypted)\n## - No key rotation (same keys for 10+ years)\n## - Unclear encryption standards across systems\n## - Compliance violations (PCI DSS, HIPAA require strong encryption)\n\n## PART 1: SYMMETRIC VS ASYMMETRIC ENCRYPTION\n## Q1: Compare encryption types:\n##\n##     Symmetric Encryption (DES, AES, 3DES):\n##     - What: Same key encrypts and decrypts\n##     - Speed: _______ (fast/slow)\n##     - Key management: _______ (easy/complex)\n##     - Best for: _______\n##     - Example: AES-256 encrypts database\n##\n##     Asymmetric Encryption (RSA, ECC):\n##     - What: Different keys (public/private)\n##     - Speed: _______ (fast/slow)\n##     - Key management: _______ (easy/complex)\n##     - Best for: _______\n##     - Example: RSA encrypts sensitive email\n##\n##     Hybrid Approach (used in TLS):\n##     - What: _______\n##     - Advantages: _______\n##     - Real-world example: HTTPS connection\n\n## Q2: When to use each:\n##     Database encryption (50,000 records): Symmetric or Asymmetric? Why?\n##     Email encryption (send to 100 vendors): Symmetric or Asymmetric? Why?\n##     API authentication tokens: Symmetric or Asymmetric? Why?\n##     Digital signatures: Symmetric or Asymmetric? Why?\n\n## PART 2: ENCRYPTION STANDARDS AND ALGORITHMS\n## Q3: Evaluate encryption algorithms:\n##\n##     DES (Data Encryption Standard):\n##     - Key length: ___ bits\n##     - Block size: ___ bits\n##     - Security: Strong / Moderate / Weak\n##     - Recommended: Yes / No\n##     - Use today: _______________\n##\n##     3DES (Triple DES):\n##     - Key length: ___ bits (effective)\n##     - Security: Strong / Moderate / Weak\n##     - Why \"triple\": _______\n##     - Performance: Fast / Slow compared to AES?\n##     - Recommended: Yes / No\n##\n##     AES (Advanced Encryption Standard):\n##     - Key lengths: ___ bits (options)\n##     - Security: Strong / Moderate / Weak\n##     - Why used everywhere: _______\n##     - Performance: Fast / Slow\n##     - Recommended: Yes / No\n##     - Government approval: Yes / No\n##\n## Q4: AES key selection:\n##     SecureBank must choose: AES-128, AES-192, AES-256\n##     - AES-128: Strong enough? _______________\n##     - AES-256: Overkill or necessary? _______________\n##     - Trade-off: AES-256 is how much slower than AES-128?\n##     - Recommendation: _______________\n##     - Justification: _______________\n\n## PART 3: ASYMMETRIC ENCRYPTION AND CERTIFICATES\n## Q5: RSA vs ECC:\n##\n##     RSA (Rivest Shamir Adleman):\n##     - Key size: 2048 bits minimum\n##     - Speed: _______ (fast/slow)\n##     - Uses: Digital signatures, key exchange, encryption\n##     - Industry standard: Yes / No\n##\n##     ECC (Elliptic Curve Cryptography):\n##     - Key size: 256 bits (equivalent to RSA-2048)\n##     - Speed: _______ (fast/slow)\n##     - Smaller keys, same security: Advantage? _______________\n##     - Emerging standard: Yes / No\n##\n## Q6: Digital certificates:\n##     - Purpose: _______\n##     - Contents: (Name, public key, signature, expiration, etc.)\n##     - Issued by: _______ (certificate authority)\n##     - Chain of trust: How does it work?\n##     - Self-signed vs CA-signed: Difference?\n\n## Q7: SSL/TLS protocol:\n##     - Current version: TLS 1.2 or TLS 1.3?\n##     - Deprecated: SSL 2.0, SSL 3.0 - Why unsafe?\n##     - Protocol flow:\n##       * Client initiates connection\n##       * Server sends _______ (certificate)\n##       * Client verifies _______ (signature)\n##       * _______ (handshake complete)\n##       * _______ (data encrypted with session key)\n##\n## PART 4: KEY MANAGEMENT\n## Q8: Private key protection:\n##     Current problem: Private key stored unencrypted on server\n##     - Risk: If server compromised, attacker gets private key = can decrypt everything\n##     - Solution: Hardware security module (HSM)\n##       * What is HSM? _______\n##       * How does it work? _______\n##       * Where keys stored? _______\n##       * Cost: $_____\n##       * Benefits: _______\n##\n## Q9: Key rotation:\n##     Current problem: Same keys for 10+ years\n##     - Why rotate keys? _______\n##     - Risk of not rotating: _______\n##     - Rotation frequency:\n##       * Encryption keys: Every ___ months/years?\n##       * Signing keys: Every ___ months/years?\n##       * Master keys: Every ___ months/years?\n##     - Process: How to rotate without disruption?\n##       * Dual-key period: _______________\n##       * Verification: _______________\n##       * Rollback: If new key fails, what?\n##\n## Q10: Key storage locations and risks:\n##      Rank by security (1=most secure, 5=least):\n##      __ Hardware security module (HSM) - $50K+\n##      __ Database with encryption - $5K\n##      __ Encrypted files on servers - $0\n##      __ Unencrypted files on servers - $0\n##      __ Developer laptops (NO!) - $0\n##\n## PART 5: CRYPTOGRAPHIC FAILURES\n## Q11: Cipher text exposure scenario:\n##      - Attacker captures HTTPS traffic (man-in-middle)\n##      - Can they decrypt to see customer credit cards?\n##      - Answer: Yes/No - Explain\n##      - Why TLS prevents this: _______\n##\n## Q12: Weak encryption implementation:\n##      Problem: Developer implements \"encryption\" using:\n##      ```\n##      encrypted = base64(password + plaintext)\n##      ```\n##      - Is this secure? Yes / No\n##      - What's wrong: _______\n##      - How to exploit: _______\n##      - Correct approach: _______\n##\n## Q13: Algorithm downgrade attack:\n##      - Client supports: TLS 1.3 (secure)\n##      - Attacker forces downgrade to: SSL 2.0 (broken)\n##      - Result: Connection becomes vulnerable\n##      - Prevention: _______\n\n## Q14: Key compromise scenario:\n##      - Private key stolen from unprotected server\n##      - Attacker uses key to decrypt 5 years of archived data\n##      - Impact: 50,000 customer records exposed\n##      - Recovery steps: _______\n##      - Prevention: _______\n##\n## PART 6: COMPLIANCE AND STANDARDS\n## Q15: Encryption requirements:\n##      - PCI DSS requires: AES-128 minimum or AES-256 required?\n##      - HIPAA requires: Encryption at rest? Encryption in transit?\n##      - GDPR requires: What encryption standard?\n##      - Industry standard: TLS 1.2 minimum or 1.3 required?\n##\n## PART 7: IMPLEMENTATION ROADMAP\n## Q16: SecureBank's encryption upgrade plan:\n##      - Current state: SSL 2.0, unencrypted keys, 10-year-old keys\n##      - Goals: TLS 1.3, HSM-protected keys, annual key rotation\n##      - Timeline and cost:\n##        Phase 1 (Q1): Upgrade to TLS 1.2 - $_____, timeline ___\n##        Phase 2 (Q2): Deploy HSM - $_____, timeline ___\n##        Phase 3 (Q3): Implement key rotation - $_____, timeline ___\n##        Phase 4 (Q4): Upgrade to TLS 1.3 - $_____, timeline ___\n##      - Total cost: $_____\n##      - Compliance status after implementation: _____",
  "solution": "# CRYPTOGRAPHY FUNDAMENTALS SOLUTION\n\n## PART 1: SYMMETRIC VS ASYMMETRIC ENCRYPTION\n\n### Symmetric Encryption\n**Definition**: Same key encrypts and decrypts data\n**Examples**: AES, DES, 3DES\n\n- **Speed**: FAST (milliseconds for gigabytes of data)\n  - Why: Simple mathematical operations on data\n  - Can encrypt/decrypt at line speed\n\n- **Key management**: COMPLEX\n  - Why: Same key must be shared between parties\n  - How to share key securely? (It's a problem)\n  - Key distribution is the main challenge\n  - Every pair of users needs separate key (500 users = 124,750 key pairs)\n\n- **Best for**: \n  - Encrypting large volumes of data (databases, files, backups)\n  - Real-time communication (requires speed)\n  - Data at rest (encrypted files, databases)\n\n- **Example**: AES-256 encrypts 50,000 customer records in database\n  - Database is encrypted with single key\n  - Application decrypts with same key\n  - Fast enough for real-time queries\n\n### Asymmetric Encryption\n**Definition**: Different keys (public/private) for encryption/decryption\n**Examples**: RSA, ECC\n\n- **Speed**: SLOW (thousands of times slower than symmetric)\n  - Why: Complex mathematical operations (prime factorization)\n  - RSA encryption: ~milliseconds for small data\n  - Cannot encrypt large files efficiently\n\n- **Key management**: EASIER\n  - Why: Public key can be shared freely (publicly known)\n  - Private key never shared (kept secret)\n  - No key distribution problem\n  - Everyone has public key → Anyone can encrypt → Only holder of private key can decrypt\n\n- **Best for**:\n  - Key exchange (establish shared symmetric key)\n  - Digital signatures (prove authentication/non-repudiation)\n  - Small data encryption (tokens, credentials)\n  - Public communication (recipient publishes public key)\n\n- **Example**: RSA encrypts email to 100 vendors\n  - Each vendor publishes public key\n  - Anyone can encrypt message to vendor\n  - Only vendor with private key can decrypt\n  - No need to share secret key with 100 parties\n\n### Hybrid Approach (Used in TLS/HTTPS)\n**Definition**: Combine asymmetric (for key exchange) + symmetric (for data)\n\n**Process**:\n1. Client connects to website\n2. Server sends public key (certificate)\n3. Client and server use asymmetric encryption to negotiate session key\n4. Session key is symmetric key (AES)\n5. All data encrypted with symmetric key (fast)\n6. New session key for each connection (if compromised, only that session exposed)\n\n**Advantages**:\n- Security of asymmetric (key exchange problem solved)\n- Speed of symmetric (data encrypted fast)\n- Best of both worlds\n\n### When to Use Each\n\n**Database encryption (50,000 records)**: SYMMETRIC\n- Why: High volume data, needs speed, single key manageable\n- Use: AES-256 for entire database\n- Key protected in HSM or secure key manager\n\n**Email encryption (100 vendors)**: ASYMMETRIC\n- Why: Cannot share secret key with 100 parties\n- Use: Vendor's public key to encrypt, vendor's private key to decrypt\n- Example: PGP/GPG for secure email\n\n**API authentication tokens**: SYMMETRIC\n- Why: Single shared secret between client and server\n- Use: HMAC-SHA256 to sign tokens\n- Token verified by server with same secret\n\n**Digital signatures**: ASYMMETRIC\n- Why: Prove authenticity and non-repudiation\n- Use: Sign with private key, verify with public key\n- Anyone can verify (public key known)\n- Only signer with private key could create signature\n\n## PART 2: ENCRYPTION STANDARDS AND ALGORITHMS\n\n### DES (Data Encryption Standard)\n- **Key length**: 56 bits (effective, 64 bits with parity)\n- **Block size**: 64 bits\n- **Security**: WEAK - Cryptographically broken (can be brute-forced in hours)\n- **Recommended**: NO - Officially deprecated by NIST since 2005\n- **Use today**: ONLY for legacy systems (maintenance, not new development)\n- **Why broken**: 56-bit key too short for modern computing\n  - 2^56 = 72,057,594,037,927,936 possible keys\n  - Modern computer: 1 billion guesses/second = 2.3 years to break\n  - GPUs: Can break in hours\n\n### 3DES (Triple DES)\n- **Key length**: 168 bits effective (56 bits × 3 keys)\n  - Actually uses 3 different DES keys applied sequentially\n  - Encrypt with key1 → Decrypt with key2 → Encrypt with key3\n- **Security**: MODERATE - Secure for now but being phased out\n- **Why \"triple\"**: Applies DES algorithm 3 times to overcome short DES key length\n- **Performance**: SLOW - 3x slower than DES, 50x slower than AES\n- **Recommended**: QUESTIONABLE - Still used in banking/legacy systems\n  - Not recommended for new projects\n  - Replace with AES when possible\n- **Note**: NIST deprecated 3DES as of 2023 (sunset date 2024)\n\n### AES (Advanced Encryption Standard)\n- **Key lengths**: 128, 192, 256 bits (all three are valid)\n  - AES-128: 2^128 possible keys (~340 undecillion)\n  - AES-192: 2^192 possible keys\n  - AES-256: 2^256 possible keys (maximum)\n\n- **Security**: STRONG - No practical attacks known\n  - NIST approved (Federal standard)\n  - NSA Suite B (for classified/top secret)\n  - Resists brute force at all key sizes\n  - No mathematical attacks that compromise security\n\n- **Why used everywhere**:\n  - Fast (hardware accelerated)\n  - Secure (no known vulnerabilities)\n  - Standard (every system supports it)\n  - Flexible (multiple key sizes)\n  - Proven (20+ years, withstood attacks)\n\n- **Performance**: FAST\n  - 128 Gbps on modern CPUs (hardware acceleration)\n  - Can encrypt/decrypt petabytes per second\n  - Negligible overhead for applications\n  - Orders of magnitude faster than 3DES (50x+)\n\n- **Government approval**: YES\n  - NIST officially approved (competition winner)\n  - NSA approved for classified information\n  - Used by US Government, militaries worldwide\n\n### AES Key Selection for SecureBank\n\n**AES-128 (16 bytes)**:\n- Security: Strong (2^128 combinations)\n- Strength: Cannot be brute-forced with any current technology\n- Recommendation: Acceptable for most applications\n- Timeline: Safe for 20+ years (if no quantum computers)\n\n**AES-192 (24 bytes)**:\n- Security: Very strong (2^192 combinations)\n- Additional strength: 2^64 times stronger than AES-128\n- Use case: If you want more margin for future computing power\n\n**AES-256 (32 bytes)**:\n- Security: Very strong (2^256 combinations)\n- Strength: 2^128 times stronger than AES-128\n- Is it overkill?\n  - YES for brute force protection (AES-128 already unbreakable)\n  - But: Post-quantum computing might reduce security margin\n  - NSA Suite B recommends AES-256 for top secret\n  - Industry practice: Use AES-256 for highest value data\n\n**Performance trade-off**: AES-256 vs AES-128\n- Slower by approximately 10-15% (modern CPUs)\n- Negligible real-world impact (milliseconds per gigabyte)\n- Trade-off: Imperceptible slowdown for maximum security\n\n**SecureBank Recommendation**: AES-256\n- **Justification**:\n  1. Defending customer financial data (highest value)\n  2. Regulatory compliance (HIPAA, PCI DSS, GDPR recommend strong encryption)\n  3. Long-term data retention (customer data kept 7+ years)\n  4. Future protection (margin for unknown advances)\n  5. Industry standard (financial institutions use AES-256)\n  6. Minimal performance impact (10-15% is negligible)\n  7. Cost: Same cost as AES-128 (no additional licensing)\n\n## PART 3: ASYMMETRIC ENCRYPTION AND CERTIFICATES\n\n### RSA vs ECC\n\n**RSA (Rivest Shamir Adleman)**\n- **Key size**: 2048 bits minimum (4096 bits recommended)\n  - Why: Protects against known attacks\n  - 2048-bit considered safe until 2030\n  - 4096-bit provides longer safety margin\n\n- **Speed**: SLOW (milliseconds for small data)\n  - Why: Math is complex (prime factorization)\n  - Cannot encrypt large files\n  - Best for: Key exchange, signatures, small data\n\n- **Uses**: Digital signatures, key exchange, encryption\n  - Most common asymmetric algorithm\n  - Industry standard (everywhere)\n\n- **Industry standard**: YES\n  - Used since 1977\n  - Proven track record\n  - Every system supports RSA\n\n**ECC (Elliptic Curve Cryptography)**\n- **Key size**: 256 bits (equivalent to RSA-2048)\n  - Why: Different math makes smaller keys work\n  - 256-bit ECC ≈ 2048-bit RSA security\n  - 384-bit ECC ≈ 7680-bit RSA security\n\n- **Speed**: FAST (faster than RSA)\n  - Why: Math is simpler (curve operations)\n  - ECC-256 faster than RSA-2048 but same security\n  - Better for mobile, IoT devices\n\n- **Advantage of smaller keys**: \n  - Lower bandwidth (certificates, signatures smaller)\n  - Faster computation (same security level)\n  - Better for mobile and embedded systems\n  - Cloud infrastructure requires less storage\n\n- **Emerging standard**: YES\n  - Recommended by NIST, NSA, industry\n  - TLS 1.3 prefers ECC\n  - Expected to replace RSA long-term\n  - Still not as universally supported as RSA (legacy systems)\n\n### Digital Certificates\n\n**Purpose**: \n- Bind public key to identity of entity\n- Prove that public key belongs to claimed owner\n- Enable trust in asymmetric cryptography\n- Example: \"This public key belongs to SecureBank.com, not attacker.com\"\n\n**Certificate Contents**:\n- Subject name (who the certificate is for): SecureBank, Inc.\n- Subject public key (the actual key to be trusted)\n- Issuer name (who signed the certificate): VeriSign\n- Digital signature (proof of issuer authorization)\n- Validity dates (when certificate expires)\n- Serial number (unique identifier)\n- Extended attributes (certificate purpose, restrictions)\n\n**Issued by**: Certificate Authority (CA)\n- Trusted third party that verifies identity\n- Examples: DigiCert, Let's Encrypt, Comodo, GoDaddy\n- Process: Company submits identity proof → CA verifies → CA signs certificate\n- Root CAs: Small number of trusted CAs (browsers, OS come pre-loaded)\n\n**Chain of Trust**: \n1. Browser has Root CA certificates (trusted, embedded)\n2. Website presents certificate signed by Intermediate CA\n3. Browser verifies Intermediate CA certificate signed by Root CA\n4. Browser verifies Root CA signature (trusts Root CA)\n5. Browser now trusts website certificate\n6. Result: Secure connection established\n\n**Self-signed vs CA-signed**:\n- **Self-signed**: Website owner signs their own certificate\n  - Fast and free\n  - No trusted third party\n  - Browser shows warning \"This certificate is not trusted\"\n  - Use case: Development, internal networks only\n  - Not trusted by browsers (browsers show error)\n\n- **CA-signed**: Certificate Authority signs the certificate\n  - Browser trusts CA → Browser trusts certificate\n  - Cost: $0-300/year (Let's Encrypt free, commercial CAs paid)\n  - Browser displays green lock (secure)\n  - Use case: Production websites, customer-facing systems\n\n### SSL/TLS Protocol\n\n**Current version**: TLS 1.3 (released 2018, now recommended)\n- TLS 1.2: Still widely supported, acceptable\n- TLS 1.3: Faster, more secure (preferred)\n\n**Deprecated versions**: SSL 2.0, SSL 3.0, TLS 1.0, TLS 1.1\n- **Why unsafe**:\n  - SSL 2.0: Fundamental design flaws, broken encryption algorithms\n  - SSL 3.0: POODLE attack (downgrade possible)\n  - TLS 1.0/1.1: RC4 cipher vulnerable, MD5 weak hash\n  - TLS 1.2: Acceptable if configured correctly\n\n**Protocol flow** (simplified TLS 1.3):\n1. **Client initiates connection** (ClientHello)\n   - Client sends: Supported protocols, cipher suites, random number\n   - Goal: Determine common supported encryption\n\n2. **Server sends certificate** (ServerHello + Certificate)\n   - Server sends: Chosen protocol (TLS 1.3), cipher suite\n   - Server sends: Digital certificate containing public key\n   - Server sends: Server's random number\n\n3. **Client verifies signature** (Certificate verification)\n   - Client checks: Is certificate signed by trusted CA?\n   - Client checks: Is certificate valid (not expired)?\n   - Client checks: Does certificate domain match website?\n   - Result: Certificate trusted, connection proceeds\n\n4. **Key exchange** (KeyShare)\n   - Client and server use asymmetric encryption\n   - Negotiate shared symmetric key (session key)\n   - Only client and server know session key\n   - Attacker in middle cannot discover it\n\n5. **Data encrypted with session key** (Application Data)\n   - All subsequent communication encrypted with AES-256 + session key\n   - Client sends encrypted data\n   - Server receives encrypted data, decrypts with session key\n   - Both directions encrypted\n\n## PART 4: KEY MANAGEMENT\n\n### Private Key Protection\n\n**Problem**: Private key stored unencrypted on server\n- **Risk**: If server compromised, attacker gets private key\n- **Impact**: Attacker can:\n  - Decrypt all past and future encrypted data\n  - Impersonate the website\n  - Forge digital signatures\n  - Complete compromise of encryption security\n\n**Solution**: Hardware Security Module (HSM)\n\n**What is HSM**: \n- Physical device (box) that stores and manages cryptographic keys\n- Keys never leave the HSM (not exported)\n- Cryptographic operations done inside HSM\n- Strong physical and logical security\n- Tamper-resistant (data destroyed if opened)\n\n**How it works**:\n1. Application needs to encrypt data\n2. Application sends plaintext to HSM\n3. HSM encrypts with key (stored inside)\n4. HSM returns ciphertext\n5. Plaintext never visible to application\n6. Key never leaves HSM\n\n**Where keys stored**:\n- Inside HSM hardware (secure chip)\n- Not accessible from outside\n- Physical and logical protection\n- Encrypted even inside HSM\n\n**Cost**: $50K - $100K+ per HSM\n- Hardware: $30-50K\n- Installation and setup: $10-20K\n- Yearly support: $5-10K\n- High cost but worth it for critical keys\n\n**Benefits**:\n- Keys completely protected\n- Even if server compromised, HSM is secure\n- Compliance requirement (PCI DSS, HIPAA)\n- Long-term protection (keys never exposed)\n- Audit trail (all operations logged)\n- Key rotation (HSM manages automatically)\n\n### Key Rotation\n\n**Why rotate keys**:\n- Long key lifetime = larger window for compromise\n- Periodic fresh keys reduce exposure\n- Standards/regulations require rotation\n- Key compromise detection easier (limited historical data)\n- Future protection (if old key compromised later, only old data at risk)\n\n**Risk of not rotating**:\n- Same key used for 10+ years: Large amount of encrypted data at risk\n- If key discovered: All 10 years of data exposed\n- No separation of old vs new data\n- Regulatory violation (PCI DSS requires rotation)\n\n**Rotation frequency**:\n- **Encryption keys**: Every 12-24 months\n  - Rationale: Annual compliance requirement, large data volume\n  - Example: Database keys rotated yearly\n\n- **Signing keys**: Every 12 months\n  - Rationale: Shorter lifetime reduces exposure\n  - Example: API signing keys rotated annually\n\n- **Master keys**: Every 3-6 months (or longer)\n  - Rationale: These protect other keys (most critical)\n  - Example: HSM master key rotated quarterly\n\n**Rotation process** (no disruption):\n1. **Generate new key** (in HSM)\n2. **Dual-key period** (both old and new keys active)\n   - Old key: Decrypt existing data\n   - New key: Encrypt new data\n   - Duration: 30 days\n   - Systems updated during this period\n3. **Verification** (confirm all systems use new key)\n   - Test new key: Encrypt test data, verify decryption\n   - Audit: Check all applications using new key\n   - Timeline: 30 days\n4. **Retire old key** (after dual-key period)\n   - Old key kept in archive (in case needed)\n   - Old key marked as \"retired\" (not used for new operations)\n   - Can still decrypt historical data if needed\n5. **Rollback** (if new key fails):\n   - Revert to old key\n   - Investigate failure\n   - Fix and retry\n   - Timeline: <1 hour to restore operations\n\n### Key Storage Ranking (by security)\n\n**1. Hardware Security Module (HSM)** - MOST SECURE\n- Cost: $50K+\n- Security: Maximum (keys never leave device)\n- Use for: Master keys, root CA keys\n\n**2. Database with encryption** - SECURE\n- Cost: $5K\n- Security: High (keys encrypted at rest)\n- Use for: Application keys, session keys\n- How: Keys encrypted with master key (in HSM)\n\n**3. Encrypted files on servers** - MODERATE\n- Cost: $0 (software only)\n- Security: Moderate (files encrypted, but keys in RAM)\n- Use for: Development, testing\n- Concern: Keys in memory could be exposed\n\n**4. Unencrypted files on servers** - INSECURE\n- Cost: $0 (no security)\n- Security: Low (anyone with server access gets keys)\n- Use for: NEVER (not acceptable)\n\n**5. Developer laptops** - UNACCEPTABLE\n- Cost: $0\n- Security: None (can be lost/stolen)\n- Use for: ABSOLUTELY NOT\n- Risk: Keys exposed, data compromised\n\n## PART 5: CRYPTOGRAPHIC FAILURES\n\n### Cipher Text Exposure\n\n**Scenario**: Attacker captures HTTPS traffic (man-in-middle)\n\n**Can they decrypt?**: NO\n\n**Why**:\n- Attacker sees only ciphertext (encrypted data)\n- Attacker does not have session key\n- Session key negotiated privately between client and server\n- Asymmetric encryption ensures only client and server know session key\n- Attacker cannot derive session key from ciphertext\n\n**How TLS prevents decryption**:\n1. Attacker intercepts HTTPS connection\n2. Client and server perform TLS handshake (asymmetric encryption)\n3. Session key negotiated using server's public key (from certificate)\n4. Only server has matching private key\n5. Attacker has public key (known), but cannot decrypt with it\n6. Only server (with private key) can decrypt the session key\n7. Session key used to encrypt all data (symmetric encryption)\n8. Attacker in middle cannot decrypt (doesn't have session key)\n\n**Note**: This is why HTTPS is secure even on open networks\n\n### Weak Encryption Implementation\n\n**Developer's \"encryption\"**:\n```\nencrypted = base64(password + plaintext)\n```\n\n**Is this secure?**: NO - Completely broken\n\n**What's wrong**:\n1. Not encryption (just encoding)\n   - Base64 is encoding (reversible), not encryption\n   - Anyone can decode base64 → See plaintext\n2. Password visible (concatenated with data)\n3. No key derivation (password used directly)\n4. No authentication (no MAC/signature)\n5. No random IV (deterministic output)\n\n**How to exploit**:\n1. Attacker gets encoded data: `aGVsbG8gTXlQYXNzd29yZGMyY2MyYzI=`\n2. Decode base64 (trivial): `hello MyPassword c2c2c2`\n3. Read plaintext and password\n4. Extract password\n\n**Correct approach**:\n1. Use proven encryption library (not homemade)\n2. Use strong algorithm (AES-256)\n3. Use proper key derivation (PBKDF2, bcrypt)\n4. Use random IV (per message)\n5. Use authenticated encryption (AES-GCM)\n6. Example:\n```\nkey = PBKDF2(password, salt, iterations=100000)\niv = random(16)\nciphertext = AES-256-GCM(plaintext, key, iv)\noutput = salt || iv || ciphertext || auth_tag\n```\n\n### Algorithm Downgrade Attack\n\n**Scenario**:\n- Client supports: TLS 1.3 (secure)\n- Attacker forces downgrade to: SSL 2.0 (broken)\n- Connection becomes vulnerable\n\n**Prevention**:\n1. **Server configuration**: Disable old protocols\n   - Disable: SSL 2.0, SSL 3.0, TLS 1.0, TLS 1.1\n   - Only enable: TLS 1.2 minimum (TLS 1.3 preferred)\n   - Configuration: Remove ciphers for old protocols\n\n2. **Client enforcement**: Minimum version\n   - Client rejects connections below TLS 1.2\n   - No fallback to old protocols\n   - Better: Reject anything below TLS 1.3\n\n3. **HSTS (HTTP Strict Transport Security)**:\n   - Server sends header: `Strict-Transport-Security`\n   - Browser enforces: Always use HTTPS\n   - Duration: 31536000 seconds (1 year)\n   - Prevents downgrade to HTTP\n\n4. **Certificate pinning**:\n   - Client pins (trusts) specific certificate\n   - Any MITM attempt with different certificate fails\n   - Higher security than normal TLS\n\n### Key Compromise Scenario\n\n**Incident**: Private key stolen, attacker decrypts 5 years of data\n\n**Impact**: 50,000 customer records exposed\n\n**Recovery steps** (incident response):\n1. **Immediate** (<1 hour):\n   - Revoke compromised certificate\n   - Generate new key pair\n   - Notify security team and management\n   - Begin forensics (how was key stolen?)\n\n2. **Short-term** (1-24 hours):\n   - Patch vulnerability that exposed key\n   - Deploy new certificate/key\n   - Verify new key is secure\n   - Check logs: What data was accessed?\n   - Timeline: When was key compromised?\n\n3. **Communication** (24-72 hours):\n   - Notify customers: Data breach occurred\n   - Provide: What data exposed, when, what SecureBank doing\n   - Offer: Credit monitoring, free identity theft protection\n   - Regulatory notification (state attorney general, etc.)\n   - Legal consequences: $1000+ per customer\n\n4. **Investigation** (1-2 weeks):\n   - Forensics: How was key stolen?\n   - Audit logs: What data accessed by attacker?\n   - Scope: How many customers affected?\n   - Financial impact: Breach notification, legal, reputation\n\n5. **Prevention** (long-term):\n   - Implement HSM (keys never on regular servers)\n   - Key rotation (old key only exposes 1 year data, not 5)\n   - Access control (limit who can access keys)\n   - Logging (detect key access)\n   - Monitoring (alert on unusual access)\n\n**Prevention approach**:\n- **HSM**: Keys always protected (even if server compromised)\n- **Key rotation**: If 5-year-old key compromised now\n  - Only last year's data encrypted with it (if rotated)\n  - Not 5 years of data\n  - Dramatically reduces exposure\n- **Encrypt backups**: Old keys cannot decrypt if not stored\n- **Separate key environment**: Keys never on internet-facing servers\n\n## PART 6: COMPLIANCE AND STANDARDS\n\n### Encryption Requirements by Standard\n\n**PCI DSS** (Payment Card Industry Data Security Standard):\n- Requires: AES-128 minimum (AES-256 recommended)\n- Applies to: Credit card data, cardholder information\n- Strength: Strong encryption\n- Audit: Annual verification\n- Violation: $5,000-100,000 per month\n\n**HIPAA** (Health Insurance Portability and Accountability Act):\n- Encryption at rest: Required for sensitive data\n- Encryption in transit: Required for all protected health information\n- Algorithm: AES-128 minimum\n- Key management: Proper storage and rotation\n- Violation: $100-50,000 per violation\n\n**GDPR** (General Data Protection Regulation - EU):\n- Not prescriptive on algorithm\n- Requires: \"State-of-the-art\" encryption\n- Interpretation: Industry standard (AES-256) or stronger\n- Key management: Secure and auditable\n- Violation: €20 million or 4% of revenue (whichever larger)\n\n**Industry standard**:\n- TLS 1.3: Preferred (fastest, most secure)\n- TLS 1.2: Acceptable (widely supported, secure if configured correctly)\n- TLS 1.0/1.1: DEPRECATED (security issues)\n- SSL 2.0/3.0: PROHIBITED (fundamentally broken)\n- Cipher suites: Support ECDHE or DHE (forward secrecy)\n\n## PART 7: IMPLEMENTATION ROADMAP\n\n### SecureBank's Encryption Upgrade Plan\n\n**Current state**: SSL 2.0 (deprecated), unencrypted keys, 10-year-old keys\n**Target**: TLS 1.3, HSM-protected keys, annual key rotation\n\n### Phase 1 (Q1): Upgrade to TLS 1.2\n- **Activities**:\n  - Audit: Current SSL versions in use\n  - Plan: Which systems affected\n  - Procurement: New certificates (self-signed → CA-signed)\n  - Deployment: Update load balancers, web servers\n  - Testing: Verify TLS 1.2 works, no errors\n  - Rollback: Keep SSL 2.0 active as fallback\n  - Timeline: 6-8 weeks\n\n- **Cost**:\n  - CA certificates: $2,000 (multiple certificates, UCC certs)\n  - Deployment: $5,000 (labor)\n  - Monitoring: $1,000\n  - Total Phase 1: $8,000\n\n### Phase 2 (Q2): Deploy HSM\n- **Activities**:\n  - Procurement: Purchase/lease HSM\n  - Installation: Physical hardware installation\n  - Configuration: HSM setup, policies\n  - Integration: Connect HSM to systems\n  - Migration: Move old keys from servers to HSM\n  - Testing: Verify HSM operation, failover\n  - Timeline: 8-12 weeks\n\n- **Cost**:\n  - HSM hardware: $50,000 (or $500/month lease)\n  - Installation: $10,000\n  - Support contract: $8,000/year\n  - Total Phase 2: $60,000-68,000\n\n### Phase 3 (Q3): Implement Key Rotation\n- **Activities**:\n  - Policy: Define rotation schedule (annually)\n  - Automation: Set up automated rotation\n  - Testing: Rotate test keys first\n  - Monitoring: Alert on key rotation\n  - Dual-key period: 30 days for transition\n  - Timeline: 4-6 weeks\n\n- **Cost**:\n  - Key rotation software: $5,000\n  - Testing and implementation: $8,000\n  - Total Phase 3: $13,000\n\n### Phase 4 (Q4): Upgrade to TLS 1.3\n- **Activities**:\n  - Audit: What systems support TLS 1.3\n  - Procurement: TLS 1.3 certificates\n  - Deployment: Update to TLS 1.3\n  - Testing: Compatibility verification\n  - Disable: Turn off older protocols\n  - Timeline: 6-8 weeks\n\n- **Cost**:\n  - Certificates: $2,000\n  - Deployment: $5,000\n  - Total Phase 4: $7,000\n\n### Total 12-Month Cost\n- Phase 1: $8,000\n- Phase 2: $60,000-68,000\n- Phase 3: $13,000\n- Phase 4: $7,000\n- **Total**: $88,000-96,000\n- **Ongoing annual**: $8,000+ (HSM support + key rotation)\n\n### Compliance Status After Implementation\n- ✓ PCI DSS: AES-256 encryption of keys, HSM-protected\n- ✓ HIPAA: Strong encryption, key rotation\n- ✓ GDPR: State-of-the-art encryption (AES-256)\n- ✓ Industry standard: TLS 1.3 with perfect forward secrecy\n- ✓ Key management: HSM-based, automated rotation\n- **Status**: COMPLIANT across all standards",
  "hints": [
    "Symmetric encryption is fast (for data), asymmetric is slow (for key exchange)",
    "Hybrid approach: Use asymmetric to establish session key, then symmetric for data",
    "AES-256 provides 2^128 more security than AES-128 but only 10-15% slower",
    "Private key protection is the most critical security task - use HSM for production",
    "Key rotation limits exposure window - if key compromised, only recent data at risk",
    "TLS 1.3 is significantly faster and more secure than TLS 1.2",
    "Certificates prove the public key belongs to the claimed entity (chain of trust)",
    "Self-signed certificates are free but browsers don't trust them (use for dev only)",
    "Weak 'encryption' using encoding (base64) is not encryption at all - still readable",
    "HSM cost is high but required for compliance and high-security environments"
  ],
  "testCases": [
    {"id": "tc1-symmetric-asymmetric", "description": "Symmetric vs asymmetric encryption selection", "input": "Encryption method choice", "expected": "Symmetric for high-volume data, asymmetric for key exchange/signatures", "assert": "assert 'symmetric' in solution.lower() and 'asymmetric' in solution.lower()"},
    {"id": "tc2-aes-choice", "description": "AES key size selection", "input": "Encryption strength", "expected": "AES-256 recommended for financial data, justification provided", "assert": "assert 'aes' in solution.lower() and ('256' in solution or 'aes-256' in solution.lower())"},
    {"id": "tc3-key-management", "description": "Key storage and protection", "input": "Key security", "expected": "HSM or secure key storage described, protection mechanisms", "assert": "assert ('hsm' in solution.lower() or 'key' in solution.lower()) and ('protect' in solution.lower() or 'secure' in solution.lower())"},
    {"id": "tc4-key-rotation", "description": "Key rotation strategy", "input": "Key lifecycle management", "expected": "Rotation frequency and process described", "assert": "assert 'rotation' in solution.lower() and ('annual' in solution.lower() or 'month' in solution.lower() or 'frequency' in solution.lower())"},
    {"id": "tc5-tls", "description": "TLS protocol and versions", "input": "HTTPS security", "expected": "TLS 1.2 or 1.3 recommended, old versions deprecated", "assert": "assert 'tls' in solution.lower() and ('1.2' in solution or '1.3' in solution or 'deprecated' in solution.lower())"},
    {"id": "tc6-certificate", "description": "Digital certificates", "input": "Certificate management", "expected": "CA-signed certificates for production, chain of trust explained", "assert": "assert 'certificate' in solution.lower() and ('ca' in solution.lower() or 'chain' in solution.lower() or 'trust' in solution.lower())"},
    {"id": "tc7-compliance", "description": "Compliance requirements", "input": "Security standards", "expected": "PCI DSS, HIPAA, GDPR encryption requirements addressed", "assert": "assert ('pci' in solution.lower() or 'hipaa' in solution.lower() or 'gdpr' in solution.lower())"},
    {"id": "tc8-dsa-vs-rsa", "description": "Signature algorithms", "input": "Digital signatures", "expected": "RSA or ECC discussed for signing operations", "assert": "assert ('rsa' in solution.lower() or 'ecc' in solution.lower() or 'signature' in solution.lower())"},
    {"id": "tc9-implementation", "description": "Encryption roadmap", "input": "Deployment plan", "expected": "Phased implementation with timelines and costs", "assert": "assert ('phase' in solution.lower() or 'timeline' in solution.lower() or 'implementation' in solution.lower())"},
    {"id": "tc10-breach", "description": "Key compromise recovery", "input": "Incident response", "expected": "Steps to detect, respond, and prevent key compromise", "assert": "assert ('compromise' in solution.lower() or 'breach' in solution.lower()) and ('recovery' in solution.lower() or 'response' in solution.lower())"}
  ]
}
