{
  "id": "exercise-070-nested-functions-closures",
  "lessonId": "lesson-056-nested-functions-closures",
  "title": "Closures and Function Factories",
  "description": "Master nested functions and closures. Build function factories that remember enclosing scope variables.\n\nYour program should:\n1. Create nested functions inside outer functions\n2. Build closures that capture outer variables\n3. Use nonlocal keyword to modify enclosing scope\n4. Create function factories\n5. Implement counter and adder closures\n6. Understand closure scope retention\n\nImplement these functions:\n- `create_multiplier(n)`: Return function that multiplies by n\n- `create_adder(n)`: Return function that adds n\n- `create_counter(start)`: Return counter closure with nonlocal\n- `create_greeting(greeting)`: Return personalized greeter\n- `create_power_function(exponent)`: Return x^exponent function\n- `create_accumulator(initial)`: Return accumulator with add/get\n\nExample:\n```python\ndouble = create_multiplier(2)\ndouble(5)  # 10\n```",
  "difficulty": "intermediate",
  "points": 20,
  "language": "python",
  "starterCode": "def create_multiplier(n):\n    \"\"\"Create function that multiplies by n.\n    \n    Args:\n        n: Multiplier value.\n    \n    Returns:\n        Function that multiplies its argument by n.\n    \"\"\"\n    # TODO: Return nested function (closure)\n    # def multiplier(x):\n    #     return x * n\n    # return multiplier\n    \n    pass\n\ndef create_adder(n):\n    \"\"\"Create function that adds n to its argument.\n    \n    Args:\n        n: Value to add.\n    \n    Returns:\n        Function that adds n to its argument.\n    \"\"\"\n    # TODO: Return nested function\n    # def adder(x):\n    #     return x + n\n    # return adder\n    \n    pass\n\ndef create_counter(start=0):\n    \"\"\"Create counter closure that maintains state.\n    \n    Args:\n        start: Starting count value.\n    \n    Returns:\n        Function that increments and returns count.\n    \"\"\"\n    # TODO: Use nonlocal to modify outer variable\n    # count = start\n    # \n    # def increment():\n    #     nonlocal count\n    #     count += 1\n    #     return count\n    # \n    # return increment\n    \n    pass\n\ndef create_greeting(greeting):\n    \"\"\"Create personalized greeting function.\n    \n    Args:\n        greeting: Greeting phrase (e.g., 'Hello', 'Hi').\n    \n    Returns:\n        Function that greets a person.\n    \"\"\"\n    # TODO: Return nested function\n    # def greet(name):\n    #     return f\"{greeting}, {name}!\"\n    # return greet\n    \n    pass\n\ndef create_power_function(exponent):\n    \"\"\"Create function that raises to exponent.\n    \n    Args:\n        exponent: Power to raise to.\n    \n    Returns:\n        Function that raises its argument to exponent.\n    \"\"\"\n    # TODO: Return nested function\n    # def power(x):\n    #     return x ** exponent\n    # return power\n    \n    pass\n\ndef create_accumulator(initial=0):\n    \"\"\"Create accumulator closure with add and get methods.\n    \n    Args:\n        initial: Initial value.\n    \n    Returns:\n        Dict with 'add' and 'get' functions.\n    \"\"\"\n    # TODO: Return dict with two functions\n    # total = initial\n    # \n    # def add(value):\n    #     nonlocal total\n    #     total += value\n    #     return total\n    # \n    # def get():\n    #     return total\n    # \n    # return {'add': add, 'get': get}\n    \n    pass\n\n# Test functions\nprint(\"Create Multiplier:\")\nprint(\"=\"*60)\ndouble = create_multiplier(2)\ntriple = create_multiplier(3)\ntimes_ten = create_multiplier(10)\n\nprint(\"double = create_multiplier(2)\")\nprint(f\"  double(5): {double(5)}\")\nprint(f\"  double(10): {double(10)}\")\n\nprint(\"\\ntriple = create_multiplier(3)\")\nprint(f\"  triple(5): {triple(5)}\")\nprint(f\"  triple(10): {triple(10)}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Create Adder:\")\nprint(\"=\"*60)\nadd_five = create_adder(5)\nadd_ten = create_adder(10)\n\nprint(\"add_five = create_adder(5)\")\nprint(f\"  add_five(3): {add_five(3)}\")\nprint(f\"  add_five(7): {add_five(7)}\")\n\nprint(\"\\nadd_ten = create_adder(10)\")\nprint(f\"  add_ten(5): {add_ten(5)}\")\nprint(f\"  add_ten(15): {add_ten(15)}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Create Counter (with nonlocal):\")\nprint(\"=\"*60)\ncounter1 = create_counter(0)\nprint(\"counter1 = create_counter(0)\")\nprint(f\"  Call 1: {counter1()}\")\nprint(f\"  Call 2: {counter1()}\")\nprint(f\"  Call 3: {counter1()}\")\n\ncounter2 = create_counter(10)\nprint(\"\\ncounter2 = create_counter(10)\")\nprint(f\"  Call 1: {counter2()}\")\nprint(f\"  Call 2: {counter2()}\")\n\nprint(\"\\nEach counter maintains its own state!\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Create Greeting:\")\nprint(\"=\"*60)\nsay_hello = create_greeting(\"Hello\")\nsay_hi = create_greeting(\"Hi\")\nsay_howdy = create_greeting(\"Howdy\")\n\nprint(f\"say_hello('Alice'): {say_hello('Alice')}\")\nprint(f\"say_hi('Bob'): {say_hi('Bob')}\")\nprint(f\"say_howdy('Charlie'): {say_howdy('Charlie')}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Create Power Function:\")\nprint(\"=\"*60)\nsquare = create_power_function(2)\ncube = create_power_function(3)\nfourth = create_power_function(4)\n\nprint(f\"square = create_power_function(2)\")\nprint(f\"  square(5): {square(5)}\")\nprint(f\"  square(3): {square(3)}\")\n\nprint(f\"\\ncube = create_power_function(3)\")\nprint(f\"  cube(2): {cube(2)}\")\nprint(f\"  cube(3): {cube(3)}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Create Accumulator:\")\nprint(\"=\"*60)\naccumulator = create_accumulator(0)\nprint(\"accumulator = create_accumulator(0)\")\nprint(f\"Initial value: {accumulator['get']()}\")\nprint(f\"Add 10: {accumulator['add'](10)}\")\nprint(f\"Add 5: {accumulator['add'](5)}\")\nprint(f\"Add 3: {accumulator['add'](3)}\")\nprint(f\"Current total: {accumulator['get']()}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Closure Concepts:\")\nprint(\"=\"*60)\nprint(\"1. Nested function: Function defined inside another\")\nprint(\"2. Closure: Inner function remembers outer variables\")\nprint(\"3. Enclosing scope: Variables from outer function\")\nprint(\"4. nonlocal: Modify outer function variables\")\nprint(\"5. Function factory: Outer function returns inner function\")\nprint(\"6. State retention: Closures remember their environment\")\nprint(\"\\nClosures enable:\")\nprint(\"  - Data privacy (encapsulation)\")\nprint(\"  - Function factories\")\nprint(\"  - Callbacks with state\")\nprint(\"  - Decorators (advanced)\")",
  "solution": "def create_multiplier(n):\n    \"\"\"Create function that multiplies by n.\"\"\"\n    def multiplier(x):\n        return x * n\n    return multiplier\n\ndef create_adder(n):\n    \"\"\"Create function that adds n to its argument.\"\"\"\n    def adder(x):\n        return x + n\n    return adder\n\ndef create_counter(start=0):\n    \"\"\"Create counter closure that maintains state.\"\"\"\n    count = start\n    \n    def increment():\n        nonlocal count\n        count += 1\n        return count\n    \n    return increment\n\ndef create_greeting(greeting):\n    \"\"\"Create personalized greeting function.\"\"\"\n    def greet(name):\n        return f\"{greeting}, {name}!\"\n    return greet\n\ndef create_power_function(exponent):\n    \"\"\"Create function that raises to exponent.\"\"\"\n    def power(x):\n        return x ** exponent\n    return power\n\ndef create_accumulator(initial=0):\n    \"\"\"Create accumulator closure with add and get methods.\"\"\"\n    total = initial\n    \n    def add(value):\n        nonlocal total\n        total += value\n        return total\n    \n    def get():\n        return total\n    \n    return {'add': add, 'get': get}\n\n# Test code as provided",
  "hints": [
    "Closure: nested function that remembers outer variables",
    "Return the inner function (don't call it with ())",
    "Use nonlocal to modify outer function variables",
    "Each closure instance has its own copy of variables",
    "Function factories create specialized functions",
    "Closures provide data privacy and encapsulation"
  ],
  "testCases": [
    {
      "id": "tc1",
      "description": "Multiplier closure",
      "input": "create_multiplier(3)(5)",
      "expectedOutput": "15",
      "isHidden": false
    },
    {
      "id": "tc2",
      "description": "Adder closure",
      "input": "create_adder(10)(5)",
      "expectedOutput": "15",
      "isHidden": false
    },
    {
      "id": "tc3",
      "description": "Counter maintains state",
      "input": "c = create_counter(0); c(); c()",
      "expectedOutput": "2",
      "isHidden": false
    },
    {
      "id": "tc4",
      "description": "Greeting closure",
      "input": "create_greeting('Hello')('Alice')",
      "expectedOutput": "'Hello, Alice!'",
      "isHidden": true
    },
    {
      "id": "tc5",
      "description": "Power function closure",
      "input": "create_power_function(3)(2)",
      "expectedOutput": "8",
      "isHidden": true
    },
    {
      "id": "tc6",
      "description": "Accumulator closure",
      "input": "acc = create_accumulator(0); acc['add'](10); acc['add'](5); acc['get']()",
      "expectedOutput": "15",
      "isHidden": true
    }
  ]
}