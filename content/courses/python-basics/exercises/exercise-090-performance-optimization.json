{
  "id": "exercise-090-performance-optimization",
  "lessonId": "lesson-082-performance-optimization",
  "title": "Performance Profiler and Optimizer",
  "description": "Create a performance profiler that measures and compares different code implementations, demonstrating optimization techniques.\n\nYour program should:\n1. Measure execution time with high precision\n2. Compare different approaches (loops, comprehensions, built-ins)\n3. Measure memory usage\n4. Provide optimization recommendations\n\nImplement these functions:\n- `time_function(func, *args, iterations)`: Measure average execution time\n- `compare_implementations(implementations, data)`: Compare multiple approaches\n- `memory_usage(obj)`: Measure memory usage of objects\n- `optimization_report(results)`: Generate performance report with recommendations\n\nExample:\n```python\ncompare_implementations({\n    'For Loop': sum_for_loop,\n    'List Comprehension': sum_comprehension,\n    'Built-in': sum_builtin\n}, data=[1, 2, 3, ..., 1000])\n\n# Performance Comparison:\n# For Loop:           0.0523ms\n# List Comprehension: 0.0412ms (1.27x faster)\n# Built-in:           0.0098ms (5.34x faster) ← Recommended\n```",
  "difficulty": "advanced",
  "points": 25,
  "language": "python",
  "starterCode": "import time\nimport sys\n\ndef time_function(func, *args, iterations=1000):\n    \"\"\"Measure average execution time over multiple iterations.\"\"\"\n    # TODO: Record start time\n    \n    # TODO: Run function multiple times\n    \n    # TODO: Record end time\n    \n    # TODO: Calculate average time in milliseconds\n    \n    # TODO: Return average time\n    \n    pass\n\ndef memory_usage(obj):\n    \"\"\"Measure memory usage of an object in bytes.\"\"\"\n    # TODO: Use sys.getsizeof() to get size\n    \n    # TODO: Return size in bytes\n    \n    pass\n\ndef compare_implementations(implementations, data):\n    \"\"\"Compare different implementations and find the fastest.\"\"\"\n    # TODO: Dictionary to store results {name: time}\n    results = {}\n    \n    # TODO: Time each implementation\n    \n    # TODO: Find fastest implementation\n    \n    # TODO: Print comparison report\n    # Show each implementation with time\n    # Show speedup compared to fastest\n    # Recommend the fastest\n    \n    pass\n\ndef optimization_report(original_time, optimized_time, original_code, optimized_code):\n    \"\"\"Generate optimization report.\"\"\"\n    # TODO: Calculate speedup\n    \n    # TODO: Calculate percentage improvement\n    \n    # TODO: Print report with before/after comparison\n    \n    pass\n\n# Define different implementations to compare\ndef sum_for_loop(numbers):\n    \"\"\"Sum using for loop.\"\"\"\n    total = 0\n    for num in numbers:\n        total += num\n    return total\n\ndef sum_list_comprehension(numbers):\n    \"\"\"Sum using list comprehension.\"\"\"\n    return sum([num for num in numbers])\n\ndef sum_generator(numbers):\n    \"\"\"Sum using generator expression.\"\"\"\n    return sum(num for num in numbers)\n\ndef sum_builtin(numbers):\n    \"\"\"Sum using built-in function.\"\"\"\n    return sum(numbers)\n\n# Define filtering implementations\ndef filter_for_loop(numbers):\n    \"\"\"Filter even numbers using for loop.\"\"\"\n    result = []\n    for num in numbers:\n        if num % 2 == 0:\n            result.append(num)\n    return result\n\ndef filter_comprehension(numbers):\n    \"\"\"Filter even numbers using list comprehension.\"\"\"\n    return [num for num in numbers if num % 2 == 0]\n\ndef filter_builtin(numbers):\n    \"\"\"Filter even numbers using built-in filter.\"\"\"\n    return list(filter(lambda x: x % 2 == 0, numbers))\n\n# Test the performance profiler\nprint(\"Performance Profiler and Optimizer\")\nprint(\"=\" * 60)\n\n# Generate test data\ntest_data = list(range(1, 1001))\n\nprint(\"\\n1. Summing Numbers - Performance Comparison:\")\nprint(\"-\" * 60)\nsum_implementations = {\n    'For Loop': sum_for_loop,\n    'List Comprehension': sum_list_comprehension,\n    'Generator Expression': sum_generator,\n    'Built-in sum()': sum_builtin\n}\ncompare_implementations(sum_implementations, test_data)\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"2. Filtering Numbers - Performance Comparison:\")\nprint(\"-\" * 60)\nfilter_implementations = {\n    'For Loop': filter_for_loop,\n    'List Comprehension': filter_comprehension,\n    'Built-in filter()': filter_builtin\n}\ncompare_implementations(filter_implementations, test_data)\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"3. Memory Usage Comparison:\")\nprint(\"-\" * 60)\n\n# Compare memory usage of different data structures\ndata_structures = {\n    'List': [1, 2, 3, 4, 5] * 100,\n    'Tuple': tuple([1, 2, 3, 4, 5] * 100),\n    'Set': set([1, 2, 3, 4, 5] * 100),\n    'Generator': (x for x in range(500))\n}\n\nfor name, obj in data_structures.items():\n    size = memory_usage(obj)\n    print(f\"{name:<20} {size:>10,} bytes\")\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"Optimization Tips:\")\nprint(\"-\" * 60)\nprint(\"\"\"\n1. Use built-in functions (sum, max, min) - they're optimized in C\n2. List comprehensions are faster than for loops\n3. Generator expressions use less memory than lists\n4. Avoid repeated function calls in loops\n5. Use appropriate data structures (dict for lookups, set for membership)\n6. Profile before optimizing - measure to find bottlenecks\n7. Don't optimize prematurely - readable code matters\n\"\"\")",
  "solution": "import time\nimport sys\n\ndef time_function(func, *args, iterations=1000):\n    \"\"\"Measure average execution time over multiple iterations.\"\"\"\n    start = time.time()\n    \n    for _ in range(iterations):\n        func(*args)\n    \n    end = time.time()\n    \n    avg_time_ms = ((end - start) / iterations) * 1000\n    return avg_time_ms\n\ndef memory_usage(obj):\n    \"\"\"Measure memory usage of an object in bytes.\"\"\"\n    return sys.getsizeof(obj)\n\ndef compare_implementations(implementations, data):\n    \"\"\"Compare different implementations and find the fastest.\"\"\"\n    results = {}\n    \n    print(\"Testing implementations...\\n\")\n    \n    # Time each implementation\n    for name, func in implementations.items():\n        avg_time = time_function(func, data, iterations=1000)\n        results[name] = avg_time\n        print(f\"{name}: {avg_time:.4f}ms\")\n    \n    # Find fastest\n    fastest_name = min(results, key=results.get)\n    fastest_time = results[fastest_name]\n    \n    print(\"\\nPerformance Analysis:\")\n    print(\"-\" * 60)\n    \n    # Sort by time\n    sorted_results = sorted(results.items(), key=lambda x: x[1])\n    \n    for name, time_taken in sorted_results:\n        if name == fastest_name:\n            print(f\"{name:<25} {time_taken:>8.4f}ms ← Fastest\")\n        else:\n            speedup = time_taken / fastest_time\n            print(f\"{name:<25} {time_taken:>8.4f}ms ({speedup:.2f}x slower)\")\n    \n    print(f\"\\nRecommendation: Use '{fastest_name}' for best performance\")\n\ndef optimization_report(original_time, optimized_time, original_code, optimized_code):\n    \"\"\"Generate optimization report.\"\"\"\n    speedup = original_time / optimized_time\n    improvement = ((original_time - optimized_time) / original_time) * 100\n    \n    print(\"Optimization Report:\")\n    print(\"=\" * 60)\n    print(f\"Original Implementation:\")\n    print(f\"  Time: {original_time:.4f}ms\")\n    print(f\"  Code: {original_code}\")\n    print()\n    print(f\"Optimized Implementation:\")\n    print(f\"  Time: {optimized_time:.4f}ms\")\n    print(f\"  Code: {optimized_code}\")\n    print()\n    print(f\"Performance Improvement:\")\n    print(f\"  Speedup: {speedup:.2f}x faster\")\n    print(f\"  Time saved: {improvement:.1f}%\")\n\n# Define different implementations to compare\ndef sum_for_loop(numbers):\n    \"\"\"Sum using for loop.\"\"\"\n    total = 0\n    for num in numbers:\n        total += num\n    return total\n\ndef sum_list_comprehension(numbers):\n    \"\"\"Sum using list comprehension.\"\"\"\n    return sum([num for num in numbers])\n\ndef sum_generator(numbers):\n    \"\"\"Sum using generator expression.\"\"\"\n    return sum(num for num in numbers)\n\ndef sum_builtin(numbers):\n    \"\"\"Sum using built-in function.\"\"\"\n    return sum(numbers)\n\n# Define filtering implementations\ndef filter_for_loop(numbers):\n    \"\"\"Filter even numbers using for loop.\"\"\"\n    result = []\n    for num in numbers:\n        if num % 2 == 0:\n            result.append(num)\n    return result\n\ndef filter_comprehension(numbers):\n    \"\"\"Filter even numbers using list comprehension.\"\"\"\n    return [num for num in numbers if num % 2 == 0]\n\ndef filter_builtin(numbers):\n    \"\"\"Filter even numbers using built-in filter.\"\"\"\n    return list(filter(lambda x: x % 2 == 0, numbers))\n\n# Test the performance profiler\nprint(\"Performance Profiler and Optimizer\")\nprint(\"=\" * 60)\n\ntest_data = list(range(1, 1001))\n\nprint(\"\\n1. Summing Numbers - Performance Comparison:\")\nprint(\"-\" * 60)\nsum_implementations = {\n    'For Loop': sum_for_loop,\n    'List Comprehension': sum_list_comprehension,\n    'Generator Expression': sum_generator,\n    'Built-in sum()': sum_builtin\n}\ncompare_implementations(sum_implementations, test_data)\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"2. Filtering Numbers - Performance Comparison:\")\nprint(\"-\" * 60)\nfilter_implementations = {\n    'For Loop': filter_for_loop,\n    'List Comprehension': filter_comprehension,\n    'Built-in filter()': filter_builtin\n}\ncompare_implementations(filter_implementations, test_data)\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"3. Memory Usage Comparison:\")\nprint(\"-\" * 60)\n\ndata_structures = {\n    'List': [1, 2, 3, 4, 5] * 100,\n    'Tuple': tuple([1, 2, 3, 4, 5] * 100),\n    'Set': set([1, 2, 3, 4, 5] * 100),\n    'Generator': (x for x in range(500))\n}\n\nfor name, obj in data_structures.items():\n    size = memory_usage(obj)\n    print(f\"{name:<20} {size:>10,} bytes\")\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"Optimization Tips:\")\nprint(\"-\" * 60)\nprint(\"\"\"\n1. Use built-in functions (sum, max, min) - they're optimized in C\n2. List comprehensions are faster than for loops\n3. Generator expressions use less memory than lists\n4. Avoid repeated function calls in loops\n5. Use appropriate data structures (dict for lookups, set for membership)\n6. Profile before optimizing - measure to find bottlenecks\n7. Don't optimize prematurely - readable code matters\n\"\"\")",
  "hints": [
    "Use time.time() before and after the loop, calculate elapsed = (end - start) / iterations * 1000 for milliseconds",
    "Store results in a dictionary: results[name] = time, then use min(results, key=results.get) to find fastest",
    "Calculate speedup as: slower_time / faster_time",
    "Calculate percentage improvement: ((original - optimized) / original) * 100",
    "Use sys.getsizeof(obj) to get memory size in bytes",
    "Sort results with: sorted(results.items(), key=lambda x: x[1]) to order by time"
  ],
  "testCases": [
    {
      "id": "tc1",
      "description": "time_function measures execution time",
      "input": "def test(): pass; result = time_function(test, iterations=100); print(result >= 0)",
      "expectedOutput": "True",
      "isHidden": false
    },
    {
      "id": "tc2",
      "description": "memory_usage returns size in bytes",
      "input": "size = memory_usage([1,2,3]); print(size > 0)",
      "expectedOutput": "True",
      "isHidden": false
    },
    {
      "id": "tc3",
      "description": "Built-in sum is fastest implementation",
      "input": "Test that sum_builtin is typically faster than sum_for_loop",
      "expectedOutput": "Built-in sum() should be recommended as fastest",
      "isHidden": false
    },
    {
      "id": "tc4",
      "description": "List comprehension faster than for loop",
      "input": "filter_comprehension should be faster than filter_for_loop",
      "expectedOutput": "List comprehension typically 20-50% faster",
      "isHidden": true
    },
    {
      "id": "tc5",
      "description": "Generator uses less memory than list",
      "input": "memory_usage(generator) < memory_usage(list)",
      "expectedOutput": "Generator should use significantly less memory",
      "isHidden": true
    }
  ]
}