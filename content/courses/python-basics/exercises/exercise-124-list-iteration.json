{
  "id": "exercise-124-list-iteration",
  "lessonId": "lesson-114-list-iteration",
  "title": "Iterating Through Lists",
  "description": "Master various list iteration techniques and patterns.\n\nYour program should:\n1. Iterate with for loops\n2. Use enumerate() for index-value pairs\n3. Iterate multiple lists with zip()\n4. Use range() for index-based iteration\n5. Apply iteration patterns effectively\n6. Choose appropriate iteration method\n\nImplement these functions:\n- `basic_iteration()`: Standard for loops\n- `enumerate_iteration()`: Get index and value\n- `zip_iteration()`: Iterate multiple lists\n- `range_iteration()`: Index-based loops\n- `iteration_patterns()`: Common patterns\n- `modify_while_iterating()`: Safe modification\n\nExample:\n```python\nfor fruit in fruits:\n    print(fruit)\nfor i, fruit in enumerate(fruits):\n    print(f\"{i}: {fruit}\")\n```",
  "difficulty": "beginner",
  "points": 15,
  "language": "python",
  "starterCode": "def basic_iteration():\n    \"\"\"Basic for loop iteration.\n    \n    Returns:\n        Dict with iteration results.\n    \"\"\"\n    # TODO: Basic iteration\n    # fruits = [\"apple\", \"banana\", \"cherry\"]\n    # \n    # # Iterate over elements\n    # collected = []\n    # for fruit in fruits:\n    #     collected.append(fruit.upper())\n    # \n    # # Count matching\n    # numbers = [1, 2, 3, 4, 5, 6]\n    # even_count = 0\n    # for num in numbers:\n    #     if num % 2 == 0:\n    #         even_count += 1\n    # \n    # # Build new list\n    # squares = []\n    # for num in [1, 2, 3, 4, 5]:\n    #     squares.append(num ** 2)\n    # \n    # return {\n    #     'uppercase': collected,\n    #     'even_count': even_count,\n    #     'squares': squares\n    # }\n    pass\n\ndef enumerate_iteration():\n    \"\"\"Iterate with index using enumerate().\n    \n    Returns:\n        Dict with enumerate results.\n    \"\"\"\n    # TODO: Enumerate iteration\n    # fruits = [\"apple\", \"banana\", \"cherry\"]\n    # \n    # # Get index and value\n    # indexed = []\n    # for i, fruit in enumerate(fruits):\n    #     indexed.append(f\"{i}: {fruit}\")\n    # \n    # # Start from different index\n    # from_one = []\n    # for i, fruit in enumerate(fruits, start=1):\n    #     from_one.append(f\"{i}. {fruit}\")\n    # \n    # # Find index of element\n    # numbers = [10, 20, 30, 40, 50]\n    # index_of_30 = None\n    # for i, num in enumerate(numbers):\n    #     if num == 30:\n    #         index_of_30 = i\n    #         break\n    # \n    # # Modify by index\n    # nums = [1, 2, 3, 4, 5]\n    # for i, num in enumerate(nums):\n    #     nums[i] = num * 10\n    # modified = nums.copy()\n    # \n    # return {\n    #     'indexed': indexed,\n    #     'from_one': from_one,\n    #     'index_of_30': index_of_30,\n    #     'modified': modified\n    # }\n    pass\n\ndef zip_iteration():\n    \"\"\"Iterate multiple lists with zip().\n    \n    Returns:\n        Dict with zip results.\n    \"\"\"\n    # TODO: Zip iteration\n    # names = [\"Alice\", \"Bob\", \"Charlie\"]\n    # ages = [25, 30, 35]\n    # cities = [\"NYC\", \"LA\", \"Chicago\"]\n    # \n    # # Combine two lists\n    # pairs = []\n    # for name, age in zip(names, ages):\n    #     pairs.append(f\"{name} is {age}\")\n    # \n    # # Combine three lists\n    # triples = []\n    # for name, age, city in zip(names, ages, cities):\n    #     triples.append(f\"{name}, {age}, {city}\")\n    # \n    # # Unequal length (zip stops at shortest)\n    # short = [1, 2]\n    # long = [\"a\", \"b\", \"c\", \"d\"]\n    # combined = []\n    # for num, letter in zip(short, long):\n    #     combined.append(f\"{num}{letter}\")\n    # \n    # # Build dictionary\n    # person_dict = {}\n    # for name, age in zip(names, ages):\n    #     person_dict[name] = age\n    # \n    # return {\n    #     'pairs': pairs,\n    #     'triples': triples,\n    #     'combined': combined,\n    #     'person_dict': person_dict\n    # }\n    pass\n\ndef range_iteration():\n    \"\"\"Index-based iteration with range().\n    \n    Returns:\n        Dict with range results.\n    \"\"\"\n    # TODO: Range iteration\n    # numbers = [10, 20, 30, 40, 50]\n    # \n    # # Iterate by index\n    # doubled = []\n    # for i in range(len(numbers)):\n    #     doubled.append(numbers[i] * 2)\n    # \n    # # Modify in place\n    # nums = [1, 2, 3, 4, 5]\n    # for i in range(len(nums)):\n    #     nums[i] += 10\n    # modified = nums.copy()\n    # \n    # # Iterate part of list\n    # partial = []\n    # for i in range(1, 4):  # indices 1, 2, 3\n    #     partial.append(numbers[i])\n    # \n    # # Iterate with step\n    # evens = []\n    # for i in range(0, len(numbers), 2):\n    #     evens.append(numbers[i])\n    # \n    # # Reverse iteration\n    # reversed_list = []\n    # for i in range(len(numbers) - 1, -1, -1):\n    #     reversed_list.append(numbers[i])\n    # \n    # return {\n    #     'doubled': doubled,\n    #     'modified': modified,\n    #     'partial': partial,\n    #     'evens': evens,\n    #     'reversed': reversed_list\n    # }\n    pass\n\ndef iteration_patterns():\n    \"\"\"Common iteration patterns.\n    \n    Returns:\n        Dict with pattern results.\n    \"\"\"\n    # TODO: Iteration patterns\n    # numbers = [1, 2, 3, 4, 5]\n    # \n    # # Find first matching\n    # first_even = None\n    # for num in numbers:\n    #     if num % 2 == 0:\n    #         first_even = num\n    #         break\n    # \n    # # Check if all match\n    # all_positive = True\n    # for num in numbers:\n    #     if num <= 0:\n    #         all_positive = False\n    #         break\n    # \n    # # Check if any match\n    # has_even = False\n    # for num in numbers:\n    #     if num % 2 == 0:\n    #         has_even = True\n    #         break\n    # \n    # # Skip some\n    # odds_only = []\n    # for num in numbers:\n    #     if num % 2 == 0:\n    #         continue\n    #     odds_only.append(num)\n    # \n    # # Nested iteration\n    # matrix = [[1, 2], [3, 4], [5, 6]]\n    # flattened = []\n    # for row in matrix:\n    #     for val in row:\n    #         flattened.append(val)\n    # \n    # return {\n    #     'first_even': first_even,\n    #     'all_positive': all_positive,\n    #     'has_even': has_even,\n    #     'odds_only': odds_only,\n    #     'flattened': flattened\n    # }\n    pass\n\ndef modify_while_iterating():\n    \"\"\"Safe modification during iteration.\n    \n    Returns:\n        Dict showing safe patterns.\n    \"\"\"\n    # TODO: Safe modification\n    # # WRONG: Modifying while iterating\n    # # nums = [1, 2, 3, 4, 5]\n    # # for num in nums:\n    # #     if num % 2 == 0:\n    # #         nums.remove(num)  # BAD: skips elements\n    # \n    # # RIGHT: Iterate over copy\n    # nums = [1, 2, 3, 4, 5]\n    # for num in nums.copy():\n    #     if num % 2 == 0:\n    #         nums.remove(num)\n    # removed_evens = nums.copy()\n    # \n    # # RIGHT: Build new list\n    # nums = [1, 2, 3, 4, 5]\n    # odds = []\n    # for num in nums:\n    #     if num % 2 != 0:\n    #         odds.append(num)\n    # \n    # # RIGHT: Comprehension (best)\n    # nums = [1, 2, 3, 4, 5]\n    # filtered = [num for num in nums if num % 2 != 0]\n    # \n    # # RIGHT: Reverse iteration for removal\n    # nums = [1, 2, 3, 4, 5]\n    # for i in range(len(nums) - 1, -1, -1):\n    #     if nums[i] % 2 == 0:\n    #         nums.pop(i)\n    # reverse_removed = nums.copy()\n    # \n    # return {\n    #     'copy_method': removed_evens,\n    #     'build_new': odds,\n    #     'comprehension': filtered,\n    #     'reverse_iteration': reverse_removed\n    # }\n    pass\n\n# Test code\nprint(\"List Iteration:\")\nprint(\"=\"*60)\n\nprint(\"\\nBasic Iteration:\")\nprint(\"-\"*60)\nbasic = basic_iteration()\nfor name, value in basic.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Enumerate Iteration:\")\nprint(\"=\"*60)\nenumerate_demo = enumerate_iteration()\nfor name, value in enumerate_demo.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Zip Iteration:\")\nprint(\"=\"*60)\nzip_demo = zip_iteration()\nfor name, value in zip_demo.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Range Iteration:\")\nprint(\"=\"*60)\nrange_demo = range_iteration()\nfor name, value in range_demo.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Iteration Patterns:\")\nprint(\"=\"*60)\npatterns = iteration_patterns()\nfor name, value in patterns.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Safe Modification:\")\nprint(\"=\"*60)\nmodify = modify_while_iterating()\nfor name, value in modify.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Key Concepts:\")\nprint(\"=\"*60)\nprint(\"Basic Iteration:\")\nprint(\"  - for item in list: Simple element access\")\nprint(\"  - Most readable and pythonic\")\nprint(\"\\nEnumerate:\")\nprint(\"  - for i, item in enumerate(list): Get index and value\")\nprint(\"  - enumerate(list, start=1): Start from 1 instead of 0\")\nprint(\"\\nZip:\")\nprint(\"  - for x, y in zip(list1, list2): Iterate parallel\")\nprint(\"  - Stops at shortest list\")\nprint(\"\\nRange:\")\nprint(\"  - for i in range(len(list)): Index-based\")\nprint(\"  - Use when you need to modify by index\")\nprint(\"\\nSafe Modification:\")\nprint(\"  - Don't modify list while iterating over it\")\nprint(\"  - Use: copy(), build new list, comprehension, or reverse iterate\")",
  "solution": "def basic_iteration():\n    fruits = [\"apple\", \"banana\", \"cherry\"]\n    \n    collected = []\n    for fruit in fruits:\n        collected.append(fruit.upper())\n    \n    numbers = [1, 2, 3, 4, 5, 6]\n    even_count = 0\n    for num in numbers:\n        if num % 2 == 0:\n            even_count += 1\n    \n    squares = []\n    for num in [1, 2, 3, 4, 5]:\n        squares.append(num ** 2)\n    \n    return {\n        'uppercase': collected,\n        'even_count': even_count,\n        'squares': squares\n    }\n\ndef enumerate_iteration():\n    fruits = [\"apple\", \"banana\", \"cherry\"]\n    \n    indexed = []\n    for i, fruit in enumerate(fruits):\n        indexed.append(f\"{i}: {fruit}\")\n    \n    from_one = []\n    for i, fruit in enumerate(fruits, start=1):\n        from_one.append(f\"{i}. {fruit}\")\n    \n    numbers = [10, 20, 30, 40, 50]\n    index_of_30 = None\n    for i, num in enumerate(numbers):\n        if num == 30:\n            index_of_30 = i\n            break\n    \n    nums = [1, 2, 3, 4, 5]\n    for i, num in enumerate(nums):\n        nums[i] = num * 10\n    modified = nums.copy()\n    \n    return {\n        'indexed': indexed,\n        'from_one': from_one,\n        'index_of_30': index_of_30,\n        'modified': modified\n    }\n\ndef zip_iteration():\n    names = [\"Alice\", \"Bob\", \"Charlie\"]\n    ages = [25, 30, 35]\n    cities = [\"NYC\", \"LA\", \"Chicago\"]\n    \n    pairs = []\n    for name, age in zip(names, ages):\n        pairs.append(f\"{name} is {age}\")\n    \n    triples = []\n    for name, age, city in zip(names, ages, cities):\n        triples.append(f\"{name}, {age}, {city}\")\n    \n    short = [1, 2]\n    long = [\"a\", \"b\", \"c\", \"d\"]\n    combined = []\n    for num, letter in zip(short, long):\n        combined.append(f\"{num}{letter}\")\n    \n    person_dict = {}\n    for name, age in zip(names, ages):\n        person_dict[name] = age\n    \n    return {\n        'pairs': pairs,\n        'triples': triples,\n        'combined': combined,\n        'person_dict': person_dict\n    }\n\ndef range_iteration():\n    numbers = [10, 20, 30, 40, 50]\n    \n    doubled = []\n    for i in range(len(numbers)):\n        doubled.append(numbers[i] * 2)\n    \n    nums = [1, 2, 3, 4, 5]\n    for i in range(len(nums)):\n        nums[i] += 10\n    modified = nums.copy()\n    \n    partial = []\n    for i in range(1, 4):\n        partial.append(numbers[i])\n    \n    evens = []\n    for i in range(0, len(numbers), 2):\n        evens.append(numbers[i])\n    \n    reversed_list = []\n    for i in range(len(numbers) - 1, -1, -1):\n        reversed_list.append(numbers[i])\n    \n    return {\n        'doubled': doubled,\n        'modified': modified,\n        'partial': partial,\n        'evens': evens,\n        'reversed': reversed_list\n    }\n\ndef iteration_patterns():\n    numbers = [1, 2, 3, 4, 5]\n    \n    first_even = None\n    for num in numbers:\n        if num % 2 == 0:\n            first_even = num\n            break\n    \n    all_positive = True\n    for num in numbers:\n        if num <= 0:\n            all_positive = False\n            break\n    \n    has_even = False\n    for num in numbers:\n        if num % 2 == 0:\n            has_even = True\n            break\n    \n    odds_only = []\n    for num in numbers:\n        if num % 2 == 0:\n            continue\n        odds_only.append(num)\n    \n    matrix = [[1, 2], [3, 4], [5, 6]]\n    flattened = []\n    for row in matrix:\n        for val in row:\n            flattened.append(val)\n    \n    return {\n        'first_even': first_even,\n        'all_positive': all_positive,\n        'has_even': has_even,\n        'odds_only': odds_only,\n        'flattened': flattened\n    }\n\ndef modify_while_iterating():\n    nums = [1, 2, 3, 4, 5]\n    for num in nums.copy():\n        if num % 2 == 0:\n            nums.remove(num)\n    removed_evens = nums.copy()\n    \n    nums = [1, 2, 3, 4, 5]\n    odds = []\n    for num in nums:\n        if num % 2 != 0:\n            odds.append(num)\n    \n    nums = [1, 2, 3, 4, 5]\n    filtered = [num for num in nums if num % 2 != 0]\n    \n    nums = [1, 2, 3, 4, 5]\n    for i in range(len(nums) - 1, -1, -1):\n        if nums[i] % 2 == 0:\n            nums.pop(i)\n    reverse_removed = nums.copy()\n    \n    return {\n        'copy_method': removed_evens,\n        'build_new': odds,\n        'comprehension': filtered,\n        'reverse_iteration': reverse_removed\n    }",
  "hints": [
    "Basic: for item in list - most readable",
    "enumerate(list) gives (index, value) pairs",
    "zip(list1, list2) iterates multiple lists together",
    "range(len(list)) for index-based iteration",
    "break stops loop, continue skips to next",
    "Don't modify list while iterating - use copy() or build new"
  ],
  "testCases": [
    {
      "id": "tc1",
      "description": "Basic iteration",
      "input": "basic_iteration()['even_count']",
      "expectedOutput": "3",
      "isHidden": false
    },
    {
      "id": "tc2",
      "description": "Enumerate start",
      "input": "enumerate_iteration()['from_one'][0]",
      "expectedOutput": "'1. apple'",
      "isHidden": false
    },
    {
      "id": "tc3",
      "description": "Zip combines",
      "input": "len(zip_iteration()['combined'])",
      "expectedOutput": "2",
      "isHidden": false
    },
    {
      "id": "tc4",
      "description": "Range reverse",
      "input": "range_iteration()['reversed']",
      "expectedOutput": "[50, 40, 30, 20, 10]",
      "isHidden": true
    },
    {
      "id": "tc5",
      "description": "Pattern first match",
      "input": "iteration_patterns()['first_even']",
      "expectedOutput": "2",
      "isHidden": true
    },
    {
      "id": "tc6",
      "description": "Safe modification",
      "input": "modify_while_iterating()['comprehension']",
      "expectedOutput": "[1, 3, 5]",
      "isHidden": true
    }
  ]
}