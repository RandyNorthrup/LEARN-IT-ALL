{
  "id": "exercise-174-testing-mastery",
  "lessonId": "lesson-164-testing-mastery",
  "title": "Testing Mastery Capstone",
  "description": "Build comprehensive test suites, apply all testing concepts, create production-ready tests, and master testing workflows.",
  "difficulty": "advanced",
  "points": 30,
  "starterCode": "# Exercise: Testing Mastery Capstone\nimport pytest\nfrom unittest.mock import Mock\n\nclass Product:\n    \"\"\"Product model.\"\"\"\n    pass\n\nclass ProductService:\n    \"\"\"Service for product operations.\"\"\"\n    pass\n\nclass InventoryManager:\n    \"\"\"Manage product inventory.\"\"\"\n    pass\n\nclass OrderProcessor:\n    \"\"\"Process orders with payment.\"\"\"\n    pass\n\nclass NotificationService:\n    \"\"\"Send order notifications.\"\"\"\n    pass\n\nclass ECommerceSystem:\n    \"\"\"Complete e-commerce system integration.\"\"\"\n    pass\n",
  "solution": "# Solution: Testing Mastery Capstone\nimport pytest\nfrom unittest.mock import Mock, patch\nfrom typing import List, Dict, Optional\nfrom dataclasses import dataclass\n\n@dataclass\nclass Product:\n    \"\"\"Product model.\"\"\"\n    id: str\n    name: str\n    price: float\n    stock: int\n\nclass ProductService:\n    \"\"\"Service for product operations.\"\"\"\n    \n    def __init__(self, database):\n        self.db = database\n    \n    def get_product(self, product_id: str) -> Optional[Product]:\n        \"\"\"Get product by ID.\"\"\"\n        data = self.db.get(\"products\", product_id)\n        if data:\n            return Product(**data)\n        return None\n    \n    def check_availability(self, product_id: str, quantity: int) -> bool:\n        \"\"\"Check if product is available in requested quantity.\"\"\"\n        product = self.get_product(product_id)\n        if not product:\n            return False\n        return product.stock >= quantity\n    \n    def update_stock(self, product_id: str, quantity_change: int):\n        \"\"\"\n        Update product stock.\n        \n        Raises:\n            ValueError: If product not found or insufficient stock\n        \"\"\"\n        product = self.get_product(product_id)\n        if not product:\n            raise ValueError(f\"Product not found: {product_id}\")\n        \n        new_stock = product.stock + quantity_change\n        if new_stock < 0:\n            raise ValueError(f\"Insufficient stock for {product_id}\")\n        \n        product.stock = new_stock\n        self.db.update(\"products\", product_id, {\"stock\": product.stock})\n\nclass InventoryManager:\n    \"\"\"Manage product inventory.\"\"\"\n    \n    def __init__(self, product_service: ProductService):\n        self.products = product_service\n        self.reserved = {}\n    \n    def reserve_stock(self, product_id: str, quantity: int) -> bool:\n        \"\"\"\n        Reserve stock for order.\n        \n        Returns:\n            True if reservation successful\n        \"\"\"\n        if not self.products.check_availability(product_id, quantity):\n            return False\n        \n        if product_id not in self.reserved:\n            self.reserved[product_id] = 0\n        \n        self.reserved[product_id] += quantity\n        return True\n    \n    def commit_reservation(self, product_id: str, quantity: int):\n        \"\"\"Commit reserved stock (reduce actual stock).\"\"\"\n        self.products.update_stock(product_id, -quantity)\n        self.reserved[product_id] -= quantity\n    \n    def release_reservation(self, product_id: str, quantity: int):\n        \"\"\"Release reserved stock without committing.\"\"\"\n        if product_id in self.reserved:\n            self.reserved[product_id] = max(0, self.reserved[product_id] - quantity)\n\nclass OrderProcessor:\n    \"\"\"Process orders with payment.\"\"\"\n    \n    def __init__(self, inventory: InventoryManager, payment_gateway):\n        self.inventory = inventory\n        self.payment = payment_gateway\n    \n    def process_order(self, order_items: List[Dict], total: float) -> Dict:\n        \"\"\"\n        Process order with payment.\n        \n        Args:\n            order_items: List of {product_id, quantity}\n            total: Order total amount\n        \n        Returns:\n            Order result with status\n        \"\"\"\n        # Reserve stock\n        for item in order_items:\n            if not self.inventory.reserve_stock(item[\"product_id\"], item[\"quantity\"]):\n                # Release already reserved items\n                for prev_item in order_items:\n                    if prev_item == item:\n                        break\n                    self.inventory.release_reservation(\n                        prev_item[\"product_id\"], prev_item[\"quantity\"]\n                    )\n                return {\"status\": \"failed\", \"reason\": \"insufficient_stock\"}\n        \n        # Process payment\n        try:\n            payment_result = self.payment.charge(total)\n            \n            if payment_result[\"status\"] == \"success\":\n                # Commit stock\n                for item in order_items:\n                    self.inventory.commit_reservation(\n                        item[\"product_id\"], item[\"quantity\"]\n                    )\n                \n                return {\n                    \"status\": \"success\",\n                    \"transaction_id\": payment_result[\"transaction_id\"]\n                }\n            else:\n                # Release stock\n                for item in order_items:\n                    self.inventory.release_reservation(\n                        item[\"product_id\"], item[\"quantity\"]\n                    )\n                \n                return {\"status\": \"failed\", \"reason\": \"payment_declined\"}\n        \n        except Exception as e:\n            # Release stock on error\n            for item in order_items:\n                self.inventory.release_reservation(\n                    item[\"product_id\"], item[\"quantity\"]\n                )\n            \n            return {\"status\": \"error\", \"reason\": str(e)}\n\nclass NotificationService:\n    \"\"\"Send order notifications.\"\"\"\n    \n    def __init__(self):\n        self.sent_notifications = []\n    \n    def send_order_confirmation(self, email: str, order_id: str) -> bool:\n        \"\"\"Send order confirmation email.\"\"\"\n        notification = {\n            \"type\": \"order_confirmation\",\n            \"email\": email,\n            \"order_id\": order_id\n        }\n        self.sent_notifications.append(notification)\n        return True\n    \n    def send_order_failure(self, email: str, reason: str) -> bool:\n        \"\"\"Send order failure notification.\"\"\"\n        notification = {\n            \"type\": \"order_failure\",\n            \"email\": email,\n            \"reason\": reason\n        }\n        self.sent_notifications.append(notification)\n        return True\n\nclass ECommerceSystem:\n    \"\"\"Complete e-commerce system integration.\"\"\"\n    \n    def __init__(self, product_service: ProductService, \n                 order_processor: OrderProcessor,\n                 notifications: NotificationService):\n        self.products = product_service\n        self.orders = order_processor\n        self.notifications = notifications\n    \n    def place_order(self, email: str, items: List[Dict]) -> Dict:\n        \"\"\"\n        Place complete order.\n        \n        Args:\n            email: Customer email\n            items: List of {product_id, quantity}\n        \n        Returns:\n            Order result\n        \"\"\"\n        # Calculate total\n        total = 0.0\n        for item in items:\n            product = self.products.get_product(item[\"product_id\"])\n            if not product:\n                return {\"status\": \"error\", \"reason\": \"invalid_product\"}\n            total += product.price * item[\"quantity\"]\n        \n        # Process order\n        result = self.orders.process_order(items, total)\n        \n        # Send notification\n        if result[\"status\"] == \"success\":\n            order_id = result.get(\"transaction_id\", \"unknown\")\n            self.notifications.send_order_confirmation(email, order_id)\n        else:\n            reason = result.get(\"reason\", \"unknown\")\n            self.notifications.send_order_failure(email, reason)\n        \n        return result\n\n# Comprehensive test suite\n\nclass MockDatabase:\n    \"\"\"Mock database for testing.\"\"\"\n    \n    def __init__(self):\n        self.data = {\n            \"products\": {\n                \"prod1\": {\"id\": \"prod1\", \"name\": \"Product 1\", \"price\": 10.0, \"stock\": 100},\n                \"prod2\": {\"id\": \"prod2\", \"name\": \"Product 2\", \"price\": 20.0, \"stock\": 50}\n            }\n        }\n    \n    def get(self, table: str, key: str) -> Optional[Dict]:\n        return self.data.get(table, {}).get(key)\n    \n    def update(self, table: str, key: str, updates: Dict):\n        if table in self.data and key in self.data[table]:\n            self.data[table][key].update(updates)\n\n@pytest.fixture\ndef mock_db():\n    return MockDatabase()\n\n@pytest.fixture\ndef product_service(mock_db):\n    return ProductService(mock_db)\n\n@pytest.fixture\ndef inventory_manager(product_service):\n    return InventoryManager(product_service)\n\n@pytest.fixture\ndef mock_payment():\n    payment = Mock()\n    payment.charge.return_value = {\"status\": \"success\", \"transaction_id\": \"txn_123\"}\n    return payment\n\n@pytest.fixture\ndef order_processor(inventory_manager, mock_payment):\n    return OrderProcessor(inventory_manager, mock_payment)\n\n@pytest.fixture\ndef notification_service():\n    return NotificationService()\n\n@pytest.fixture\ndef ecommerce_system(product_service, order_processor, notification_service):\n    return ECommerceSystem(product_service, order_processor, notification_service)\n\n# Unit tests\n\nclass TestProductService:\n    def test_get_product(self, product_service):\n        product = product_service.get_product(\"prod1\")\n        assert product.name == \"Product 1\"\n        assert product.price == 10.0\n    \n    def test_check_availability_sufficient(self, product_service):\n        assert product_service.check_availability(\"prod1\", 50) is True\n    \n    def test_check_availability_insufficient(self, product_service):\n        assert product_service.check_availability(\"prod1\", 200) is False\n    \n    def test_update_stock(self, product_service):\n        product_service.update_stock(\"prod1\", -10)\n        product = product_service.get_product(\"prod1\")\n        assert product.stock == 90\n\nclass TestInventoryManager:\n    def test_reserve_stock(self, inventory_manager):\n        result = inventory_manager.reserve_stock(\"prod1\", 10)\n        assert result is True\n        assert inventory_manager.reserved[\"prod1\"] == 10\n    \n    def test_commit_reservation(self, inventory_manager, product_service):\n        inventory_manager.reserve_stock(\"prod1\", 10)\n        inventory_manager.commit_reservation(\"prod1\", 10)\n        \n        product = product_service.get_product(\"prod1\")\n        assert product.stock == 90\n\nclass TestOrderProcessor:\n    def test_process_order_success(self, order_processor, mock_payment):\n        items = [{\"product_id\": \"prod1\", \"quantity\": 2}]\n        result = order_processor.process_order(items, 20.0)\n        \n        assert result[\"status\"] == \"success\"\n        mock_payment.charge.assert_called_once_with(20.0)\n    \n    def test_process_order_insufficient_stock(self, order_processor):\n        items = [{\"product_id\": \"prod1\", \"quantity\": 200}]\n        result = order_processor.process_order(items, 2000.0)\n        \n        assert result[\"status\"] == \"failed\"\n        assert result[\"reason\"] == \"insufficient_stock\"\n    \n    def test_process_order_payment_declined(self, order_processor, mock_payment):\n        mock_payment.charge.return_value = {\"status\": \"declined\"}\n        \n        items = [{\"product_id\": \"prod1\", \"quantity\": 2}]\n        result = order_processor.process_order(items, 20.0)\n        \n        assert result[\"status\"] == \"failed\"\n        assert result[\"reason\"] == \"payment_declined\"\n\n# Integration tests\n\nclass TestECommerceSystemIntegration:\n    def test_successful_order_flow(self, ecommerce_system, notification_service):\n        \"\"\"Test complete successful order flow.\"\"\"\n        items = [{\"product_id\": \"prod1\", \"quantity\": 3}]\n        result = ecommerce_system.place_order(\"customer@example.com\", items)\n        \n        assert result[\"status\"] == \"success\"\n        assert len(notification_service.sent_notifications) == 1\n        assert notification_service.sent_notifications[0][\"type\"] == \"order_confirmation\"\n    \n    def test_failed_order_notification(self, ecommerce_system, notification_service):\n        \"\"\"Test failure notification sent.\"\"\"\n        items = [{\"product_id\": \"prod1\", \"quantity\": 200}]\n        result = ecommerce_system.place_order(\"customer@example.com\", items)\n        \n        assert result[\"status\"] == \"failed\"\n        assert len(notification_service.sent_notifications) == 1\n        assert notification_service.sent_notifications[0][\"type\"] == \"order_failure\"\n    \n    def test_stock_rollback_on_payment_failure(self, ecommerce_system, mock_payment, product_service):\n        \"\"\"Test stock is released when payment fails.\"\"\"\n        mock_payment.charge.return_value = {\"status\": \"declined\"}\n        \n        initial_stock = product_service.get_product(\"prod1\").stock\n        \n        items = [{\"product_id\": \"prod1\", \"quantity\": 5}]\n        ecommerce_system.place_order(\"customer@example.com\", items)\n        \n        final_stock = product_service.get_product(\"prod1\").stock\n        assert final_stock == initial_stock  # Stock unchanged\n",
  "hints": [
    "Product model: Use @dataclass with id, name, price, stock fields",
    "ProductService: Needs database dependency, get/check/update methods",
    "InventoryManager: Track reserved stock in dict, reserve/commit/release",
    "OrderProcessor: Reserve → Payment → Commit or Release on failure",
    "Integration test: Test complete flow from place_order to notification",
    "Test rollback: Verify stock unchanged when payment fails"
  ],
  "testCases": [
    {
      "input": "product = Product('p1', 'Test', 10.0, 100)\\nproduct.name",
      "description": "Test Product dataclass",
      "id": "test1",
      "expectedOutput": "'Test'",
      "isHidden": false
    },
    {
      "input": "db = MockDatabase()\\nservice = ProductService(db)\\nproduct = service.get_product('prod1')\\nproduct.price",
      "description": "Test ProductService get_product",
      "id": "test2",
      "expectedOutput": "10.0",
      "isHidden": false
    },
    {
      "input": "db = MockDatabase()\\nservice = ProductService(db)\\ninventory = InventoryManager(service)\\ninventory.reserve_stock('prod1', 10)\\ninventory.reserved['prod1']",
      "description": "Test InventoryManager reserve",
      "id": "test3",
      "expectedOutput": "10",
      "isHidden": false
    },
    {
      "input": "db = MockDatabase()\\nservice = ProductService(db)\\ninventory = InventoryManager(service)\\npayment = Mock()\\npayment.charge.return_value = {'status': 'success', 'transaction_id': 'txn1'}\\nprocessor = OrderProcessor(inventory, payment)\\nresult = processor.process_order([{'product_id': 'prod1', 'quantity': 2}], 20.0)\\nresult['status']",
      "description": "Test OrderProcessor success",
      "id": "test4",
      "expectedOutput": "'success'",
      "isHidden": true
    },
    {
      "input": "notif = NotificationService()\\nnotif.send_order_confirmation('test@ex.com', 'order1')\\nlen(notif.sent_notifications)",
      "description": "Test NotificationService",
      "id": "test5",
      "expectedOutput": "1",
      "isHidden": true
    },
    {
      "input": "db = MockDatabase()\\nservice = ProductService(db)\\ninventory = InventoryManager(service)\\npayment = Mock()\\npayment.charge.return_value = {'status': 'success', 'transaction_id': 'txn1'}\\nprocessor = OrderProcessor(inventory, payment)\\nnotif = NotificationService()\\nsystem = ECommerceSystem(service, processor, notif)\\nresult = system.place_order('test@ex.com', [{'product_id': 'prod1', 'quantity': 1}])\\n(result['status'], len(notif.sent_notifications))",
      "description": "Test ECommerceSystem integration",
      "id": "test6",
      "expectedOutput": "('success', 1)",
      "isHidden": true
    }
  ],
  "language": "python"
}