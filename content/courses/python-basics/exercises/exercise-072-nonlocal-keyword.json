{
  "id": "exercise-072-nonlocal-keyword",
  "lessonId": "lesson-058-nonlocal-keyword",
  "title": "Modifying Enclosing Scope with nonlocal",
  "description": "Master the nonlocal keyword for modifying enclosing scope variables. Build stateful closures.\n\nYour program should:\n1. Use nonlocal to modify enclosing variables\n2. Understand nonlocal vs global differences\n3. Build stateful closures with nonlocal\n4. Handle multiple enclosing levels\n5. Create counters and state machines\n6. Avoid UnboundLocalError\n\nImplement these functions:\n- `create_counter(start)`: Counter closure with nonlocal\n- `make_accumulator(initial)`: Accumulator with add/reset\n- `create_toggle(initial_state)`: Toggle switch\n- `nonlocal_vs_global_demo()`: Compare nonlocal and global\n- `multi_level_nonlocal()`: nonlocal with multiple enclosing levels\n- `state_machine()`: Simple state machine with nonlocal\n\nExample:\n```python\ncounter = create_counter(0)\ncounter()  # 1\ncounter()  # 2\n```",
  "difficulty": "intermediate",
  "points": 20,
  "language": "python",
  "starterCode": "def create_counter(start=0):\n    \"\"\"Create counter closure using nonlocal.\n    \n    Args:\n        start: Starting count value.\n    \n    Returns:\n        Function that increments and returns count.\n    \"\"\"\n    # TODO: Use nonlocal to modify enclosing count\n    # count = start\n    # \n    # def increment():\n    #     nonlocal count\n    #     count += 1\n    #     return count\n    # \n    # return increment\n    \n    pass\n\ndef make_accumulator(initial=0):\n    \"\"\"Create accumulator with add and reset.\n    \n    Args:\n        initial: Initial value.\n    \n    Returns:\n        Dict with 'add', 'reset', 'get' functions.\n    \"\"\"\n    # TODO: Three functions sharing state via nonlocal\n    # total = initial\n    # \n    # def add(value):\n    #     nonlocal total\n    #     total += value\n    #     return total\n    # \n    # def reset():\n    #     nonlocal total\n    #     total = initial\n    # \n    # def get():\n    #     return total\n    # \n    # return {'add': add, 'reset': reset, 'get': get}\n    \n    pass\n\ndef create_toggle(initial_state=False):\n    \"\"\"Create toggle switch using nonlocal.\n    \n    Args:\n        initial_state: Initial on/off state.\n    \n    Returns:\n        Function that toggles state.\n    \"\"\"\n    # TODO: Toggle boolean state\n    # state = initial_state\n    # \n    # def toggle():\n    #     nonlocal state\n    #     state = not state\n    #     return state\n    # \n    # return toggle\n    \n    pass\n\ndef nonlocal_vs_global_demo():\n    \"\"\"Compare nonlocal and global.\n    \n    Returns:\n        Dict showing differences.\n    \"\"\"\n    # TODO: Show nonlocal modifies enclosing, global modifies module\n    # enclosing_var = 10\n    # \n    # def modify_enclosing():\n    #     nonlocal enclosing_var\n    #     enclosing_var += 5\n    # \n    # def read_enclosing():\n    #     return enclosing_var\n    # \n    # modify_enclosing()\n    # return {\n    #     'enclosing_after_nonlocal': read_enclosing()\n    # }\n    \n    pass\n\ndef multi_level_nonlocal():\n    \"\"\"Demonstrate nonlocal with multiple levels.\n    \n    Returns:\n        Value from nested modification.\n    \"\"\"\n    # TODO: nonlocal modifies nearest enclosing\n    # x = 1  # Outer level\n    # \n    # def middle():\n    #     x = 2  # Middle level\n    #     \n    #     def inner():\n    #         nonlocal x  # Modifies middle's x\n    #         x = 3\n    #     \n    #     inner()\n    #     return x  # Middle's x changed to 3\n    # \n    # return middle()\n    \n    pass\n\ndef state_machine():\n    \"\"\"Create simple state machine.\n    \n    Returns:\n        Function that cycles through states.\n    \"\"\"\n    # TODO: State machine with nonlocal\n    # states = ['red', 'yellow', 'green']\n    # current_index = 0\n    # \n    # def next_state():\n    #     nonlocal current_index\n    #     state = states[current_index]\n    #     current_index = (current_index + 1) % len(states)\n    #     return state\n    # \n    # return next_state\n    \n    pass\n\n# Test functions\nprint(\"nonlocal Keyword - Modify Enclosing Scope:\")\nprint(\"=\"*60)\n\nprint(\"\\nCounter with nonlocal:\")\nprint(\"-\"*60)\ncounter = create_counter(0)\nprint(\"counter = create_counter(0)\")\nprint(f\"  counter(): {counter()}\")\nprint(f\"  counter(): {counter()}\")\nprint(f\"  counter(): {counter()}\")\nprint(\"Count persists across calls (closure with nonlocal)\")\n\ncounter2 = create_counter(10)\nprint(\"\\ncounter2 = create_counter(10)\")\nprint(f\"  counter2(): {counter2()}\")\nprint(f\"  counter2(): {counter2()}\")\nprint(\"Each closure has independent state\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Accumulator with Multiple Operations:\")\nprint(\"=\"*60)\naccumulator = make_accumulator(0)\nprint(\"accumulator = make_accumulator(0)\")\nprint(f\"Initial: {accumulator['get']()}\")\nprint(f\"Add 10: {accumulator['add'](10)}\")\nprint(f\"Add 5: {accumulator['add'](5)}\")\nprint(f\"Add 3: {accumulator['add'](3)}\")\nprint(f\"Total: {accumulator['get']()}\")\naccumulator['reset']()\nprint(f\"After reset: {accumulator['get']()}\")\nprint(\"All functions share same 'total' via nonlocal\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Toggle Switch:\")\nprint(\"=\"*60)\ntoggle = create_toggle(False)\nprint(\"toggle = create_toggle(False)\")\nprint(f\"Toggle: {toggle()}\")\nprint(f\"Toggle: {toggle()}\")\nprint(f\"Toggle: {toggle()}\")\nprint(f\"Toggle: {toggle()}\")\nprint(\"State flips each call\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"nonlocal vs global:\")\nprint(\"=\"*60)\nresult = nonlocal_vs_global_demo()\nprint(f\"Enclosing var after nonlocal: {result['enclosing_after_nonlocal']}\")\nprint(\"nonlocal modifies enclosing scope\")\nprint(\"global modifies module-level scope\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Multi-Level nonlocal:\")\nprint(\"=\"*60)\nresult = multi_level_nonlocal()\nprint(f\"Middle x after inner nonlocal: {result}\")\nprint(\"nonlocal modifies nearest enclosing scope\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"State Machine:\")\nprint(\"=\"*60)\ntraffic_light = state_machine()\nprint(\"traffic_light = state_machine()\")\nprint(f\"State: {traffic_light()}\")\nprint(f\"State: {traffic_light()}\")\nprint(f\"State: {traffic_light()}\")\nprint(f\"State: {traffic_light()}\")\nprint(\"Cycles through states: red → yellow → green → red\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Key Concepts:\")\nprint(\"=\"*60)\nprint(\"1. nonlocal: Modify enclosing scope variable\")\nprint(\"2. Without nonlocal: Assignment creates new local\")\nprint(\"3. nonlocal vs global: Different scope targets\")\nprint(\"4. Stateful closures: Maintain state across calls\")\nprint(\"5. Multiple levels: Modifies nearest enclosing\")\nprint(\"6. Shared state: Multiple functions access same variable\")\nprint(\"\\nCommon Use Cases:\")\nprint(\"  - Counters\")\nprint(\"  - Accumulators\")\nprint(\"  - State machines\")\nprint(\"  - Toggle switches\")\nprint(\"  - Cached/memoized functions\")",
  "solution": "def create_counter(start=0):\n    \"\"\"Create counter closure using nonlocal.\"\"\"\n    count = start\n    \n    def increment():\n        nonlocal count\n        count += 1\n        return count\n    \n    return increment\n\ndef make_accumulator(initial=0):\n    \"\"\"Create accumulator with add and reset.\"\"\"\n    total = initial\n    \n    def add(value):\n        nonlocal total\n        total += value\n        return total\n    \n    def reset():\n        nonlocal total\n        total = initial\n    \n    def get():\n        return total\n    \n    return {'add': add, 'reset': reset, 'get': get}\n\ndef create_toggle(initial_state=False):\n    \"\"\"Create toggle switch using nonlocal.\"\"\"\n    state = initial_state\n    \n    def toggle():\n        nonlocal state\n        state = not state\n        return state\n    \n    return toggle\n\ndef nonlocal_vs_global_demo():\n    \"\"\"Compare nonlocal and global.\"\"\"\n    enclosing_var = 10\n    \n    def modify_enclosing():\n        nonlocal enclosing_var\n        enclosing_var += 5\n    \n    def read_enclosing():\n        return enclosing_var\n    \n    modify_enclosing()\n    return {\n        'enclosing_after_nonlocal': read_enclosing()\n    }\n\ndef multi_level_nonlocal():\n    \"\"\"Demonstrate nonlocal with multiple levels.\"\"\"\n    x = 1\n    \n    def middle():\n        x = 2\n        \n        def inner():\n            nonlocal x\n            x = 3\n        \n        inner()\n        return x\n    \n    return middle()\n\ndef state_machine():\n    \"\"\"Create simple state machine.\"\"\"\n    states = ['red', 'yellow', 'green']\n    current_index = 0\n    \n    def next_state():\n        nonlocal current_index\n        state = states[current_index]\n        current_index = (current_index + 1) % len(states)\n        return state\n    \n    return next_state\n\n# Test code as provided",
  "hints": [
    "nonlocal keyword: Declare before modifying enclosing variable",
    "Without nonlocal: Assignment creates new local variable",
    "nonlocal vs global: nonlocal for enclosing, global for module",
    "Stateful closures: Use nonlocal to maintain state",
    "Multiple levels: nonlocal modifies nearest enclosing scope",
    "UnboundLocalError: Happens when modifying without nonlocal"
  ],
  "testCases": [
    {
      "id": "tc1",
      "description": "Counter closure",
      "input": "c = create_counter(5); c(); c()",
      "expectedOutput": "7",
      "isHidden": false
    },
    {
      "id": "tc2",
      "description": "Accumulator",
      "input": "a = make_accumulator(0); a['add'](10); a['add'](5); a['get']()",
      "expectedOutput": "15",
      "isHidden": false
    },
    {
      "id": "tc3",
      "description": "Toggle switch",
      "input": "t = create_toggle(False); t(); t()",
      "expectedOutput": "False",
      "isHidden": false
    },
    {
      "id": "tc4",
      "description": "nonlocal vs global",
      "input": "nonlocal_vs_global_demo()['enclosing_after_nonlocal']",
      "expectedOutput": "15",
      "isHidden": true
    },
    {
      "id": "tc5",
      "description": "Multi-level nonlocal",
      "input": "multi_level_nonlocal()",
      "expectedOutput": "3",
      "isHidden": true
    },
    {
      "id": "tc6",
      "description": "State machine",
      "input": "s = state_machine(); s(); s(); s()",
      "expectedOutput": "'green'",
      "isHidden": true
    }
  ]
}