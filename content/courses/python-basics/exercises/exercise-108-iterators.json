{
  "id": "exercise-108-iterators",
  "lessonId": "lesson-098-iterators",
  "title": "Custom Iterator Workshop",
  "description": "Understand iterators and the iteration protocol. Learn how for loops work under the hood.\n\nYour program should:\n1. Use iter() and next() functions\n2. Understand iterator exhaustion\n3. Create custom iterable classes\n4. Implement __iter__ and __next__ methods\n5. Handle StopIteration exception\n\nImplement these functions:\n- `manual_iteration(iterable)`: Iterate using iter() and next()\n- `peek_first_three(iterable)`: Return first 3 elements without consuming all\n- `CountDown` class: Custom iterator counting down\n- `EvenNumbers` class: Iterator generating even numbers\n- `take_n(iterable, n)`: Take first n elements\n- `skip_n(iterable, n)`: Skip first n elements\n\nExample:\n```python\ncd = CountDown(5)  # Creates iterator\nfor n in cd: print(n)  # 5, 4, 3, 2, 1\n```",
  "difficulty": "advanced",
  "points": 25,
  "language": "python",
  "starterCode": "def manual_iteration(iterable):\n    \"\"\"Iterate manually using iter() and next().\"\"\"\n    # TODO: Manual iteration\n    # iterator = iter(iterable)\n    # result = []\n    # try:\n    #   while True:\n    #     result.append(next(iterator))\n    # except StopIteration:\n    #   pass\n    # return result\n    \n    pass\n\ndef peek_first_three(iterable):\n    \"\"\"Return first 3 elements without consuming entire iterable.\"\"\"\n    # TODO: Use iter() and next()\n    # iterator = iter(iterable)\n    # result = []\n    # for _ in range(3):\n    #   try:\n    #     result.append(next(iterator))\n    #   except StopIteration:\n    #     break\n    # return result\n    \n    pass\n\nclass CountDown:\n    \"\"\"Iterator that counts down from n to 1.\"\"\"\n    \n    def __init__(self, n):\n        # TODO: Store starting value\n        # self.n = n\n        # self.current = n\n        pass\n    \n    def __iter__(self):\n        # TODO: Return self (this object is the iterator)\n        # return self\n        pass\n    \n    def __next__(self):\n        # TODO: Return next value or raise StopIteration\n        # if self.current <= 0:\n        #   raise StopIteration\n        # value = self.current\n        # self.current -= 1\n        # return value\n        pass\n\nclass EvenNumbers:\n    \"\"\"Iterator generating first n even numbers.\"\"\"\n    \n    def __init__(self, count):\n        # TODO: Store count and initialize\n        # self.count = count\n        # self.current = 0\n        # self.generated = 0\n        pass\n    \n    def __iter__(self):\n        # TODO: Return self\n        pass\n    \n    def __next__(self):\n        # TODO: Generate next even number\n        # if self.generated >= self.count:\n        #   raise StopIteration\n        # value = self.current\n        # self.current += 2\n        # self.generated += 1\n        # return value\n        pass\n\ndef take_n(iterable, n):\n    \"\"\"Take first n elements from iterable.\"\"\"\n    # TODO: Use iterator protocol\n    # iterator = iter(iterable)\n    # result = []\n    # for _ in range(n):\n    #   try:\n    #     result.append(next(iterator))\n    #   except StopIteration:\n    #     break\n    # return result\n    \n    pass\n\ndef skip_n(iterable, n):\n    \"\"\"Skip first n elements, return rest as list.\"\"\"\n    # TODO: Skip n elements\n    # iterator = iter(iterable)\n    # for _ in range(n):\n    #   try:\n    #     next(iterator)\n    #   except StopIteration:\n    #     return []\n    # return list(iterator)\n    \n    pass\n\n# Test functions\nprint(\"Manual Iteration:\")\nprint(\"=\"*60)\nitems = [1, 2, 3, 4, 5]\nresult = manual_iteration(items)\nprint(f\"Input: {items}\")\nprint(f\"Manual iteration result: {result}\\n\")\n\nprint(\"=\"*60)\nprint(\"Peek First Three:\")\nprint(\"=\"*60)\ntest_lists = [\n    [1, 2, 3, 4, 5],\n    ['a', 'b'],\n    range(100),\n]\n\nfor items in test_lists:\n    first_three = peek_first_three(items)\n    print(f\"Peeked from {list(items) if not isinstance(items, range) else 'range(100)'}: {first_three}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"CountDown Iterator:\")\nprint(\"=\"*60)\ncd = CountDown(5)\nprint(\"CountDown(5):\")\nfor num in cd:\n    print(num, end=\" \")\nprint(\"\\n\")\n\n# Can't reuse exhausted iterator\nprint(\"Trying to iterate again (exhausted):\")\nfor num in cd:\n    print(num, end=\" \")\nprint(\"(nothing printed - iterator exhausted)\\n\")\n\n# Create new iterator\ncd2 = CountDown(3)\nprint(\"CountDown(3):\")\nfor num in cd2:\n    print(num, end=\" \")\nprint(\"\\n\")\n\nprint(\"=\"*60)\nprint(\"EvenNumbers Iterator:\")\nprint(\"=\"*60)\nevens = EvenNumbers(5)\nprint(\"First 5 even numbers:\")\nfor num in evens:\n    print(num, end=\" \")\nprint(\"\\n\")\n\nevens10 = EvenNumbers(10)\nprint(\"First 10 even numbers:\")\nresult = list(evens10)\nprint(result)\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Take N Elements:\")\nprint(\"=\"*60)\nnumbers = range(100)\nprint(f\"Take 5 from range(100): {take_n(numbers, 5)}\")\nprint(f\"Take 3 from [1,2,3,4,5]: {take_n([1,2,3,4,5], 3)}\")\nprint(f\"Take 10 from [1,2,3]: {take_n([1,2,3], 10)}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Skip N Elements:\")\nprint(\"=\"*60)\ntest_cases = [\n    ([1, 2, 3, 4, 5], 2),\n    ([1, 2, 3, 4, 5], 0),\n    ([1, 2, 3], 5),\n    (range(10), 5),\n]\n\nfor items, n in test_cases:\n    result = skip_n(items, n)\n    items_str = list(items) if not isinstance(items, range) else f'range({items.stop})'\n    print(f\"Skip {n} from {items_str}: {result}\")",
  "solution": "def manual_iteration(iterable):\n    \"\"\"Iterate manually using iter() and next().\"\"\"\n    iterator = iter(iterable)\n    result = []\n    try:\n        while True:\n            result.append(next(iterator))\n    except StopIteration:\n        pass\n    return result\n\ndef peek_first_three(iterable):\n    \"\"\"Return first 3 elements without consuming entire iterable.\"\"\"\n    iterator = iter(iterable)\n    result = []\n    for _ in range(3):\n        try:\n            result.append(next(iterator))\n        except StopIteration:\n            break\n    return result\n\nclass CountDown:\n    \"\"\"Iterator that counts down from n to 1.\"\"\"\n    \n    def __init__(self, n):\n        self.n = n\n        self.current = n\n    \n    def __iter__(self):\n        return self\n    \n    def __next__(self):\n        if self.current <= 0:\n            raise StopIteration\n        value = self.current\n        self.current -= 1\n        return value\n\nclass EvenNumbers:\n    \"\"\"Iterator generating first n even numbers.\"\"\"\n    \n    def __init__(self, count):\n        self.count = count\n        self.current = 0\n        self.generated = 0\n    \n    def __iter__(self):\n        return self\n    \n    def __next__(self):\n        if self.generated >= self.count:\n            raise StopIteration\n        value = self.current\n        self.current += 2\n        self.generated += 1\n        return value\n\ndef take_n(iterable, n):\n    \"\"\"Take first n elements from iterable.\"\"\"\n    iterator = iter(iterable)\n    result = []\n    for _ in range(n):\n        try:\n            result.append(next(iterator))\n        except StopIteration:\n            break\n    return result\n\ndef skip_n(iterable, n):\n    \"\"\"Skip first n elements, return rest as list.\"\"\"\n    iterator = iter(iterable)\n    for _ in range(n):\n        try:\n            next(iterator)\n        except StopIteration:\n            return []\n    return list(iterator)\n\n# Test code as provided",
  "hints": [
    "iter() creates iterator from iterable",
    "next(iterator) gets next value or raises StopIteration",
    "Custom iterator: implement __iter__() and __next__()",
    "__iter__() should return self",
    "__next__() returns next value or raises StopIteration",
    "Iterators can only be used once (exhausted after iteration)"
  ],
  "testCases": [
    {
      "id": "tc1",
      "description": "Manual iteration returns list",
      "input": "manual_iteration([1, 2, 3])",
      "expectedOutput": "[1, 2, 3]",
      "isHidden": false
    },
    {
      "id": "tc2",
      "description": "Peek first three elements",
      "input": "peek_first_three([1, 2, 3, 4, 5])",
      "expectedOutput": "[1, 2, 3]",
      "isHidden": false
    },
    {
      "id": "tc3",
      "description": "CountDown iterator works",
      "input": "list(CountDown(3))",
      "expectedOutput": "[3, 2, 1]",
      "isHidden": false
    },
    {
      "id": "tc4",
      "description": "EvenNumbers generates evens",
      "input": "list(EvenNumbers(4))",
      "expectedOutput": "[0, 2, 4, 6]",
      "isHidden": true
    },
    {
      "id": "tc5",
      "description": "Take n elements",
      "input": "take_n([1, 2, 3, 4, 5], 3)",
      "expectedOutput": "[1, 2, 3]",
      "isHidden": true
    },
    {
      "id": "tc6",
      "description": "Skip n elements",
      "input": "skip_n([1, 2, 3, 4, 5], 2)",
      "expectedOutput": "[3, 4, 5]",
      "isHidden": true
    }
  ]
}