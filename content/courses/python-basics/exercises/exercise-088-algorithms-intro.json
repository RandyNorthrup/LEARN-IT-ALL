{
  "id": "exercise-088-algorithms-intro",
  "lessonId": "lesson-080-algorithms-intro",
  "title": "Algorithm Efficiency Analyzer",
  "description": "Create an algorithm efficiency analyzer that compares different approaches to solving the same problem and demonstrates Big O notation concepts.\n\nYour program should:\n1. Implement multiple algorithms for finding maximum in a list\n2. Measure execution time for different input sizes\n3. Compare linear search vs binary search\n4. Calculate and display algorithm complexity (Big O)\n\nImplement these functions:\n- `find_max_v1(numbers)`: Straightforward max finder\n- `find_max_v2(numbers)`: Sort-based max finder\n- `linear_search(arr, target)`: Search by checking each element\n- `binary_search(arr, target)`: Search using binary divide-and-conquer\n- `compare_algorithms(sizes)`: Compare performance across input sizes\n\nExample output:\n```\nFinding Maximum:\n  Simple approach: 0.0001ms - O(n)\n  Sort approach: 0.0005ms - O(n log n)\n  Winner: Simple approach (5x faster)\n\nSearching:\n  Linear: 0.0010ms - O(n)\n  Binary: 0.0002ms - O(log n)\n  Winner: Binary search (5x faster)\n```",
  "difficulty": "intermediate",
  "points": 20,
  "language": "python",
  "starterCode": "import time\n\ndef find_max_v1(numbers):\n    \"\"\"Find maximum using simple iteration - O(n).\"\"\"\n    # TODO: Handle empty list\n    \n    # TODO: Initialize max to first element\n    \n    # TODO: Iterate through rest and update max\n    \n    # TODO: Return max\n    \n    pass\n\ndef find_max_v2(numbers):\n    \"\"\"Find maximum using sorting - O(n log n).\"\"\"\n    # TODO: Handle empty list\n    \n    # TODO: Sort the list\n    \n    # TODO: Return last element (largest)\n    \n    pass\n\ndef linear_search(arr, target):\n    \"\"\"Search for target using linear search - O(n).\"\"\"\n    # TODO: Loop through array with index\n    \n    # TODO: Return index if found\n    \n    # TODO: Return -1 if not found\n    \n    pass\n\ndef binary_search(arr, target):\n    \"\"\"Search for target using binary search - O(log n).\"\"\"\n    # Note: Array must be sorted!\n    \n    # TODO: Initialize left and right pointers\n    left = 0\n    right = len(arr) - 1\n    \n    # TODO: Loop while left <= right\n    while left <= right:\n        # TODO: Calculate middle index\n        \n        # TODO: Check if middle element is target\n        \n        # TODO: If target < middle, search left half\n        \n        # TODO: If target > middle, search right half\n        \n        pass\n    \n    # TODO: Return -1 if not found\n    return -1\n\ndef measure_time(func, *args):\n    \"\"\"Measure execution time of a function.\"\"\"\n    # TODO: Get start time (time.time())\n    \n    # TODO: Execute function\n    \n    # TODO: Get end time\n    \n    # TODO: Calculate elapsed time in milliseconds\n    \n    # TODO: Return result and time\n    \n    pass\n\ndef compare_max_algorithms(numbers):\n    \"\"\"Compare different max-finding algorithms.\"\"\"\n    # TODO: Measure time for both versions\n    \n    # TODO: Print comparison with Big O notation\n    \n    # TODO: Calculate and show speedup\n    \n    pass\n\ndef compare_search_algorithms(arr, target):\n    \"\"\"Compare linear vs binary search.\"\"\"\n    # TODO: Ensure array is sorted for binary search\n    \n    # TODO: Measure time for both searches\n    \n    # TODO: Print comparison with Big O notation\n    \n    # TODO: Calculate and show speedup\n    \n    pass\n\n# Test the algorithms\nprint(\"Algorithm Efficiency Analyzer\")\nprint(\"=\" * 60)\n\n# Test with different sizes\nprint(\"\\n1. Finding Maximum in Lists:\")\nprint(\"-\" * 60)\n\ntest_sizes = [100, 1000, 10000]\nfor size in test_sizes:\n    numbers = list(range(size))\n    print(f\"\\nList size: {size:,} elements\")\n    compare_max_algorithms(numbers)\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"2. Searching in Lists:\")\nprint(\"-\" * 60)\n\nfor size in test_sizes:\n    arr = list(range(size))\n    target = size - 1  # Search for last element (worst case)\n    print(f\"\\nList size: {size:,} elements (searching for {target})\")\n    compare_search_algorithms(arr, target)\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"3. Big O Notation Summary:\")\nprint(\"-\" * 60)\nprint(\"\"\"\nO(1)        - Constant time (array access)\nO(log n)    - Logarithmic (binary search)\nO(n)        - Linear (simple loop)\nO(n log n)  - Linearithmic (efficient sorting)\nO(n²)       - Quadratic (nested loops)\nO(2^n)      - Exponential (recursive fibonacci)\n\nBest to Worst: O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2^n)\n\"\"\")",
  "solution": "import time\n\ndef find_max_v1(numbers):\n    \"\"\"Find maximum using simple iteration - O(n).\"\"\"\n    if not numbers:\n        return None\n    \n    max_num = numbers[0]\n    for num in numbers[1:]:\n        if num > max_num:\n            max_num = num\n    \n    return max_num\n\ndef find_max_v2(numbers):\n    \"\"\"Find maximum using sorting - O(n log n).\"\"\"\n    if not numbers:\n        return None\n    \n    sorted_numbers = sorted(numbers)\n    return sorted_numbers[-1]\n\ndef linear_search(arr, target):\n    \"\"\"Search for target using linear search - O(n).\"\"\"\n    for i, value in enumerate(arr):\n        if value == target:\n            return i\n    return -1\n\ndef binary_search(arr, target):\n    \"\"\"Search for target using binary search - O(log n).\"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == target:\n            return mid\n        elif target < arr[mid]:\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return -1\n\ndef measure_time(func, *args):\n    \"\"\"Measure execution time of a function.\"\"\"\n    start = time.time()\n    result = func(*args)\n    end = time.time()\n    elapsed_ms = (end - start) * 1000\n    return result, elapsed_ms\n\ndef compare_max_algorithms(numbers):\n    \"\"\"Compare different max-finding algorithms.\"\"\"\n    result1, time1 = measure_time(find_max_v1, numbers)\n    result2, time2 = measure_time(find_max_v2, numbers)\n    \n    print(f\"  Simple iteration: {time1:.4f}ms - O(n)\")\n    print(f\"  Sort-based:       {time2:.4f}ms - O(n log n)\")\n    \n    if time1 < time2:\n        speedup = time2 / time1 if time1 > 0 else float('inf')\n        print(f\"  Winner: Simple iteration ({speedup:.1f}x faster)\")\n    else:\n        speedup = time1 / time2 if time2 > 0 else float('inf')\n        print(f\"  Winner: Sort-based ({speedup:.1f}x faster)\")\n\ndef compare_search_algorithms(arr, target):\n    \"\"\"Compare linear vs binary search.\"\"\"\n    # Ensure sorted for binary search\n    sorted_arr = sorted(arr)\n    \n    result1, time1 = measure_time(linear_search, arr, target)\n    result2, time2 = measure_time(binary_search, sorted_arr, target)\n    \n    print(f\"  Linear search:  {time1:.4f}ms - O(n)\")\n    print(f\"  Binary search:  {time2:.4f}ms - O(log n)\")\n    \n    if time2 < time1:\n        speedup = time1 / time2 if time2 > 0 else float('inf')\n        print(f\"  Winner: Binary search ({speedup:.1f}x faster)\")\n    else:\n        speedup = time2 / time1 if time1 > 0 else float('inf')\n        print(f\"  Winner: Linear search ({speedup:.1f}x faster)\")\n\n# Test the algorithms\nprint(\"Algorithm Efficiency Analyzer\")\nprint(\"=\" * 60)\n\nprint(\"\\n1. Finding Maximum in Lists:\")\nprint(\"-\" * 60)\n\ntest_sizes = [100, 1000, 10000]\nfor size in test_sizes:\n    numbers = list(range(size))\n    print(f\"\\nList size: {size:,} elements\")\n    compare_max_algorithms(numbers)\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"2. Searching in Lists:\")\nprint(\"-\" * 60)\n\nfor size in test_sizes:\n    arr = list(range(size))\n    target = size - 1\n    print(f\"\\nList size: {size:,} elements (searching for {target})\")\n    compare_search_algorithms(arr, target)\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"3. Big O Notation Summary:\")\nprint(\"-\" * 60)\nprint(\"\"\"\nO(1)        - Constant time (array access)\nO(log n)    - Logarithmic (binary search)\nO(n)        - Linear (simple loop)\nO(n log n)  - Linearithmic (efficient sorting)\nO(n²)       - Quadratic (nested loops)\nO(2^n)      - Exponential (recursive fibonacci)\n\nBest to Worst: O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2^n)\n\"\"\")",
  "hints": [
    "For find_max_v1, use a simple loop: max_num = numbers[0], then iterate and update if num > max_num",
    "For find_max_v2, use sorted(numbers)[-1] to get the last (largest) element after sorting",
    "For linear_search, use enumerate() to get both index and value: for i, val in enumerate(arr)",
    "For binary_search, calculate mid as (left + right) // 2, then adjust left or right based on comparison",
    "Measure time with: start = time.time(), run function, end = time.time(), elapsed = (end - start) * 1000",
    "Binary search only works on sorted arrays - remember to sort before calling it"
  ],
  "testCases": [
    {
      "id": "tc1",
      "description": "find_max_v1 finds maximum correctly",
      "input": "find_max_v1([3, 7, 2, 9, 1])",
      "expectedOutput": "9",
      "isHidden": false
    },
    {
      "id": "tc2",
      "description": "linear_search finds target index",
      "input": "linear_search([10, 20, 30, 40], 30)",
      "expectedOutput": "2",
      "isHidden": false
    },
    {
      "id": "tc3",
      "description": "binary_search finds target in sorted array",
      "input": "binary_search([1, 3, 5, 7, 9], 7)",
      "expectedOutput": "3",
      "isHidden": false
    },
    {
      "id": "tc4",
      "description": "linear_search returns -1 when not found",
      "input": "linear_search([1, 2, 3], 5)",
      "expectedOutput": "-1",
      "isHidden": true
    },
    {
      "id": "tc5",
      "description": "binary_search returns -1 when not found",
      "input": "binary_search([1, 3, 5, 7], 6)",
      "expectedOutput": "-1",
      "isHidden": true
    }
  ]
}