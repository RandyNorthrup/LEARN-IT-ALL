{
  "id": "exercise-128-list-memory-performance",
  "lessonId": "lesson-118-list-memory-performance",
  "title": "List Memory and Performance",
  "description": "Understand list memory usage and optimize performance.\n\nYour program should:\n1. Understand time complexity of operations\n2. Compare operation performance\n3. Optimize list operations\n4. Choose efficient alternatives\n5. Measure memory usage\n6. Apply performance best practices\n\nImplement these functions:\n- `operation_complexity()`: Show time complexity\n- `compare_operations()`: Benchmark operations\n- `optimization_examples()`: Efficient patterns\n- `memory_considerations()`: Memory-efficient code\n- `generator_vs_list()`: When to use generators\n- `performance_tips()`: Best practices\n\nExample:\n```python\nlist[i]  # O(1)\nlist.append(x)  # O(1)\nx in list  # O(n)\nlist.sort()  # O(n log n)\n```",
  "difficulty": "advanced",
  "points": 25,
  "language": "python",
  "starterCode": "def operation_complexity():\n    \"\"\"Demonstrate time complexity of operations.\n    \n    Returns:\n        Dict with complexity info.\n    \"\"\"\n    # TODO: Operation complexity\n    # complexities = {\n    #     'index_access': 'O(1) - Direct memory access',\n    #     'append': 'O(1) amortized - Occasional resize',\n    #     'pop_last': 'O(1) - Remove from end',\n    #     'insert_0': 'O(n) - Shift all elements',\n    #     'pop_0': 'O(n) - Shift all elements',\n    #     'search': 'O(n) - Check each element',\n    #     'membership': 'O(n) - Linear search',\n    #     'copy': 'O(n) - Copy all elements',\n    #     'sort': 'O(n log n) - Timsort algorithm',\n    #     'reverse': 'O(n) - Swap all pairs'\n    # }\n    # \n    # # Demonstrate O(1) operations\n    # lst = list(range(1000))\n    # fast_ops = {\n    #     'access': lst[500],\n    #     'append': None,  # lst.append returns None\n    #     'pop_last': None\n    # }\n    # \n    # # Demonstrate O(n) operations\n    # slow_ops = {\n    #     'search': 500 in lst,\n    #     'insert_0': 'Shifts all elements',\n    #     'copy': 'Copies all elements'\n    # }\n    # \n    # return {\n    #     'complexities': complexities,\n    #     'fast_operations': fast_ops,\n    #     'slow_operations': slow_ops\n    # }\n    pass\n\ndef compare_operations():\n    \"\"\"Compare performance of similar operations.\n    \n    Returns:\n        Dict with operation comparisons.\n    \"\"\"\n    # TODO: Compare operations\n    # # Building list: append vs comprehension\n    # # append approach\n    # result1 = []\n    # for i in range(100):\n    #     result1.append(i**2)\n    # \n    # # comprehension (faster)\n    # result2 = [i**2 for i in range(100)]\n    # \n    # # String concatenation\n    # # Bad: concatenation in loop\n    # parts = ['a', 'b', 'c', 'd', 'e']\n    # slow = ''\n    # for part in parts:\n    #     slow += part  # Creates new string each time\n    # \n    # # Good: join (much faster)\n    # fast = ''.join(parts)\n    # \n    # # Membership testing\n    # nums_list = list(range(1000))\n    # nums_set = set(range(1000))\n    # \n    # # List: O(n)\n    # list_check = 999 in nums_list\n    # \n    # # Set: O(1) - much faster\n    # set_check = 999 in nums_set\n    # \n    # # Removal from beginning\n    # # Bad: pop(0) is O(n)\n    # lst = list(range(100))\n    # # first = lst.pop(0)  # Shifts all elements\n    # \n    # # Good: use deque for queue operations\n    # from collections import deque\n    # dq = deque(range(100))\n    # first = dq.popleft()  # O(1)\n    # \n    # return {\n    #     'append_vs_comp': result1 == result2,\n    #     'concat_vs_join': slow == fast,\n    #     'list_vs_set': list_check == set_check,\n    #     'deque_first': first,\n    #     'recommendation': 'Use comprehensions, join(), sets, deque'\n    # }\n    pass\n\ndef optimization_examples():\n    \"\"\"Show optimization patterns.\n    \n    Returns:\n        Dict with optimized examples.\n    \"\"\"\n    # TODO: Optimization examples\n    # # SLOW: Check if any element matches\n    # nums = list(range(1000))\n    # # has_even = False\n    # # for num in nums:\n    # #     if num % 2 == 0:\n    # #         has_even = True\n    # #         break\n    # \n    # # FAST: Use any()\n    # has_even_fast = any(num % 2 == 0 for num in nums)\n    # \n    # # SLOW: Check if all match\n    # # all_positive = True\n    # # for num in nums:\n    # #     if num < 0:\n    # #         all_positive = False\n    # #         break\n    # \n    # # FAST: Use all()\n    # all_positive_fast = all(num >= 0 for num in nums)\n    # \n    # # SLOW: Build list then sum\n    # squares = [x**2 for x in range(100)]\n    # total_slow = sum(squares)\n    # \n    # # FAST: Generator expression (no intermediate list)\n    # total_fast = sum(x**2 for x in range(100))\n    # \n    # # SLOW: Multiple passes\n    # nums = [1, 2, 3, 4, 5, 6]\n    # evens = [x for x in nums if x % 2 == 0]\n    # doubled = [x * 2 for x in evens]\n    # \n    # # FAST: Single pass\n    # result = [x * 2 for x in nums if x % 2 == 0]\n    # \n    # return {\n    #     'has_even': has_even_fast,\n    #     'all_positive': all_positive_fast,\n    #     'totals_equal': total_slow == total_fast,\n    #     'multi_pass': doubled,\n    #     'single_pass': result,\n    #     'passes_equal': doubled == result\n    # }\n    pass\n\ndef memory_considerations():\n    \"\"\"Memory-efficient patterns.\n    \n    Returns:\n        Dict with memory patterns.\n    \"\"\"\n    # TODO: Memory considerations\n    # # MEMORY HEAVY: Store all values\n    # large_list = [x**2 for x in range(10000)]\n    # first_10 = large_list[:10]\n    # \n    # # MEMORY LIGHT: Generate on demand\n    # large_gen = (x**2 for x in range(10000))\n    # first_10_gen = []\n    # for i, val in enumerate(large_gen):\n    #     if i >= 10:\n    #         break\n    #     first_10_gen.append(val)\n    # \n    # # Avoid duplicating large lists\n    # original = list(range(1000))\n    # \n    # # BAD: Creates copy\n    # # backup = original[:]\n    # \n    # # GOOD: Only copy if needed\n    # # Process original directly when possible\n    # \n    # # Use del to free memory\n    # temp = list(range(1000))\n    # result = sum(temp)\n    # del temp  # Free memory immediately\n    # \n    # # Reuse lists instead of creating new ones\n    # buffer = []\n    # for i in range(5):\n    #     buffer.clear()  # Reuse same list\n    #     for j in range(10):\n    #         buffer.append(j)\n    #     # process buffer\n    # \n    # return {\n    #     'first_10_equal': first_10 == first_10_gen,\n    #     'result': result,\n    #     'tip': 'Use generators for large sequences'\n    # }\n    pass\n\ndef generator_vs_list():\n    \"\"\"Compare generators and lists.\n    \n    Returns:\n        Dict comparing approaches.\n    \"\"\"\n    # TODO: Generator vs list\n    # # List: All values in memory\n    # list_comp = [x**2 for x in range(100)]\n    # list_sum = sum(list_comp)\n    # list_len = len(list_comp)\n    # \n    # # Generator: Values on demand\n    # gen_exp = (x**2 for x in range(100))\n    # gen_sum = sum(gen_exp)  # Consumes generator\n    # # Can't get len of generator\n    # \n    # # When to use list:\n    # # - Need multiple passes\n    # # - Need len(), indexing, slicing\n    # # - Small dataset\n    # \n    # use_list = {\n    #     'multiple_passes': 'Need to iterate multiple times',\n    #     'random_access': 'Need list[i]',\n    #     'small_data': 'Memory not a concern'\n    # }\n    # \n    # # When to use generator:\n    # # - Large dataset\n    # # - Single pass\n    # # - Pipeline operations\n    # \n    # use_gen = {\n    #     'large_data': 'Save memory',\n    #     'single_pass': 'Process once',\n    #     'pipeline': 'Chain operations'\n    # }\n    # \n    # return {\n    #     'sums_equal': list_sum == gen_sum,\n    #     'list_allows_len': True,\n    #     'use_list': use_list,\n    #     'use_generator': use_gen\n    # }\n    pass\n\ndef performance_tips():\n    \"\"\"Performance best practices.\n    \n    Returns:\n        Dict with tips and examples.\n    \"\"\"\n    # TODO: Performance tips\n    # tips = {\n    #     'tip1': 'Use list comprehensions over loops',\n    #     'tip2': 'Use any()/all() for early termination',\n    #     'tip3': 'Use set for membership testing',\n    #     'tip4': 'Use deque for queue operations',\n    #     'tip5': 'Use generators for large datasets',\n    #     'tip6': 'Avoid repeated list.pop(0)',\n    #     'tip7': 'Use join() not += for strings',\n    #     'tip8': 'Preallocate with [None]*n if size known',\n    #     'tip9': 'Use sorted() to avoid copying',\n    #     'tip10': 'Profile before optimizing'\n    # }\n    # \n    # # Example: Set vs List for membership\n    # items_list = list(range(1000))\n    # items_set = set(range(1000))\n    # \n    # # 1000 membership tests\n    # list_approach = 'O(n) per test - slow for large lists'\n    # set_approach = 'O(1) per test - fast'\n    # \n    # # Example: Comprehension vs loop\n    # # Loop approach\n    # result_loop = []\n    # for i in range(100):\n    #     result_loop.append(i**2)\n    # \n    # # Comprehension (faster)\n    # result_comp = [i**2 for i in range(100)]\n    # \n    # return {\n    #     'tips': tips,\n    #     'membership': {'list': list_approach, 'set': set_approach},\n    #     'results_equal': result_loop == result_comp,\n    #     'golden_rule': 'Readable code first, optimize if needed'\n    # }\n    pass\n\n# Test code\nprint(\"List Memory and Performance:\")\nprint(\"=\"*60)\n\nprint(\"\\nOperation Complexity:\")\nprint(\"-\"*60)\ncomplexity = operation_complexity()\nprint(\"Time Complexities:\")\nfor op, desc in complexity['complexities'].items():\n    print(f\"  {op:15s}: {desc}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Compare Operations:\")\nprint(\"=\"*60)\ncompare = compare_operations()\nfor name, value in compare.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Optimization Examples:\")\nprint(\"=\"*60)\nopt = optimization_examples()\nfor name, value in opt.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Memory Considerations:\")\nprint(\"=\"*60)\nmem = memory_considerations()\nfor name, value in mem.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Generator vs List:\")\nprint(\"=\"*60)\ngen_list = generator_vs_list()\nprint(f\"Sums equal: {gen_list['sums_equal']}\")\nprint(\"\\nUse list when:\")\nfor key, val in gen_list['use_list'].items():\n    print(f\"  - {val}\")\nprint(\"\\nUse generator when:\")\nfor key, val in gen_list['use_generator'].items():\n    print(f\"  - {val}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Performance Tips:\")\nprint(\"=\"*60)\ntips = performance_tips()\nprint(\"Best Practices:\")\nfor tip, desc in tips['tips'].items():\n    print(f\"  {tip}: {desc}\")\nprint(f\"\\n{tips['golden_rule']}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Key Takeaways:\")\nprint(\"=\"*60)\nprint(\"Fast Operations (O(1)):\")\nprint(\"  - list[i]: Direct access\")\nprint(\"  - list.append(x): Add to end\")\nprint(\"  - list.pop(): Remove last\")\nprint(\"\\nSlow Operations (O(n)):\")\nprint(\"  - x in list: Search all\")\nprint(\"  - list.insert(0, x): Shift all\")\nprint(\"  - list.pop(0): Shift all\")\nprint(\"\\nAlternatives:\")\nprint(\"  - Set for membership: O(1) vs O(n)\")\nprint(\"  - Deque for queues: O(1) vs O(n)\")\nprint(\"  - Generators for memory: Lazy vs eager\")\nprint(\"\\nRemember: Profile before optimizing!\")",
  "solution": "def operation_complexity():\n    complexities = {\n        'index_access': 'O(1) - Direct memory access',\n        'append': 'O(1) amortized - Occasional resize',\n        'pop_last': 'O(1) - Remove from end',\n        'insert_0': 'O(n) - Shift all elements',\n        'pop_0': 'O(n) - Shift all elements',\n        'search': 'O(n) - Check each element',\n        'membership': 'O(n) - Linear search',\n        'copy': 'O(n) - Copy all elements',\n        'sort': 'O(n log n) - Timsort algorithm',\n        'reverse': 'O(n) - Swap all pairs'\n    }\n    \n    lst = list(range(1000))\n    fast_ops = {\n        'access': lst[500],\n        'append': None,\n        'pop_last': None\n    }\n    \n    slow_ops = {\n        'search': 500 in lst,\n        'insert_0': 'Shifts all elements',\n        'copy': 'Copies all elements'\n    }\n    \n    return {\n        'complexities': complexities,\n        'fast_operations': fast_ops,\n        'slow_operations': slow_ops\n    }\n\ndef compare_operations():\n    result1 = []\n    for i in range(100):\n        result1.append(i**2)\n    \n    result2 = [i**2 for i in range(100)]\n    \n    parts = ['a', 'b', 'c', 'd', 'e']\n    slow = ''\n    for part in parts:\n        slow += part\n    \n    fast = ''.join(parts)\n    \n    nums_list = list(range(1000))\n    nums_set = set(range(1000))\n    \n    list_check = 999 in nums_list\n    set_check = 999 in nums_set\n    \n    from collections import deque\n    dq = deque(range(100))\n    first = dq.popleft()\n    \n    return {\n        'append_vs_comp': result1 == result2,\n        'concat_vs_join': slow == fast,\n        'list_vs_set': list_check == set_check,\n        'deque_first': first,\n        'recommendation': 'Use comprehensions, join(), sets, deque'\n    }\n\ndef optimization_examples():\n    nums = list(range(1000))\n    has_even_fast = any(num % 2 == 0 for num in nums)\n    all_positive_fast = all(num >= 0 for num in nums)\n    \n    squares = [x**2 for x in range(100)]\n    total_slow = sum(squares)\n    total_fast = sum(x**2 for x in range(100))\n    \n    nums = [1, 2, 3, 4, 5, 6]\n    evens = [x for x in nums if x % 2 == 0]\n    doubled = [x * 2 for x in evens]\n    result = [x * 2 for x in nums if x % 2 == 0]\n    \n    return {\n        'has_even': has_even_fast,\n        'all_positive': all_positive_fast,\n        'totals_equal': total_slow == total_fast,\n        'multi_pass': doubled,\n        'single_pass': result,\n        'passes_equal': doubled == result\n    }\n\ndef memory_considerations():\n    large_list = [x**2 for x in range(10000)]\n    first_10 = large_list[:10]\n    \n    large_gen = (x**2 for x in range(10000))\n    first_10_gen = []\n    for i, val in enumerate(large_gen):\n        if i >= 10:\n            break\n        first_10_gen.append(val)\n    \n    original = list(range(1000))\n    temp = list(range(1000))\n    result = sum(temp)\n    del temp\n    \n    buffer = []\n    for i in range(5):\n        buffer.clear()\n        for j in range(10):\n            buffer.append(j)\n    \n    return {\n        'first_10_equal': first_10 == first_10_gen,\n        'result': result,\n        'tip': 'Use generators for large sequences'\n    }\n\ndef generator_vs_list():\n    list_comp = [x**2 for x in range(100)]\n    list_sum = sum(list_comp)\n    list_len = len(list_comp)\n    \n    gen_exp = (x**2 for x in range(100))\n    gen_sum = sum(gen_exp)\n    \n    use_list = {\n        'multiple_passes': 'Need to iterate multiple times',\n        'random_access': 'Need list[i]',\n        'small_data': 'Memory not a concern'\n    }\n    \n    use_gen = {\n        'large_data': 'Save memory',\n        'single_pass': 'Process once',\n        'pipeline': 'Chain operations'\n    }\n    \n    return {\n        'sums_equal': list_sum == gen_sum,\n        'list_allows_len': True,\n        'use_list': use_list,\n        'use_generator': use_gen\n    }\n\ndef performance_tips():\n    tips = {\n        'tip1': 'Use list comprehensions over loops',\n        'tip2': 'Use any()/all() for early termination',\n        'tip3': 'Use set for membership testing',\n        'tip4': 'Use deque for queue operations',\n        'tip5': 'Use generators for large datasets',\n        'tip6': 'Avoid repeated list.pop(0)',\n        'tip7': 'Use join() not += for strings',\n        'tip8': 'Preallocate with [None]*n if size known',\n        'tip9': 'Use sorted() to avoid copying',\n        'tip10': 'Profile before optimizing'\n    }\n    \n    items_list = list(range(1000))\n    items_set = set(range(1000))\n    \n    list_approach = 'O(n) per test - slow for large lists'\n    set_approach = 'O(1) per test - fast'\n    \n    result_loop = []\n    for i in range(100):\n        result_loop.append(i**2)\n    \n    result_comp = [i**2 for i in range(100)]\n    \n    return {\n        'tips': tips,\n        'membership': {'list': list_approach, 'set': set_approach},\n        'results_equal': result_loop == result_comp,\n        'golden_rule': 'Readable code first, optimize if needed'\n    }",
  "hints": [
    "O(1) operations: index, append, pop last - very fast",
    "O(n) operations: search, insert(0), pop(0) - slow for large lists",
    "Use set for membership testing - O(1) vs O(n)",
    "Use deque for queue operations - O(1) popleft() vs O(n) pop(0)",
    "Use generators for large sequences - saves memory",
    "Profile before optimizing - measure, don't guess"
  ],
  "testCases": [
    {
      "id": "tc1",
      "description": "Fast access",
      "input": "operation_complexity()['fast_operations']['access']",
      "expectedOutput": "500",
      "isHidden": false
    },
    {
      "id": "tc2",
      "description": "Operations equal",
      "input": "compare_operations()['append_vs_comp']",
      "expectedOutput": "True",
      "isHidden": false
    },
    {
      "id": "tc3",
      "description": "Optimization equal",
      "input": "optimization_examples()['passes_equal']",
      "expectedOutput": "True",
      "isHidden": false
    },
    {
      "id": "tc4",
      "description": "Memory efficient",
      "input": "memory_considerations()['first_10_equal']",
      "expectedOutput": "True",
      "isHidden": true
    },
    {
      "id": "tc5",
      "description": "Generator equals",
      "input": "generator_vs_list()['sums_equal']",
      "expectedOutput": "True",
      "isHidden": true
    },
    {
      "id": "tc6",
      "description": "Tips equal",
      "input": "performance_tips()['results_equal']",
      "expectedOutput": "True",
      "isHidden": true
    }
  ]
}