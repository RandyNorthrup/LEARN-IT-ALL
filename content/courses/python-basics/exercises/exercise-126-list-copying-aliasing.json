{
  "id": "exercise-126-list-copying-aliasing",
  "lessonId": "lesson-116-list-copying-aliasing",
  "title": "List Copying and Aliasing",
  "description": "Understand list references, shallow vs deep copying, and avoid aliasing bugs.\n\nYour program should:\n1. Differentiate assignment vs copying\n2. Create shallow copies correctly\n3. Identify shallow copy limitations\n4. Use deep copy for nested structures\n5. Avoid common aliasing bugs\n6. Choose appropriate copy method\n\nImplement these functions:\n- `aliasing_demo()`: Show assignment creates alias\n- `shallow_copy_methods()`: Four ways to shallow copy\n- `shallow_copy_problem()`: Nested structure issue\n- `deep_copy_solution()`: When deep copy needed\n- `safe_function_params()`: Avoid param mutation\n- `testing_identity()`: Use is vs ==\n\nExample:\n```python\nlist2 = list1  # Alias!\nlist2 = list1[:]  # Shallow copy\nimport copy\nlist2 = copy.deepcopy(list1)  # Deep\n```",
  "difficulty": "intermediate",
  "points": 20,
  "language": "python",
  "starterCode": "def aliasing_demo():\n    \"\"\"Show assignment creates alias.\n    \n    Returns:\n        Dict showing aliasing behavior.\n    \"\"\"\n    # TODO: Aliasing demonstration\n    # list1 = [1, 2, 3]\n    # list2 = list1  # Alias, not copy!\n    # \n    # # Same object?\n    # same_id = id(list1) == id(list2)\n    # \n    # # Modify through list2\n    # list2.append(4)\n    # list1_after = list1.copy()\n    # list2_after = list2.copy()\n    # \n    # # Modify through list1\n    # list1[0] = 99\n    # list1_final = list1.copy()\n    # list2_final = list2.copy()\n    # \n    # return {\n    #     'same_id': same_id,\n    #     'list1_after_list2_append': list1_after,\n    #     'list2_after_list2_append': list2_after,\n    #     'list1_after_list1_modify': list1_final,\n    #     'list2_after_list1_modify': list2_final\n    # }\n    pass\n\ndef shallow_copy_methods():\n    \"\"\"Four ways to create shallow copy.\n    \n    Returns:\n        Dict showing all methods work.\n    \"\"\"\n    # TODO: Shallow copy methods\n    # original = [1, 2, 3, 4, 5]\n    # \n    # # Method 1: Slice notation [:]\n    # copy1 = original[:]\n    # copy1.append(6)\n    # slice_original = original.copy()\n    # slice_copy = copy1.copy()\n    # \n    # # Method 2: list() constructor\n    # copy2 = list(original)\n    # copy2[0] = 99\n    # list_original = original.copy()\n    # list_copy = copy2.copy()\n    # \n    # # Method 3: .copy() method\n    # copy3 = original.copy()\n    # copy3.append(7)\n    # method_original = original.copy()\n    # method_copy = copy3.copy()\n    # \n    # # Method 4: copy.copy()\n    # import copy\n    # copy4 = copy.copy(original)\n    # copy4[0] = 88\n    # module_original = original.copy()\n    # module_copy = copy4.copy()\n    # \n    # # All create independent copies\n    # all_independent = (\n    #     slice_original == [1, 2, 3, 4, 5] and\n    #     list_original == [1, 2, 3, 4, 5] and\n    #     method_original == [1, 2, 3, 4, 5] and\n    #     module_original == [1, 2, 3, 4, 5]\n    # )\n    # \n    # return {\n    #     'slice_method': slice_copy,\n    #     'list_constructor': list_copy,\n    #     'copy_method': method_copy,\n    #     'copy_module': module_copy,\n    #     'all_independent': all_independent\n    # }\n    pass\n\ndef shallow_copy_problem():\n    \"\"\"Show shallow copy limitation with nested lists.\n    \n    Returns:\n        Dict demonstrating the problem.\n    \"\"\"\n    # TODO: Shallow copy problem\n    # # Shallow copy with nested list\n    # original = [[1, 2], [3, 4]]\n    # shallow = original[:]\n    # \n    # # Nested lists share reference!\n    # nested_same_id = id(original[0]) == id(shallow[0])\n    # \n    # # Modifying nested affects both\n    # shallow[0][0] = 99\n    # original_affected = original.copy()\n    # shallow_copy = shallow.copy()\n    # \n    # # Replacing entire nested list is safe\n    # original2 = [[1, 2], [3, 4]]\n    # shallow2 = original2[:]\n    # shallow2[0] = [99, 99]  # Replace, not modify\n    # original2_safe = original2.copy()\n    # shallow2_changed = shallow2.copy()\n    # \n    # return {\n    #     'nested_same_id': nested_same_id,\n    #     'original_affected': original_affected,\n    #     'shallow_affected': shallow_copy,\n    #     'original2_unchanged': original2_safe,\n    #     'shallow2_changed': shallow2_changed\n    # }\n    pass\n\ndef deep_copy_solution():\n    \"\"\"Use deep copy for nested structures.\n    \n    Returns:\n        Dict showing deep copy protects nested.\n    \"\"\"\n    # TODO: Deep copy\n    # import copy\n    # \n    # # Deep copy nested list\n    # original = [[1, 2], [3, 4]]\n    # deep = copy.deepcopy(original)\n    # \n    # # Nested lists are different objects\n    # nested_different_id = id(original[0]) != id(deep[0])\n    # \n    # # Modifying nested - original safe\n    # deep[0][0] = 99\n    # original_unchanged = original.copy()\n    # deep_modified = deep.copy()\n    # \n    # # Complex nested structure\n    # original = [[1, [2, 3]], [4, [5, 6]]]\n    # deep = copy.deepcopy(original)\n    # deep[0][1][0] = 999\n    # complex_original = original.copy()\n    # complex_deep = deep.copy()\n    # \n    # return {\n    #     'nested_different_id': nested_different_id,\n    #     'original_unchanged': original_unchanged,\n    #     'deep_modified': deep_modified,\n    #     'complex_original_safe': complex_original,\n    #     'complex_deep_changed': complex_deep\n    # }\n    pass\n\ndef safe_function_params():\n    \"\"\"Avoid mutating function parameters.\n    \n    Returns:\n        Dict showing safe patterns.\n    \"\"\"\n    # TODO: Safe function parameters\n    # # UNSAFE: Modifies original\n    # def unsafe_process(data):\n    #     data.append(999)\n    #     return data\n    # \n    # original = [1, 2, 3]\n    # result = unsafe_process(original)\n    # unsafe_original = original.copy()\n    # \n    # # SAFE: Create copy first\n    # def safe_process(data):\n    #     data_copy = data.copy()\n    #     data_copy.append(999)\n    #     return data_copy\n    # \n    # original = [1, 2, 3]\n    # result = safe_process(original)\n    # safe_original = original.copy()\n    # safe_result = result.copy()\n    # \n    # # Default argument bug\n    # results = []\n    # \n    # def buggy_append(item, lst=[]):\n    #     lst.append(item)\n    #     return lst\n    # \n    # r1 = buggy_append(1)\n    # r2 = buggy_append(2)\n    # results.append((r1.copy(), r2.copy()))\n    # \n    # # Fixed version\n    # def safe_append(item, lst=None):\n    #     if lst is None:\n    #         lst = []\n    #     lst.append(item)\n    #     return lst\n    # \n    # s1 = safe_append(1)\n    # s2 = safe_append(2)\n    # \n    # return {\n    #     'unsafe_mutated': unsafe_original,\n    #     'safe_unchanged': safe_original,\n    #     'safe_result': safe_result,\n    #     'buggy_r1': results[0][0],\n    #     'buggy_r2': results[0][1],\n    #     'safe_s1': s1,\n    #     'safe_s2': s2\n    # }\n    pass\n\ndef testing_identity():\n    \"\"\"Use 'is' vs '==' correctly.\n    \n    Returns:\n        Dict showing identity vs equality.\n    \"\"\"\n    # TODO: Identity testing\n    # # Aliasing: same object\n    # list1 = [1, 2, 3]\n    # list2 = list1\n    # alias_is = list1 is list2\n    # alias_equals = list1 == list2\n    # \n    # # Shallow copy: different objects, same content\n    # list1 = [1, 2, 3]\n    # list3 = list1[:]\n    # copy_is = list1 is list3\n    # copy_equals = list1 == list3\n    # \n    # # Different content\n    # list1 = [1, 2, 3]\n    # list4 = [1, 2, 4]\n    # diff_is = list1 is list4\n    # diff_equals = list1 == list4\n    # \n    # # Checking for None\n    # value = None\n    # is_none = value is None  # Correct\n    # equals_none = value == None  # Works but not pythonic\n    # \n    # return {\n    #     'alias_is': alias_is,\n    #     'alias_equals': alias_equals,\n    #     'copy_is': copy_is,\n    #     'copy_equals': copy_equals,\n    #     'diff_is': diff_is,\n    #     'diff_equals': diff_equals,\n    #     'is_none_check': is_none,\n    #     'equals_none_check': equals_none\n    # }\n    pass\n\n# Test code\nprint(\"List Copying and Aliasing:\")\nprint(\"=\"*60)\n\nprint(\"\\nAliasing Demo:\")\nprint(\"-\"*60)\naliasing = aliasing_demo()\nfor name, value in aliasing.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Shallow Copy Methods:\")\nprint(\"=\"*60)\nshallow_methods = shallow_copy_methods()\nfor name, value in shallow_methods.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Shallow Copy Problem:\")\nprint(\"=\"*60)\nproblem = shallow_copy_problem()\nfor name, value in problem.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Deep Copy Solution:\")\nprint(\"=\"*60)\ndeep = deep_copy_solution()\nfor name, value in deep.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Safe Function Parameters:\")\nprint(\"=\"*60)\nsafe_params = safe_function_params()\nfor name, value in safe_params.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Identity Testing (is vs ==):\")\nprint(\"=\"*60)\nidentity = testing_identity()\nfor name, value in identity.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Key Concepts:\")\nprint(\"=\"*60)\nprint(\"Aliasing:\")\nprint(\"  - list2 = list1 creates alias (same object)\")\nprint(\"  - Modifications affect both names\")\nprint(\"  - Use 'is' to check if same object\")\nprint(\"\\nShallow Copy:\")\nprint(\"  - [:], list(), .copy(), copy.copy()\")\nprint(\"  - Creates new list, elements reference same objects\")\nprint(\"  - Safe for flat lists, problematic for nested\")\nprint(\"\\nDeep Copy:\")\nprint(\"  - copy.deepcopy() copies recursively\")\nprint(\"  - Use for nested structures\")\nprint(\"  - Slower but safer\")\nprint(\"\\nBest Practices:\")\nprint(\"  - Don't mutate function parameters\")\nprint(\"  - Never use mutable default arguments\")\nprint(\"  - Use 'is None' not '== None'\")\nprint(\"  - Choose appropriate copy method\")",
  "solution": "def aliasing_demo():\n    list1 = [1, 2, 3]\n    list2 = list1\n    \n    same_id = id(list1) == id(list2)\n    \n    list2.append(4)\n    list1_after = list1.copy()\n    list2_after = list2.copy()\n    \n    list1[0] = 99\n    list1_final = list1.copy()\n    list2_final = list2.copy()\n    \n    return {\n        'same_id': same_id,\n        'list1_after_list2_append': list1_after,\n        'list2_after_list2_append': list2_after,\n        'list1_after_list1_modify': list1_final,\n        'list2_after_list1_modify': list2_final\n    }\n\ndef shallow_copy_methods():\n    original = [1, 2, 3, 4, 5]\n    \n    copy1 = original[:]\n    copy1.append(6)\n    slice_original = original.copy()\n    slice_copy = copy1.copy()\n    \n    copy2 = list(original)\n    copy2[0] = 99\n    list_original = original.copy()\n    list_copy = copy2.copy()\n    \n    copy3 = original.copy()\n    copy3.append(7)\n    method_original = original.copy()\n    method_copy = copy3.copy()\n    \n    import copy\n    copy4 = copy.copy(original)\n    copy4[0] = 88\n    module_original = original.copy()\n    module_copy = copy4.copy()\n    \n    all_independent = (\n        slice_original == [1, 2, 3, 4, 5] and\n        list_original == [1, 2, 3, 4, 5] and\n        method_original == [1, 2, 3, 4, 5] and\n        module_original == [1, 2, 3, 4, 5]\n    )\n    \n    return {\n        'slice_method': slice_copy,\n        'list_constructor': list_copy,\n        'copy_method': method_copy,\n        'copy_module': module_copy,\n        'all_independent': all_independent\n    }\n\ndef shallow_copy_problem():\n    original = [[1, 2], [3, 4]]\n    shallow = original[:]\n    \n    nested_same_id = id(original[0]) == id(shallow[0])\n    \n    shallow[0][0] = 99\n    original_affected = original.copy()\n    shallow_copy = shallow.copy()\n    \n    original2 = [[1, 2], [3, 4]]\n    shallow2 = original2[:]\n    shallow2[0] = [99, 99]\n    original2_safe = original2.copy()\n    shallow2_changed = shallow2.copy()\n    \n    return {\n        'nested_same_id': nested_same_id,\n        'original_affected': original_affected,\n        'shallow_affected': shallow_copy,\n        'original2_unchanged': original2_safe,\n        'shallow2_changed': shallow2_changed\n    }\n\ndef deep_copy_solution():\n    import copy\n    \n    original = [[1, 2], [3, 4]]\n    deep = copy.deepcopy(original)\n    \n    nested_different_id = id(original[0]) != id(deep[0])\n    \n    deep[0][0] = 99\n    original_unchanged = original.copy()\n    deep_modified = deep.copy()\n    \n    original = [[1, [2, 3]], [4, [5, 6]]]\n    deep = copy.deepcopy(original)\n    deep[0][1][0] = 999\n    complex_original = original.copy()\n    complex_deep = deep.copy()\n    \n    return {\n        'nested_different_id': nested_different_id,\n        'original_unchanged': original_unchanged,\n        'deep_modified': deep_modified,\n        'complex_original_safe': complex_original,\n        'complex_deep_changed': complex_deep\n    }\n\ndef safe_function_params():\n    def unsafe_process(data):\n        data.append(999)\n        return data\n    \n    original = [1, 2, 3]\n    result = unsafe_process(original)\n    unsafe_original = original.copy()\n    \n    def safe_process(data):\n        data_copy = data.copy()\n        data_copy.append(999)\n        return data_copy\n    \n    original = [1, 2, 3]\n    result = safe_process(original)\n    safe_original = original.copy()\n    safe_result = result.copy()\n    \n    results = []\n    \n    def buggy_append(item, lst=[]):\n        lst.append(item)\n        return lst\n    \n    r1 = buggy_append(1)\n    r2 = buggy_append(2)\n    results.append((r1.copy(), r2.copy()))\n    \n    def safe_append(item, lst=None):\n        if lst is None:\n            lst = []\n        lst.append(item)\n        return lst\n    \n    s1 = safe_append(1)\n    s2 = safe_append(2)\n    \n    return {\n        'unsafe_mutated': unsafe_original,\n        'safe_unchanged': safe_original,\n        'safe_result': safe_result,\n        'buggy_r1': results[0][0],\n        'buggy_r2': results[0][1],\n        'safe_s1': s1,\n        'safe_s2': s2\n    }\n\ndef testing_identity():\n    list1 = [1, 2, 3]\n    list2 = list1\n    alias_is = list1 is list2\n    alias_equals = list1 == list2\n    \n    list1 = [1, 2, 3]\n    list3 = list1[:]\n    copy_is = list1 is list3\n    copy_equals = list1 == list3\n    \n    list1 = [1, 2, 3]\n    list4 = [1, 2, 4]\n    diff_is = list1 is list4\n    diff_equals = list1 == list4\n    \n    value = None\n    is_none = value is None\n    equals_none = value == None\n    \n    return {\n        'alias_is': alias_is,\n        'alias_equals': alias_equals,\n        'copy_is': copy_is,\n        'copy_equals': copy_equals,\n        'diff_is': diff_is,\n        'diff_equals': diff_equals,\n        'is_none_check': is_none,\n        'equals_none_check': equals_none\n    }",
  "hints": [
    "Assignment creates alias - same object, different names",
    "Shallow copy: [:], list(), .copy(), copy.copy() - all work for flat lists",
    "Shallow copy shares nested object references - modify affects both",
    "Deep copy (copy.deepcopy()) recursively copies nested structures",
    "Never mutate function parameters - create copy first",
    "Use 'is' for identity (same object), '==' for equality (same value)"
  ],
  "testCases": [
    {
      "id": "tc1",
      "description": "Aliasing same ID",
      "input": "aliasing_demo()['same_id']",
      "expectedOutput": "True",
      "isHidden": false
    },
    {
      "id": "tc2",
      "description": "Shallow methods independent",
      "input": "shallow_copy_methods()['all_independent']",
      "expectedOutput": "True",
      "isHidden": false
    },
    {
      "id": "tc3",
      "description": "Shallow nested same ID",
      "input": "shallow_copy_problem()['nested_same_id']",
      "expectedOutput": "True",
      "isHidden": false
    },
    {
      "id": "tc4",
      "description": "Deep copy different ID",
      "input": "deep_copy_solution()['nested_different_id']",
      "expectedOutput": "True",
      "isHidden": true
    },
    {
      "id": "tc5",
      "description": "Safe param unchanged",
      "input": "safe_function_params()['safe_unchanged']",
      "expectedOutput": "[1, 2, 3]",
      "isHidden": true
    },
    {
      "id": "tc6",
      "description": "Identity check",
      "input": "testing_identity()['alias_is']",
      "expectedOutput": "True",
      "isHidden": true
    }
  ]
}