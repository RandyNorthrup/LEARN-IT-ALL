{
  "id": "exercise-120-list-creation-initialization",
  "lessonId": "lesson-110-list-creation-initialization",
  "title": "List Creation and Initialization Patterns",
  "description": "Master various ways to create and initialize lists efficiently.\n\nYour program should:\n1. Create lists with literals, list(), range()\n2. Use repetition operator for initialization\n3. Avoid mutable default argument trap\n4. Create shallow vs deep copies\n5. Pre-allocate lists for performance\n6. Use comprehensions for initialization\n\nImplement these functions:\n- `creation_methods()`: Various creation techniques\n- `repetition_initialization()`: Use * operator\n- `avoid_mutable_trap()`: Show shallow copy problem\n- `copying_methods()`: Shallow vs deep copy\n- `preallocation()`: Pre-allocate for known sizes\n- `from_iterables()`: Create from strings, ranges, etc\n\nExample:\n```python\n[0] * 5  # [0, 0, 0, 0, 0]\nlist(range(5))  # [0, 1, 2, 3, 4]\n```",
  "difficulty": "intermediate",
  "points": 20,
  "language": "python",
  "starterCode": "def creation_methods():\n    \"\"\"Various list creation methods.\n    \n    Returns:\n        Dict with different creation examples.\n    \"\"\"\n    # TODO: Create lists different ways\n    # literal = [1, 2, 3, 4, 5]\n    # empty = []\n    # from_list = list(\"hello\")\n    # from_range = list(range(5))\n    # from_range_step = list(range(0, 10, 2))\n    # comprehension = [x**2 for x in range(5)]\n    # \n    # return {\n    #     'literal': literal,\n    #     'empty': empty,\n    #     'from_list': from_list,\n    #     'from_range': from_range,\n    #     'from_range_step': from_range_step,\n    #     'comprehension': comprehension\n    # }\n    pass\n\ndef repetition_initialization():\n    \"\"\"Use repetition operator.\n    \n    Returns:\n        Dict with repetition examples.\n    \"\"\"\n    # TODO: Repetition initialization\n    # zeros = [0] * 5\n    # pattern = [1, 2] * 3\n    # empty_repeat = [None] * 10\n    # \n    # # String repetition\n    # strings = [\"item\"] * 3\n    # \n    # return {\n    #     'zeros': zeros,\n    #     'pattern': pattern,\n    #     'empty_repeat': empty_repeat,\n    #     'strings': strings\n    # }\n    pass\n\ndef avoid_mutable_trap():\n    \"\"\"Show shallow copy problem with repetition.\n    \n    Returns:\n        Dict showing the trap.\n    \"\"\"\n    # TODO: Demonstrate trap\n    # # BAD: All sublists are same object\n    # bad_matrix = [[0] * 3] * 3\n    # bad_matrix[0][0] = 1\n    # all_affected = bad_matrix  # All rows changed!\n    # \n    # # GOOD: Each sublist is separate\n    # good_matrix = [[0] * 3 for _ in range(3)]\n    # good_matrix[0][0] = 1\n    # only_first_affected = good_matrix  # Only first row changed\n    # \n    # # Check if same object\n    # bad_test = [[0] * 3] * 3\n    # same_object = bad_test[0] is bad_test[1]\n    # \n    # good_test = [[0] * 3 for _ in range(3)]\n    # different_objects = good_test[0] is not good_test[1]\n    # \n    # return {\n    #     'bad_matrix': all_affected,\n    #     'good_matrix': only_first_affected,\n    #     'bad_same_object': same_object,\n    #     'good_different_objects': different_objects\n    # }\n    pass\n\ndef copying_methods():\n    \"\"\"Shallow vs deep copy.\n    \n    Returns:\n        Dict comparing copy methods.\n    \"\"\"\n    # TODO: Copy methods\n    # original = [1, 2, 3, 4, 5]\n    # \n    # # Shallow copies (all equivalent)\n    # copy1 = original[:]\n    # copy2 = original.copy()\n    # copy3 = list(original)\n    # \n    # # Modify copy doesn't affect original\n    # copy1[0] = 99\n    # original_unchanged = original[0] == 1\n    # \n    # # Nested lists - shallow copy problem\n    # nested = [[1, 2], [3, 4]]\n    # shallow = nested[:]\n    # shallow[0][0] = 99\n    # nested_affected = nested[0][0] == 99  # Nested list modified!\n    # \n    # # Deep copy for nested\n    # import copy\n    # nested2 = [[1, 2], [3, 4]]\n    # deep = copy.deepcopy(nested2)\n    # deep[0][0] = 99\n    # nested2_unaffected = nested2[0][0] == 1\n    # \n    # return {\n    #     'original_unchanged': original_unchanged,\n    #     'shallow_copies_work': copy1 == copy2 == copy3,\n    #     'nested_affected': nested_affected,\n    #     'deep_copy_protects': nested2_unaffected\n    # }\n    pass\n\ndef preallocation():\n    \"\"\"Pre-allocate lists for performance.\n    \n    Returns:\n        Dict with preallocation examples.\n    \"\"\"\n    # TODO: Pre-allocate\n    # # Pre-allocate with None\n    # size = 10\n    # preallocated = [None] * size\n    # \n    # # Fill later\n    # for i in range(size):\n    #     preallocated[i] = i ** 2\n    # \n    # # Pre-allocate matrix\n    # rows, cols = 3, 4\n    # matrix = [[0 for _ in range(cols)] for _ in range(rows)]\n    # \n    # # Set value\n    # matrix[1][2] = 99\n    # \n    # return {\n    #     'preallocated': preallocated,\n    #     'matrix': matrix,\n    #     'matrix_value': matrix[1][2]\n    # }\n    pass\n\ndef from_iterables():\n    \"\"\"Create lists from various iterables.\n    \n    Returns:\n        Dict with examples from iterables.\n    \"\"\"\n    # TODO: From iterables\n    # # From string\n    # chars = list(\"Python\")\n    # \n    # # From range\n    # numbers = list(range(10, 20))\n    # \n    # # From tuple\n    # tuple_data = (1, 2, 3, 4, 5)\n    # from_tuple = list(tuple_data)\n    # \n    # # From set (order not guaranteed)\n    # set_data = {3, 1, 2}\n    # from_set = sorted(list(set_data))  # Sort for consistency\n    # \n    # # From dict keys/values\n    # dict_data = {\"a\": 1, \"b\": 2, \"c\": 3}\n    # keys = list(dict_data.keys())\n    # values = list(dict_data.values())\n    # items = list(dict_data.items())\n    # \n    # # From generator\n    # gen = (x**2 for x in range(5))\n    # from_gen = list(gen)\n    # \n    # return {\n    #     'chars': chars,\n    #     'numbers': numbers,\n    #     'from_tuple': from_tuple,\n    #     'from_set': from_set,\n    #     'keys': sorted(keys),\n    #     'values': sorted(values),\n    #     'from_gen': from_gen\n    # }\n    pass\n\n# Test code\nprint(\"List Creation and Initialization:\")\nprint(\"=\"*60)\n\nprint(\"\\nCreation Methods:\")\nprint(\"-\"*60)\ncreation = creation_methods()\nfor name, lst in creation.items():\n    print(f\"{name}: {lst}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Repetition Initialization:\")\nprint(\"=\"*60)\nrepetition = repetition_initialization()\nfor name, lst in repetition.items():\n    print(f\"{name}: {lst}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"⚠️  Mutable Repetition Trap:\")\nprint(\"=\"*60)\ntrap = avoid_mutable_trap()\nprint(\"BAD: [[0] * 3] * 3\")\nprint(f\"  Result after [0][0] = 1: {trap['bad_matrix']}\")\nprint(f\"  All rows same object: {trap['bad_same_object']}\")\nprint(\"\\nGOOD: [[0] * 3 for _ in range(3)]\")\nprint(f\"  Result after [0][0] = 1: {trap['good_matrix']}\")\nprint(f\"  Rows are different: {trap['good_different_objects']}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Copying Methods:\")\nprint(\"=\"*60)\ncopying = copying_methods()\nfor name, value in copying.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Preallocation:\")\nprint(\"=\"*60)\nprealloc = preallocation()\nfor name, value in prealloc.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"From Iterables:\")\nprint(\"=\"*60)\nfrom_iter = from_iterables()\nfor name, value in from_iter.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Key Concepts:\")\nprint(\"=\"*60)\nprint(\"Creation:\")\nprint(\"  - Literals: [1, 2, 3]\")\nprint(\"  - list(): list('hello'), list(range(5))\")\nprint(\"  - Comprehension: [x**2 for x in range(5)]\")\nprint(\"\\nRepetition:\")\nprint(\"  - [0] * 5 creates [0, 0, 0, 0, 0]\")\nprint(\"  - ⚠️  [[0] * 3] * 3 creates shared references!\")\nprint(\"  - ✅ [[0] * 3 for _ in range(3)] creates independent lists\")\nprint(\"\\nCopying:\")\nprint(\"  - Shallow: [:], .copy(), list()\")\nprint(\"  - Deep: copy.deepcopy() for nested structures\")\nprint(\"\\nPreallocation:\")\nprint(\"  - [None] * n for known size\")\nprint(\"  - Better performance than repeated append()\")",
  "solution": "def creation_methods():\n    literal = [1, 2, 3, 4, 5]\n    empty = []\n    from_list = list(\"hello\")\n    from_range = list(range(5))\n    from_range_step = list(range(0, 10, 2))\n    comprehension = [x**2 for x in range(5)]\n    \n    return {\n        'literal': literal,\n        'empty': empty,\n        'from_list': from_list,\n        'from_range': from_range,\n        'from_range_step': from_range_step,\n        'comprehension': comprehension\n    }\n\ndef repetition_initialization():\n    zeros = [0] * 5\n    pattern = [1, 2] * 3\n    empty_repeat = [None] * 10\n    strings = [\"item\"] * 3\n    \n    return {\n        'zeros': zeros,\n        'pattern': pattern,\n        'empty_repeat': empty_repeat,\n        'strings': strings\n    }\n\ndef avoid_mutable_trap():\n    bad_matrix = [[0] * 3] * 3\n    bad_matrix[0][0] = 1\n    all_affected = bad_matrix\n    \n    good_matrix = [[0] * 3 for _ in range(3)]\n    good_matrix[0][0] = 1\n    only_first_affected = good_matrix\n    \n    bad_test = [[0] * 3] * 3\n    same_object = bad_test[0] is bad_test[1]\n    \n    good_test = [[0] * 3 for _ in range(3)]\n    different_objects = good_test[0] is not good_test[1]\n    \n    return {\n        'bad_matrix': all_affected,\n        'good_matrix': only_first_affected,\n        'bad_same_object': same_object,\n        'good_different_objects': different_objects\n    }\n\ndef copying_methods():\n    original = [1, 2, 3, 4, 5]\n    \n    copy1 = original[:]\n    copy2 = original.copy()\n    copy3 = list(original)\n    \n    copy1[0] = 99\n    original_unchanged = original[0] == 1\n    \n    nested = [[1, 2], [3, 4]]\n    shallow = nested[:]\n    shallow[0][0] = 99\n    nested_affected = nested[0][0] == 99\n    \n    import copy\n    nested2 = [[1, 2], [3, 4]]\n    deep = copy.deepcopy(nested2)\n    deep[0][0] = 99\n    nested2_unaffected = nested2[0][0] == 1\n    \n    return {\n        'original_unchanged': original_unchanged,\n        'shallow_copies_work': copy1 == copy2 == copy3,\n        'nested_affected': nested_affected,\n        'deep_copy_protects': nested2_unaffected\n    }\n\ndef preallocation():\n    size = 10\n    preallocated = [None] * size\n    \n    for i in range(size):\n        preallocated[i] = i ** 2\n    \n    rows, cols = 3, 4\n    matrix = [[0 for _ in range(cols)] for _ in range(rows)]\n    matrix[1][2] = 99\n    \n    return {\n        'preallocated': preallocated,\n        'matrix': matrix,\n        'matrix_value': matrix[1][2]\n    }\n\ndef from_iterables():\n    chars = list(\"Python\")\n    numbers = list(range(10, 20))\n    tuple_data = (1, 2, 3, 4, 5)\n    from_tuple = list(tuple_data)\n    set_data = {3, 1, 2}\n    from_set = sorted(list(set_data))\n    dict_data = {\"a\": 1, \"b\": 2, \"c\": 3}\n    keys = list(dict_data.keys())\n    values = list(dict_data.values())\n    items = list(dict_data.items())\n    gen = (x**2 for x in range(5))\n    from_gen = list(gen)\n    \n    return {\n        'chars': chars,\n        'numbers': numbers,\n        'from_tuple': from_tuple,\n        'from_set': from_set,\n        'keys': sorted(keys),\n        'values': sorted(values),\n        'from_gen': from_gen\n    }",
  "hints": [
    "list() constructor converts any iterable to list",
    "Repetition [0] * 5 creates [0, 0, 0, 0, 0]",
    "⚠️ [[0] * 3] * 3 creates shared references - use comprehension",
    "Shallow copy: [:], .copy(), list() - sufficient for flat lists",
    "Deep copy: copy.deepcopy() - needed for nested structures",
    "Pre-allocate with [None] * n for better performance"
  ],
  "testCases": [
    {
      "id": "tc1",
      "description": "Create from string",
      "input": "creation_methods()['from_list']",
      "expectedOutput": "['h', 'e', 'l', 'l', 'o']",
      "isHidden": false
    },
    {
      "id": "tc2",
      "description": "Repetition zeros",
      "input": "repetition_initialization()['zeros']",
      "expectedOutput": "[0, 0, 0, 0, 0]",
      "isHidden": false
    },
    {
      "id": "tc3",
      "description": "Mutable trap detected",
      "input": "avoid_mutable_trap()['bad_same_object']",
      "expectedOutput": "True",
      "isHidden": false
    },
    {
      "id": "tc4",
      "description": "Shallow copy works",
      "input": "copying_methods()['original_unchanged']",
      "expectedOutput": "True",
      "isHidden": true
    },
    {
      "id": "tc5",
      "description": "Deep copy protects",
      "input": "copying_methods()['deep_copy_protects']",
      "expectedOutput": "True",
      "isHidden": true
    },
    {
      "id": "tc6",
      "description": "From generator",
      "input": "from_iterables()['from_gen']",
      "expectedOutput": "[0, 1, 4, 9, 16]",
      "isHidden": true
    }
  ]
}