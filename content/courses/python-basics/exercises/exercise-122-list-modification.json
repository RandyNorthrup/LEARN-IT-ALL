{
  "id": "exercise-122-list-modification",
  "lessonId": "lesson-112-list-modification",
  "title": "Modifying Lists In-Place",
  "description": "Master in-place list modification methods and understand mutation.\n\nYour program should:\n1. Add elements with append(), extend(), insert()\n2. Remove elements with remove(), pop(), clear()\n3. Understand in-place vs copying operations\n4. Modify elements by index\n5. Handle method return values correctly\n6. Choose appropriate modification methods\n\nImplement these functions:\n- `adding_methods()`: append, extend, insert, +=\n- `removing_methods()`: remove, pop, clear, del\n- `inplace_vs_copy()`: Show difference\n- `modify_by_index()`: Change elements directly\n- `method_returns()`: Show what methods return\n- `chaining_mistake()`: Why chaining fails\n\nExample:\n```python\nlst.append(4)  # Adds to end\nlst.pop()  # Removes and returns last\n```",
  "difficulty": "intermediate",
  "points": 20,
  "language": "python",
  "starterCode": "def adding_methods():\n    \"\"\"Methods for adding elements.\n    \n    Returns:\n        Dict showing addition results.\n    \"\"\"\n    # TODO: Adding methods\n    # nums = [1, 2, 3]\n    # nums.append(4)  # Add single\n    # after_append = nums.copy()\n    # \n    # nums.extend([5, 6])  # Add multiple\n    # after_extend = nums.copy()\n    # \n    # nums.insert(0, 0)  # Insert at position\n    # after_insert = nums.copy()\n    # \n    # nums += [7, 8]  # += is like extend\n    # after_plus_equals = nums.copy()\n    # \n    # # append vs extend difference\n    # list1 = [1, 2]\n    # list1.append([3, 4])  # Nested\n    # append_result = list1.copy()\n    # \n    # list2 = [1, 2]\n    # list2.extend([3, 4])  # Flattened\n    # extend_result = list2.copy()\n    # \n    # return {\n    #     'after_append': after_append,\n    #     'after_extend': after_extend,\n    #     'after_insert': after_insert,\n    #     'after_plus_equals': after_plus_equals,\n    #     'append_vs_extend_append': append_result,\n    #     'append_vs_extend_extend': extend_result\n    # }\n    pass\n\ndef removing_methods():\n    \"\"\"Methods for removing elements.\n    \n    Returns:\n        Dict showing removal results.\n    \"\"\"\n    # TODO: Removing methods\n    # # remove() - removes first occurrence\n    # nums = [1, 2, 3, 2, 4]\n    # nums.remove(2)\n    # after_remove = nums.copy()\n    # \n    # # pop() - removes and returns by index\n    # nums = [1, 2, 3, 4, 5]\n    # popped_last = nums.pop()\n    # after_pop_last = nums.copy()\n    # \n    # nums = [1, 2, 3, 4, 5]\n    # popped_first = nums.pop(0)\n    # after_pop_first = nums.copy()\n    # \n    # # clear() - removes all\n    # nums = [1, 2, 3]\n    # nums.clear()\n    # after_clear = nums.copy()\n    # \n    # # del statement\n    # nums = [1, 2, 3, 4, 5]\n    # del nums[2]  # Delete by index\n    # after_del = nums.copy()\n    # \n    # return {\n    #     'after_remove': after_remove,\n    #     'popped_last': popped_last,\n    #     'after_pop_last': after_pop_last,\n    #     'popped_first': popped_first,\n    #     'after_pop_first': after_pop_first,\n    #     'after_clear': after_clear,\n    #     'after_del': after_del\n    # }\n    pass\n\ndef inplace_vs_copy():\n    \"\"\"Show in-place vs copying operations.\n    \n    Returns:\n        Dict comparing both approaches.\n    \"\"\"\n    # TODO: Compare in-place vs copy\n    # original = [3, 1, 4, 1, 5]\n    # \n    # # In-place: modifies original, returns None\n    # list1 = original.copy()\n    # result = list1.sort()\n    # inplace_returns = result  # None\n    # inplace_list = list1  # [1, 1, 3, 4, 5]\n    # \n    # # Copy: returns new list, original unchanged\n    # list2 = original.copy()\n    # sorted_copy = sorted(list2)\n    # copy_original = list2  # [3, 1, 4, 1, 5]\n    # copy_result = sorted_copy  # [1, 1, 3, 4, 5]\n    # \n    # return {\n    #     'inplace_returns': inplace_returns,\n    #     'inplace_modified': inplace_list,\n    #     'copy_original_unchanged': copy_original,\n    #     'copy_new_list': copy_result\n    # }\n    pass\n\ndef modify_by_index():\n    \"\"\"Modify elements by index.\n    \n    Returns:\n        Dict showing index modifications.\n    \"\"\"\n    # TODO: Modify by index\n    # nums = [1, 2, 3, 4, 5]\n    # \n    # # Single element\n    # nums[0] = 10\n    # after_first = nums.copy()\n    # \n    # # Last element\n    # nums[-1] = 50\n    # after_last = nums.copy()\n    # \n    # # Multiple assignments\n    # nums[1] = nums[2] = 20\n    # after_multiple = nums.copy()\n    # \n    # # Swap elements\n    # nums = [1, 2, 3, 4, 5]\n    # nums[0], nums[4] = nums[4], nums[0]\n    # after_swap = nums.copy()\n    # \n    # # Modify based on condition\n    # nums = [1, 2, 3, 4, 5]\n    # for i in range(len(nums)):\n    #     if nums[i] % 2 == 0:\n    #         nums[i] = 0\n    # after_conditional = nums.copy()\n    # \n    # return {\n    #     'after_first': after_first,\n    #     'after_last': after_last,\n    #     'after_multiple': after_multiple,\n    #     'after_swap': after_swap,\n    #     'after_conditional': after_conditional\n    # }\n    pass\n\ndef method_returns():\n    \"\"\"What methods return.\n    \n    Returns:\n        Dict showing return values.\n    \"\"\"\n    # TODO: Method returns\n    # nums = [1, 2, 3]\n    # \n    # append_returns = nums.append(4)  # None\n    # extend_returns = nums.extend([5])  # None\n    # insert_returns = nums.insert(0, 0)  # None\n    # remove_returns = nums.remove(2)  # None\n    # clear_returns = [].clear()  # None\n    # \n    # pop_returns = [1, 2, 3].pop()  # 3 (the value)\n    # pop_index_returns = [1, 2, 3].pop(0)  # 1 (the value)\n    # \n    # sort_returns = [3, 1, 2].sort()  # None\n    # reverse_returns = [1, 2, 3].reverse()  # None\n    # \n    # return {\n    #     'append': append_returns,\n    #     'extend': extend_returns,\n    #     'insert': insert_returns,\n    #     'remove': remove_returns,\n    #     'clear': clear_returns,\n    #     'pop': pop_returns,\n    #     'pop_index': pop_index_returns,\n    #     'sort': sort_returns,\n    #     'reverse': reverse_returns\n    # }\n    pass\n\ndef chaining_mistake():\n    \"\"\"Why you can't chain mutation methods.\n    \n    Returns:\n        Dict explaining the problem.\n    \"\"\"\n    # TODO: Chaining mistake\n    # # This fails because methods return None\n    # try:\n    #     result = [1, 2].append(3).append(4)\n    #     error_occurred = False\n    # except AttributeError:\n    #     error_occurred = True\n    # \n    # # Correct approach\n    # nums = [1, 2]\n    # nums.append(3)\n    # nums.append(4)\n    # correct = nums.copy()\n    # \n    # explanation = {\n    #     'problem': 'Mutation methods return None',\n    #     'cant_chain': 'None.append(4) raises AttributeError',\n    #     'solution': 'Call methods separately on same list'\n    # }\n    # \n    # return {\n    #     'error_occurred': error_occurred,\n    #     'correct_result': correct,\n    #     'explanation': explanation\n    # }\n    pass\n\n# Test code\nprint(\"List Modification:\")\nprint(\"=\"*60)\n\nprint(\"\\nAdding Methods:\")\nprint(\"-\"*60)\nadding = adding_methods()\nfor name, value in adding.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Removing Methods:\")\nprint(\"=\"*60)\nremoving = removing_methods()\nfor name, value in removing.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"In-Place vs Copy:\")\nprint(\"=\"*60)\ncomparison = inplace_vs_copy()\nfor name, value in comparison.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Modify by Index:\")\nprint(\"=\"*60)\nmodify = modify_by_index()\nfor name, value in modify.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Method Return Values:\")\nprint(\"=\"*60)\nreturns = method_returns()\nfor name, value in returns.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Chaining Mistake:\")\nprint(\"=\"*60)\nchaining = chaining_mistake()\nprint(f\"Error occurred: {chaining['error_occurred']}\")\nprint(f\"Correct result: {chaining['correct_result']}\")\nprint(\"\\nExplanation:\")\nfor key, value in chaining['explanation'].items():\n    print(f\"  {key}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Key Concepts:\")\nprint(\"=\"*60)\nprint(\"Adding:\")\nprint(\"  - append(x): Add single element to end\")\nprint(\"  - extend(iter): Add all elements from iterable\")\nprint(\"  - insert(i, x): Insert at specific index\")\nprint(\"  - += : Same as extend()\")\nprint(\"\\nRemoving:\")\nprint(\"  - remove(x): Remove first occurrence\")\nprint(\"  - pop(i): Remove and return at index (default: -1)\")\nprint(\"  - clear(): Remove all elements\")\nprint(\"  - del list[i]: Delete by index\")\nprint(\"\\nImportant:\")\nprint(\"  - Most methods return None (modify in-place)\")\nprint(\"  - pop() returns the removed element\")\nprint(\"  - Can't chain: list.append(1).append(2) fails\")\nprint(\"  - sort() vs sorted(): in-place vs new list\")",
  "solution": "def adding_methods():\n    nums = [1, 2, 3]\n    nums.append(4)\n    after_append = nums.copy()\n    \n    nums.extend([5, 6])\n    after_extend = nums.copy()\n    \n    nums.insert(0, 0)\n    after_insert = nums.copy()\n    \n    nums += [7, 8]\n    after_plus_equals = nums.copy()\n    \n    list1 = [1, 2]\n    list1.append([3, 4])\n    append_result = list1.copy()\n    \n    list2 = [1, 2]\n    list2.extend([3, 4])\n    extend_result = list2.copy()\n    \n    return {\n        'after_append': after_append,\n        'after_extend': after_extend,\n        'after_insert': after_insert,\n        'after_plus_equals': after_plus_equals,\n        'append_vs_extend_append': append_result,\n        'append_vs_extend_extend': extend_result\n    }\n\ndef removing_methods():\n    nums = [1, 2, 3, 2, 4]\n    nums.remove(2)\n    after_remove = nums.copy()\n    \n    nums = [1, 2, 3, 4, 5]\n    popped_last = nums.pop()\n    after_pop_last = nums.copy()\n    \n    nums = [1, 2, 3, 4, 5]\n    popped_first = nums.pop(0)\n    after_pop_first = nums.copy()\n    \n    nums = [1, 2, 3]\n    nums.clear()\n    after_clear = nums.copy()\n    \n    nums = [1, 2, 3, 4, 5]\n    del nums[2]\n    after_del = nums.copy()\n    \n    return {\n        'after_remove': after_remove,\n        'popped_last': popped_last,\n        'after_pop_last': after_pop_last,\n        'popped_first': popped_first,\n        'after_pop_first': after_pop_first,\n        'after_clear': after_clear,\n        'after_del': after_del\n    }\n\ndef inplace_vs_copy():\n    original = [3, 1, 4, 1, 5]\n    \n    list1 = original.copy()\n    result = list1.sort()\n    inplace_returns = result\n    inplace_list = list1\n    \n    list2 = original.copy()\n    sorted_copy = sorted(list2)\n    copy_original = list2\n    copy_result = sorted_copy\n    \n    return {\n        'inplace_returns': inplace_returns,\n        'inplace_modified': inplace_list,\n        'copy_original_unchanged': copy_original,\n        'copy_new_list': copy_result\n    }\n\ndef modify_by_index():\n    nums = [1, 2, 3, 4, 5]\n    \n    nums[0] = 10\n    after_first = nums.copy()\n    \n    nums[-1] = 50\n    after_last = nums.copy()\n    \n    nums[1] = nums[2] = 20\n    after_multiple = nums.copy()\n    \n    nums = [1, 2, 3, 4, 5]\n    nums[0], nums[4] = nums[4], nums[0]\n    after_swap = nums.copy()\n    \n    nums = [1, 2, 3, 4, 5]\n    for i in range(len(nums)):\n        if nums[i] % 2 == 0:\n            nums[i] = 0\n    after_conditional = nums.copy()\n    \n    return {\n        'after_first': after_first,\n        'after_last': after_last,\n        'after_multiple': after_multiple,\n        'after_swap': after_swap,\n        'after_conditional': after_conditional\n    }\n\ndef method_returns():\n    nums = [1, 2, 3]\n    \n    append_returns = nums.append(4)\n    extend_returns = nums.extend([5])\n    insert_returns = nums.insert(0, 0)\n    remove_returns = nums.remove(2)\n    clear_returns = [].clear()\n    \n    pop_returns = [1, 2, 3].pop()\n    pop_index_returns = [1, 2, 3].pop(0)\n    \n    sort_returns = [3, 1, 2].sort()\n    reverse_returns = [1, 2, 3].reverse()\n    \n    return {\n        'append': append_returns,\n        'extend': extend_returns,\n        'insert': insert_returns,\n        'remove': remove_returns,\n        'clear': clear_returns,\n        'pop': pop_returns,\n        'pop_index': pop_index_returns,\n        'sort': sort_returns,\n        'reverse': reverse_returns\n    }\n\ndef chaining_mistake():\n    try:\n        result = [1, 2].append(3).append(4)\n        error_occurred = False\n    except AttributeError:\n        error_occurred = True\n    \n    nums = [1, 2]\n    nums.append(3)\n    nums.append(4)\n    correct = nums.copy()\n    \n    explanation = {\n        'problem': 'Mutation methods return None',\n        'cant_chain': 'None.append(4) raises AttributeError',\n        'solution': 'Call methods separately on same list'\n    }\n    \n    return {\n        'error_occurred': error_occurred,\n        'correct_result': correct,\n        'explanation': explanation\n    }",
  "hints": [
    "append(x) adds single element, extend(iter) adds all from iterable",
    "remove(x) removes first occurrence, pop(i) removes and returns",
    "Most methods return None - they modify in-place",
    "pop() is special - returns the removed element",
    "Can't chain: methods return None, not the list",
    "Modify by index: list[i] = value works directly"
  ],
  "testCases": [
    {
      "id": "tc1",
      "description": "Append result",
      "input": "adding_methods()['after_append']",
      "expectedOutput": "[1, 2, 3, 4]",
      "isHidden": false
    },
    {
      "id": "tc2",
      "description": "Pop returns value",
      "input": "removing_methods()['popped_last']",
      "expectedOutput": "5",
      "isHidden": false
    },
    {
      "id": "tc3",
      "description": "In-place returns None",
      "input": "inplace_vs_copy()['inplace_returns']",
      "expectedOutput": "None",
      "isHidden": false
    },
    {
      "id": "tc4",
      "description": "Swap elements",
      "input": "modify_by_index()['after_swap']",
      "expectedOutput": "[5, 2, 3, 4, 1]",
      "isHidden": true
    },
    {
      "id": "tc5",
      "description": "Pop returns element",
      "input": "method_returns()['pop']",
      "expectedOutput": "3",
      "isHidden": true
    },
    {
      "id": "tc6",
      "description": "Chaining error",
      "input": "chaining_mistake()['error_occurred']",
      "expectedOutput": "True",
      "isHidden": true
    }
  ]
}