{
  "id": "exercise-112-loop-patterns",
  "lessonId": "lesson-102-loop-patterns",
  "title": "Common Loop Idioms and Patterns",
  "description": "Master essential loop patterns used in real-world Python code. Learn pythonic loop idioms.\n\nYour program should:\n1. Implement accumulator pattern\n2. Use counter and tracker patterns\n3. Apply flag-based control\n4. Master min/max tracking\n5. Use window/sliding patterns\n\nImplement these functions:\n- `running_sum(numbers)`: Accumulator for running totals\n- `count_occurrences(items, target)`: Counter pattern\n- `first_and_last(items, predicate)`: Find first and last match\n- `track_min_max(numbers)`: Track min and max in one pass\n- `sliding_window_max(numbers, window_size)`: Sliding window maximums\n- `group_consecutive(numbers)`: Group consecutive equal values\n\nExample:\n```python\nrunning_sum([1,2,3]) â†’ [1,3,6]\n```",
  "difficulty": "intermediate",
  "points": 20,
  "language": "python",
  "starterCode": "def running_sum(numbers):\n    \"\"\"Return list of running sums (accumulator pattern).\"\"\"\n    # TODO: Build running sum list\n    # result = []\n    # total = 0\n    # for num in numbers:\n    #   total += num\n    #   result.append(total)\n    # return result\n    \n    pass\n\ndef count_occurrences(items, target):\n    \"\"\"Count how many times target appears in items.\"\"\"\n    # TODO: Counter pattern\n    # count = 0\n    # for item in items:\n    #   if item == target:\n    #     count += 1\n    # return count\n    \n    pass\n\ndef first_and_last(items, predicate):\n    \"\"\"Find first and last items matching predicate.\n    Returns tuple (first, last) or (None, None) if none found.\"\"\"\n    # TODO: Track first and last match\n    # first = None\n    # last = None\n    # for item in items:\n    #   if predicate(item):\n    #     if first is None:\n    #       first = item\n    #     last = item\n    # return (first, last)\n    \n    pass\n\ndef track_min_max(numbers):\n    \"\"\"Find min and max in single pass.\n    Returns tuple (min, max).\"\"\"\n    # TODO: Track both in one loop\n    # if not numbers:\n    #   return (None, None)\n    # min_val = numbers[0]\n    # max_val = numbers[0]\n    # for num in numbers[1:]:\n    #   if num < min_val:\n    #     min_val = num\n    #   if num > max_val:\n    #     max_val = num\n    # return (min_val, max_val)\n    \n    pass\n\ndef sliding_window_max(numbers, window_size):\n    \"\"\"Find maximum in each sliding window.\n    Returns list of maximums.\"\"\"\n    # TODO: Slide window and track max\n    # if len(numbers) < window_size:\n    #   return []\n    # result = []\n    # for i in range(len(numbers) - window_size + 1):\n    #   window = numbers[i:i+window_size]\n    #   result.append(max(window))\n    # return result\n    \n    pass\n\ndef group_consecutive(numbers):\n    \"\"\"Group consecutive equal values.\n    Returns list of lists.\"\"\"\n    # TODO: Group consecutive runs\n    # if not numbers:\n    #   return []\n    # groups = []\n    # current_group = [numbers[0]]\n    # for i in range(1, len(numbers)):\n    #   if numbers[i] == numbers[i-1]:\n    #     current_group.append(numbers[i])\n    #   else:\n    #     groups.append(current_group)\n    #     current_group = [numbers[i]]\n    # groups.append(current_group)\n    # return groups\n    \n    pass\n\n# Test functions\nprint(\"Running Sum (Accumulator Pattern):\")\nprint(\"=\"*60)\ntest_lists = [\n    [1, 2, 3, 4, 5],\n    [10, 20, 30],\n    [5, -2, 3, -1],\n]\n\nfor numbers in test_lists:\n    result = running_sum(numbers)\n    print(f\"running_sum({numbers})\")\n    print(f\"Result: {result}\\n\")\n\nprint(\"=\"*60)\nprint(\"Count Occurrences (Counter Pattern):\")\nprint(\"=\"*60)\ntest_cases = [\n    ([1, 2, 3, 2, 4, 2], 2),\n    (['a', 'b', 'a', 'c', 'a'], 'a'),\n    ([1, 1, 1, 1], 1),\n]\n\nfor items, target in test_cases:\n    count = count_occurrences(items, target)\n    print(f\"Count of {target} in {items}: {count}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"First and Last Match:\")\nprint(\"=\"*60)\nnumbers = [1, 3, 5, 7, 9, 11, 13]\npredicate = lambda x: x > 5\nfirst, last = first_and_last(numbers, predicate)\nprint(f\"Numbers: {numbers}\")\nprint(f\"First and last > 5: ({first}, {last})\")\n\nwords = ['apple', 'banana', 'cherry', 'date', 'elderberry']\npredicate = lambda w: len(w) > 6\nfirst, last = first_and_last(words, predicate)\nprint(f\"\\nWords: {words}\")\nprint(f\"First and last with len > 6: ({first}, {last})\")\n\nnumbers = [2, 4, 6, 8]\npredicate = lambda x: x > 10\nfirst, last = first_and_last(numbers, predicate)\nprint(f\"\\nNumbers: {numbers}\")\nprint(f\"First and last > 10: ({first}, {last})\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Track Min and Max (Single Pass):\")\nprint(\"=\"*60)\ntest_lists = [\n    [3, 1, 4, 1, 5, 9, 2, 6],\n    [10, 5, 20, 15],\n    [-5, -10, -3, -1],\n]\n\nfor numbers in test_lists:\n    min_val, max_val = track_min_max(numbers)\n    print(f\"Numbers: {numbers}\")\n    print(f\"Min: {min_val}, Max: {max_val}\\n\")\n\nprint(\"=\"*60)\nprint(\"Sliding Window Maximum:\")\nprint(\"=\"*60)\nnumbers = [1, 3, 5, 2, 4, 6]\nwindow_size = 3\nresult = sliding_window_max(numbers, window_size)\nprint(f\"Numbers: {numbers}\")\nprint(f\"Window size: {window_size}\")\nprint(f\"Window maximums: {result}\")\nprint(\"Windows: [1,3,5]=5, [3,5,2]=5, [5,2,4]=5, [2,4,6]=6\\n\")\n\nnumbers = [10, 9, 8, 7, 6]\nwindow_size = 2\nresult = sliding_window_max(numbers, window_size)\nprint(f\"Numbers: {numbers}\")\nprint(f\"Window size: {window_size}\")\nprint(f\"Window maximums: {result}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Group Consecutive Values:\")\nprint(\"=\"*60)\ntest_lists = [\n    [1, 1, 2, 2, 2, 3, 1, 1],\n    [5, 5, 5, 5],\n    [1, 2, 3, 4],\n]\n\nfor numbers in test_lists:\n    groups = group_consecutive(numbers)\n    print(f\"Numbers: {numbers}\")\n    print(f\"Groups: {groups}\\n\")\n\nprint(\"=\"*60)\nprint(\"Loop Pattern Summary:\")\nprint(\"=\"*60)\nprint(\"1. Accumulator: Build up value across iterations\")\nprint(\"2. Counter: Count matching items\")\nprint(\"3. Tracker: Track first/last/min/max\")\nprint(\"4. Window: Process sliding subsets\")\nprint(\"5. Grouping: Collect consecutive items\")\nprint(\"6. Flag: Boolean to control flow\")",
  "solution": "def running_sum(numbers):\n    \"\"\"Return list of running sums (accumulator pattern).\"\"\"\n    result = []\n    total = 0\n    for num in numbers:\n        total += num\n        result.append(total)\n    return result\n\ndef count_occurrences(items, target):\n    \"\"\"Count how many times target appears in items.\"\"\"\n    count = 0\n    for item in items:\n        if item == target:\n            count += 1\n    return count\n\ndef first_and_last(items, predicate):\n    \"\"\"Find first and last items matching predicate.\n    Returns tuple (first, last) or (None, None) if none found.\"\"\"\n    first = None\n    last = None\n    for item in items:\n        if predicate(item):\n            if first is None:\n                first = item\n            last = item\n    return (first, last)\n\ndef track_min_max(numbers):\n    \"\"\"Find min and max in single pass.\n    Returns tuple (min, max).\"\"\"\n    if not numbers:\n        return (None, None)\n    min_val = numbers[0]\n    max_val = numbers[0]\n    for num in numbers[1:]:\n        if num < min_val:\n            min_val = num\n        if num > max_val:\n            max_val = num\n    return (min_val, max_val)\n\ndef sliding_window_max(numbers, window_size):\n    \"\"\"Find maximum in each sliding window.\n    Returns list of maximums.\"\"\"\n    if len(numbers) < window_size:\n        return []\n    result = []\n    for i in range(len(numbers) - window_size + 1):\n        window = numbers[i:i+window_size]\n        result.append(max(window))\n    return result\n\ndef group_consecutive(numbers):\n    \"\"\"Group consecutive equal values.\n    Returns list of lists.\"\"\"\n    if not numbers:\n        return []\n    groups = []\n    current_group = [numbers[0]]\n    for i in range(1, len(numbers)):\n        if numbers[i] == numbers[i-1]:\n            current_group.append(numbers[i])\n        else:\n            groups.append(current_group)\n            current_group = [numbers[i]]\n    groups.append(current_group)\n    return groups\n\n# Test code as provided",
  "hints": [
    "Accumulator: Start with 0, add each item, store result",
    "Counter: Initialize to 0, increment on match",
    "First/Last: Track first on first match, update last on every match",
    "Min/Max: Start with first element, update on comparisons",
    "Sliding window: Loop to len-window_size+1, slice window",
    "Grouping: Compare current with previous, start new group on difference"
  ],
  "testCases": [
    {
      "id": "tc1",
      "description": "Running sum accumulator",
      "input": "running_sum([1, 2, 3, 4])",
      "expectedOutput": "[1, 3, 6, 10]",
      "isHidden": false
    },
    {
      "id": "tc2",
      "description": "Count occurrences",
      "input": "count_occurrences([1, 2, 3, 2, 4, 2], 2)",
      "expectedOutput": "3",
      "isHidden": false
    },
    {
      "id": "tc3",
      "description": "First and last match",
      "input": "first_and_last([1, 3, 5, 7], lambda x: x > 3)",
      "expectedOutput": "(5, 7)",
      "isHidden": false
    },
    {
      "id": "tc4",
      "description": "Track min and max",
      "input": "track_min_max([3, 1, 4, 1, 5])",
      "expectedOutput": "(1, 5)",
      "isHidden": true
    },
    {
      "id": "tc5",
      "description": "Sliding window maximum",
      "input": "sliding_window_max([1, 3, 5, 2, 4], 3)",
      "expectedOutput": "[5, 5, 5]",
      "isHidden": true
    },
    {
      "id": "tc6",
      "description": "Group consecutive values",
      "input": "group_consecutive([1, 1, 2, 2, 3])",
      "expectedOutput": "[[1, 1], [2, 2], [3]]",
      "isHidden": true
    }
  ]
}