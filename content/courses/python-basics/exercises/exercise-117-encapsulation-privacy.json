{
  "id": "exercise-117-encapsulation-privacy",
  "lessonId": "lesson-107-encapsulation-privacy",
  "title": "Encapsulation and Variable Privacy Patterns",
  "description": "Master Python's privacy conventions and encapsulation patterns. Learn naming conventions and property-based access control.\n\nYour program should:\n1. Use naming conventions for privacy (_protected, __private)\n2. Understand name mangling with double underscore\n3. Implement property-based access control\n4. Create private helpers vs public API\n5. Follow Python privacy philosophy\n6. Build well-encapsulated classes\n\nImplement these functions/classes:\n- `BankAccount`: Class with public/protected/private attributes\n- `Temperature`: Class with property-based access\n- `demonstrate_name_mangling()`: Show __private behavior\n- `privacy_conventions()`: Explain conventions\n- `property_pattern()`: Property getter/setter pattern\n- `encapsulation_benefits()`: Why encapsulate\n\nExample:\n```python\naccount = BankAccount(1000)\naccount.balance  # Public\n```",
  "difficulty": "advanced",
  "points": 25,
  "language": "python",
  "starterCode": "class BankAccount:\n    \"\"\"Demonstrate public/protected/private attributes.\"\"\"\n    \n    def __init__(self, initial_balance):\n        # TODO: Three levels of privacy\n        # self.balance = initial_balance        # Public\n        # self._account_id = \"12345\"            # Protected\n        # self.__secret_key = \"secret\"          # Private (name mangled)\n        pass\n    \n    def deposit(self, amount):\n        \"\"\"Public method.\"\"\"\n        # TODO: Public API method\n        # if amount > 0:\n        #     self.balance += amount\n        # return self.balance\n        pass\n    \n    def _validate_amount(self, amount):\n        \"\"\"Protected helper method.\"\"\"\n        # TODO: Internal helper (convention: don't call from outside)\n        # return amount > 0\n        pass\n    \n    def __encrypt_data(self, data):\n        \"\"\"Private method (name mangled).\"\"\"\n        # TODO: Private implementation detail\n        # return f\"encrypted_{data}\"\n        pass\n\nclass Temperature:\n    \"\"\"Demonstrate property-based access control.\"\"\"\n    \n    def __init__(self, celsius):\n        # TODO: Store in protected attribute\n        # self._celsius = celsius\n        pass\n    \n    @property\n    def celsius(self):\n        \"\"\"Get temperature in Celsius.\"\"\"\n        # TODO: Property getter\n        # return self._celsius\n        pass\n    \n    @celsius.setter\n    def celsius(self, value):\n        \"\"\"Set temperature with validation.\"\"\"\n        # TODO: Property setter with validation\n        # if value < -273.15:\n        #     raise ValueError(\"Below absolute zero\")\n        # self._celsius = value\n        pass\n\ndef demonstrate_name_mangling():\n    \"\"\"Show how __private name mangling works.\n    \n    Returns:\n        Dict showing mangling behavior.\n    \"\"\"\n    # TODO: Demonstrate name mangling\n    # account = BankAccount(1000)\n    # # Can't access __secret_key directly\n    # # But can access via mangled name\n    # return {\n    #     'public_access': hasattr(account, 'balance'),\n    #     'protected_access': hasattr(account, '_account_id'),\n    #     'private_direct': hasattr(account, '__secret_key'),\n    #     'private_mangled': hasattr(account, '_BankAccount__secret_key')\n    # }\n    pass\n\ndef privacy_conventions():\n    \"\"\"Explain Python privacy conventions.\n    \n    Returns:\n        Dict explaining conventions.\n    \"\"\"\n    # TODO: Document conventions\n    # return {\n    #     'public': 'No prefix: name',\n    #     'protected': 'Single underscore: _name',\n    #     'private': 'Double underscore: __name',\n    #     'special': 'Both sides: __name__',\n    #     'philosophy': 'We are all consenting adults'\n    # }\n    pass\n\ndef property_pattern():\n    \"\"\"Demonstrate property pattern benefits.\n    \n    Returns:\n        Dict showing property usage.\n    \"\"\"\n    # TODO: Show property pattern\n    # temp = Temperature(25)\n    # original = temp.celsius\n    # temp.celsius = 30  # Uses setter\n    # return {\n    #     'original': original,\n    #     'modified': temp.celsius,\n    #     'benefit': 'Validation in setter'\n    # }\n    pass\n\ndef encapsulation_benefits():\n    \"\"\"Explain encapsulation benefits.\n    \n    Returns:\n        String explaining benefits.\n    \"\"\"\n    # TODO: List benefits\n    # return (\n    #     \"1. Data hiding: Internal details hidden\\n\"\n    #     \"2. Validation: Control access with properties\\n\"\n    #     \"3. Flexibility: Change internals without breaking API\\n\"\n    #     \"4. Maintainability: Clear public vs private\\n\"\n    #     \"5. Documentation: Naming shows intent\"\n    # )\n    pass\n\n# Test code\nprint(\"Encapsulation and Privacy:\")\nprint(\"=\"*60)\n\nprint(\"\\nNaming Conventions:\")\nprint(\"-\"*60)\naccount = BankAccount(1000)\nprint(f\"Public (balance): {account.balance}\")\nprint(f\"Protected (_account_id): {account._account_id}\")\nprint(\"Private (__secret_key): Not directly accessible\")\ntry:\n    print(account.__secret_key)\nexcept AttributeError:\n    print(\"AttributeError: Can't access __secret_key\")\nprint(f\"Via mangling (_BankAccount__secret_key): {account._BankAccount__secret_key}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Name Mangling Demonstration:\")\nprint(\"=\"*60)\nmangling = demonstrate_name_mangling()\nfor key, value in mangling.items():\n    print(f\"{key}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Privacy Conventions:\")\nprint(\"=\"*60)\nconventions = privacy_conventions()\nfor key, value in conventions.items():\n    print(f\"{key}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Property-Based Access Control:\")\nprint(\"=\"*60)\ntemp = Temperature(25)\nprint(f\"Initial temp: {temp.celsius}°C\")\ntemp.celsius = 30\nprint(f\"After setting to 30: {temp.celsius}°C\")\ntry:\n    temp.celsius = -300\n    print(\"This shouldn't print\")\nexcept ValueError as e:\n    print(f\"Validation works: {e}\")\nprint(\"Property provides controlled access\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Property Pattern Benefits:\")\nprint(\"=\"*60)\npattern = property_pattern()\nfor key, value in pattern.items():\n    print(f\"{key}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Encapsulation Benefits:\")\nprint(\"=\"*60)\nprint(encapsulation_benefits())\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Key Concepts:\")\nprint(\"=\"*60)\nprint(\"Naming Conventions:\")\nprint(\"  public_var: Anyone can use\")\nprint(\"  _protected_var: Internal use (convention)\")\nprint(\"  __private_var: Name mangled (harder to access)\")\nprint(\"  __special__: Python special methods\")\nprint(\"\\nName Mangling:\")\nprint(\"  __name becomes _ClassName__name\")\nprint(\"  Prevents accidental override in subclasses\")\nprint(\"\\nProperties:\")\nprint(\"  @property: Getter method\")\nprint(\"  @name.setter: Setter with validation\")\nprint(\"  Access like attribute, runs method\")\nprint(\"\\nPhilosophy:\")\nprint(\"  No true private in Python\")\nprint(\"  Conventions show intent\")\nprint(\"  'We are all consenting adults'\")",
  "solution": "class BankAccount:\n    def __init__(self, initial_balance):\n        self.balance = initial_balance\n        self._account_id = \"12345\"\n        self.__secret_key = \"secret\"\n    \n    def deposit(self, amount):\n        if amount > 0:\n            self.balance += amount\n        return self.balance\n    \n    def _validate_amount(self, amount):\n        return amount > 0\n    \n    def __encrypt_data(self, data):\n        return f\"encrypted_{data}\"\n\nclass Temperature:\n    def __init__(self, celsius):\n        self._celsius = celsius\n    \n    @property\n    def celsius(self):\n        return self._celsius\n    \n    @celsius.setter\n    def celsius(self, value):\n        if value < -273.15:\n            raise ValueError(\"Below absolute zero\")\n        self._celsius = value\n\ndef demonstrate_name_mangling():\n    account = BankAccount(1000)\n    return {\n        'public_access': hasattr(account, 'balance'),\n        'protected_access': hasattr(account, '_account_id'),\n        'private_direct': hasattr(account, '__secret_key'),\n        'private_mangled': hasattr(account, '_BankAccount__secret_key')\n    }\n\ndef privacy_conventions():\n    return {\n        'public': 'No prefix: name',\n        'protected': 'Single underscore: _name',\n        'private': 'Double underscore: __name',\n        'special': 'Both sides: __name__',\n        'philosophy': 'We are all consenting adults'\n    }\n\ndef property_pattern():\n    temp = Temperature(25)\n    original = temp.celsius\n    temp.celsius = 30\n    return {\n        'original': original,\n        'modified': temp.celsius,\n        'benefit': 'Validation in setter'\n    }\n\ndef encapsulation_benefits():\n    return (\n        \"1. Data hiding: Internal details hidden\\n\"\n        \"2. Validation: Control access with properties\\n\"\n        \"3. Flexibility: Change internals without breaking API\\n\"\n        \"4. Maintainability: Clear public vs private\\n\"\n        \"5. Documentation: Naming shows intent\"\n    )\n\n# Test code as provided",
  "hints": [
    "Public: No prefix (name), anyone can use",
    "Protected: Single underscore (_name), internal use suggested",
    "Private: Double underscore (__name), name mangled to _Class__name",
    "Properties: @property for getter, @name.setter for setter",
    "Name mangling: Prevents accidental override in subclasses",
    "Python philosophy: No true private, conventions show intent"
  ],
  "testCases": [
    {
      "id": "tc1",
      "description": "Public attribute access",
      "input": "BankAccount(1000).balance",
      "expectedOutput": "1000",
      "isHidden": false
    },
    {
      "id": "tc2",
      "description": "Name mangling",
      "input": "demonstrate_name_mangling()['private_mangled']",
      "expectedOutput": "True",
      "isHidden": false
    },
    {
      "id": "tc3",
      "description": "Property getter",
      "input": "Temperature(25).celsius",
      "expectedOutput": "25",
      "isHidden": false
    },
    {
      "id": "tc4",
      "description": "Privacy conventions",
      "input": "'protected' in privacy_conventions()",
      "expectedOutput": "True",
      "isHidden": true
    },
    {
      "id": "tc5",
      "description": "Property pattern",
      "input": "property_pattern()['modified']",
      "expectedOutput": "30",
      "isHidden": true
    },
    {
      "id": "tc6",
      "description": "Encapsulation benefits",
      "input": "'hiding' in encapsulation_benefits()",
      "expectedOutput": "True",
      "isHidden": true
    }
  ]
}