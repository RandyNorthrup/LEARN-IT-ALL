{
  "id": "exercise-127-list-advanced-techniques",
  "lessonId": "lesson-117-list-advanced-techniques",
  "title": "Advanced List Techniques",
  "description": "Master advanced list operations including unpacking, map/filter, and flattening.\n\nYour program should:\n1. Unpack lists with * operator\n2. Use map() and filter() effectively\n3. Flatten nested lists\n4. Apply functional programming patterns\n5. Work with itertools functions\n6. Understand when to use each technique\n\nImplement these functions:\n- `list_unpacking()`: Basic and extended unpacking\n- `map_filter_operations()`: Transform and filter\n- `flatten_nested()`: Flatten nested structures\n- `list_as_stack()`: Stack operations (LIFO)\n- `partition_list()`: Split by condition\n- `advanced_patterns()`: Combine techniques\n\nExample:\n```python\nfirst, *rest = [1,2,3,4]\nmap(lambda x: x**2, nums)\nfilter(lambda x: x%2==0, nums)\n```",
  "difficulty": "advanced",
  "points": 25,
  "language": "python",
  "starterCode": "def list_unpacking():\n    \"\"\"Demonstrate list unpacking patterns.\n    \n    Returns:\n        Dict with unpacking results.\n    \"\"\"\n    # TODO: List unpacking\n    # # Basic unpacking\n    # numbers = [1, 2, 3]\n    # a, b, c = numbers\n    # basic = (a, b, c)\n    # \n    # # Extended unpacking\n    # numbers = [1, 2, 3, 4, 5]\n    # first, *middle, last = numbers\n    # extended = {'first': first, 'middle': middle, 'last': last}\n    # \n    # # Skip elements\n    # first, *_, last = numbers\n    # skip = {'first': first, 'last': last}\n    # \n    # # Unpack first few\n    # first, second, *rest = numbers\n    # first_few = {'first': first, 'second': second, 'rest': rest}\n    # \n    # # Nested unpacking\n    # data = [(1, 2), (3, 4)]\n    # [(a, b), (c, d)] = data\n    # nested = {'a': a, 'b': b, 'c': c, 'd': d}\n    # \n    # return {\n    #     'basic': basic,\n    #     'extended': extended,\n    #     'skip': skip,\n    #     'first_few': first_few,\n    #     'nested': nested\n    # }\n    pass\n\ndef map_filter_operations():\n    \"\"\"Use map() and filter() functions.\n    \n    Returns:\n        Dict with transformation results.\n    \"\"\"\n    # TODO: Map and filter\n    # from functools import reduce\n    # \n    # numbers = [1, 2, 3, 4, 5, 6]\n    # \n    # # Map - transform each element\n    # squared = list(map(lambda x: x**2, numbers))\n    # \n    # # Filter - keep matching elements\n    # evens = list(filter(lambda x: x % 2 == 0, numbers))\n    # \n    # # Combine map and filter\n    # result = list(map(lambda x: x**2, filter(lambda x: x % 2 == 0, numbers)))\n    # \n    # # Map with multiple lists\n    # list1 = [1, 2, 3]\n    # list2 = [10, 20, 30]\n    # sums = list(map(lambda x, y: x + y, list1, list2))\n    # \n    # # Reduce - accumulate\n    # total = reduce(lambda x, y: x + y, numbers)\n    # product = reduce(lambda x, y: x * y, numbers, 1)\n    # \n    # # Comprehension equivalent (often clearer)\n    # comp_squared = [x**2 for x in numbers]\n    # comp_evens = [x for x in numbers if x % 2 == 0]\n    # comp_combined = [x**2 for x in numbers if x % 2 == 0]\n    # \n    # return {\n    #     'squared': squared,\n    #     'evens': evens,\n    #     'combined': result,\n    #     'sums': sums,\n    #     'total': total,\n    #     'product': product,\n    #     'comp_equals_map': comp_squared == squared,\n    #     'comp_equals_filter': comp_evens == evens\n    # }\n    pass\n\ndef flatten_nested():\n    \"\"\"Flatten nested list structures.\n    \n    Returns:\n        Dict with flattened results.\n    \"\"\"\n    # TODO: Flatten nested\n    # # Flatten one level - comprehension\n    # nested = [[1, 2], [3, 4], [5, 6]]\n    # flat_comp = [item for sublist in nested for item in sublist]\n    # \n    # # Flatten one level - itertools\n    # from itertools import chain\n    # flat_chain = list(chain.from_iterable(nested))\n    # \n    # # Flatten arbitrarily nested - recursive\n    # def flatten(nested_list):\n    #     result = []\n    #     for item in nested_list:\n    #         if isinstance(item, list):\n    #             result.extend(flatten(item))\n    #         else:\n    #             result.append(item)\n    #     return result\n    # \n    # deeply_nested = [1, [2, [3, [4, 5]], 6], 7, [8, 9]]\n    # flat_deep = flatten(deeply_nested)\n    # \n    # # Mixed types\n    # mixed = [[1, 2], 3, [4, [5, 6]]]\n    # flat_mixed = flatten(mixed)\n    # \n    # return {\n    #     'flat_comp': flat_comp,\n    #     'flat_chain': flat_chain,\n    #     'methods_equal': flat_comp == flat_chain,\n    #     'flat_deep': flat_deep,\n    #     'flat_mixed': flat_mixed\n    # }\n    pass\n\ndef list_as_stack():\n    \"\"\"Use list as stack (LIFO).\n    \n    Returns:\n        Dict with stack operation results.\n    \"\"\"\n    # TODO: Stack operations\n    # stack = []\n    # \n    # # Push elements\n    # stack.append(1)\n    # stack.append(2)\n    # stack.append(3)\n    # after_pushes = stack.copy()\n    # \n    # # Pop element\n    # popped = stack.pop()\n    # after_pop = stack.copy()\n    # \n    # # Peek (look without removing)\n    # if stack:\n    #     top = stack[-1]\n    # else:\n    #     top = None\n    # \n    # # Check if empty\n    # is_empty = len(stack) == 0\n    # \n    # # Size\n    # size = len(stack)\n    # \n    # # Process all\n    # stack = [1, 2, 3, 4, 5]\n    # processed = []\n    # while stack:\n    #     processed.append(stack.pop())\n    # \n    # return {\n    #     'after_pushes': after_pushes,\n    #     'popped': popped,\n    #     'after_pop': after_pop,\n    #     'peek': top,\n    #     'is_empty': is_empty,\n    #     'size': size,\n    #     'processed_order': processed\n    # }\n    pass\n\ndef partition_list():\n    \"\"\"Partition list by condition.\n    \n    Returns:\n        Dict with partitioned results.\n    \"\"\"\n    # TODO: Partition list\n    # numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    # \n    # # Partition into two groups\n    # evens = [x for x in numbers if x % 2 == 0]\n    # odds = [x for x in numbers if x % 2 != 0]\n    # \n    # # Using filter\n    # evens_filter = list(filter(lambda x: x % 2 == 0, numbers))\n    # odds_filter = list(filter(lambda x: x % 2 != 0, numbers))\n    # \n    # # Partition by range\n    # small = [x for x in numbers if x <= 5]\n    # large = [x for x in numbers if x > 5]\n    # \n    # # Three-way partition\n    # low = [x for x in numbers if x < 4]\n    # mid = [x for x in numbers if 4 <= x <= 7]\n    # high = [x for x in numbers if x > 7]\n    # \n    # return {\n    #     'evens': evens,\n    #     'odds': odds,\n    #     'filter_works': evens == evens_filter,\n    #     'small': small,\n    #     'large': large,\n    #     'low': low,\n    #     'mid': mid,\n    #     'high': high\n    # }\n    pass\n\ndef advanced_patterns():\n    \"\"\"Combine advanced techniques.\n    \n    Returns:\n        Dict showing combined patterns.\n    \"\"\"\n    # TODO: Advanced patterns\n    # # Pairwise iteration\n    # numbers = [1, 2, 3, 4, 5]\n    # pairs = list(zip(numbers, numbers[1:]))\n    # \n    # # Sliding window\n    # def sliding_window(lst, size):\n    #     return [lst[i:i+size] for i in range(len(lst) - size + 1)]\n    # \n    # windows = sliding_window(numbers, 3)\n    # \n    # # Chunking\n    # def chunk(lst, size):\n    #     return [lst[i:i+size] for i in range(0, len(lst), size)]\n    # \n    # chunks = chunk(numbers, 2)\n    # \n    # # Transpose (rotate 2D list)\n    # matrix = [[1, 2, 3], [4, 5, 6]]\n    # transposed = list(map(list, zip(*matrix)))\n    # \n    # # Cartesian product\n    # list1 = [1, 2]\n    # list2 = ['a', 'b']\n    # product = [(x, y) for x in list1 for y in list2]\n    # \n    # return {\n    #     'pairs': pairs,\n    #     'windows': windows,\n    #     'chunks': chunks,\n    #     'transposed': transposed,\n    #     'product': product\n    # }\n    pass\n\n# Test code\nprint(\"Advanced List Techniques:\")\nprint(\"=\"*60)\n\nprint(\"\\nList Unpacking:\")\nprint(\"-\"*60)\nunpacking = list_unpacking()\nfor name, value in unpacking.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Map/Filter Operations:\")\nprint(\"=\"*60)\nmap_filter = map_filter_operations()\nfor name, value in map_filter.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Flatten Nested:\")\nprint(\"=\"*60)\nflatten = flatten_nested()\nfor name, value in flatten.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"List as Stack:\")\nprint(\"=\"*60)\nstack = list_as_stack()\nfor name, value in stack.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Partition List:\")\nprint(\"=\"*60)\npartition = partition_list()\nfor name, value in partition.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Advanced Patterns:\")\nprint(\"=\"*60)\npatterns = advanced_patterns()\nfor name, value in patterns.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Key Concepts:\")\nprint(\"=\"*60)\nprint(\"Unpacking:\")\nprint(\"  - a, b, c = [1,2,3]: Basic unpacking\")\nprint(\"  - first, *rest, last = [1,2,3,4,5]: Extended unpacking\")\nprint(\"  - first, *_, last: Skip middle elements\")\nprint(\"\\nFunctional:\")\nprint(\"  - map(func, list): Transform each element\")\nprint(\"  - filter(func, list): Keep matching elements\")\nprint(\"  - reduce(func, list): Accumulate to single value\")\nprint(\"\\nFlattening:\")\nprint(\"  - [x for sub in nested for x in sub]: One level\")\nprint(\"  - chain.from_iterable(nested): Itertools method\")\nprint(\"  - Recursive function: Arbitrary depth\")\nprint(\"\\nStack:\")\nprint(\"  - append(): Push to stack\")\nprint(\"  - pop(): Pop from stack (LIFO)\")\nprint(\"  - [-1]: Peek at top\")",
  "solution": "def list_unpacking():\n    numbers = [1, 2, 3]\n    a, b, c = numbers\n    basic = (a, b, c)\n    \n    numbers = [1, 2, 3, 4, 5]\n    first, *middle, last = numbers\n    extended = {'first': first, 'middle': middle, 'last': last}\n    \n    first, *_, last = numbers\n    skip = {'first': first, 'last': last}\n    \n    first, second, *rest = numbers\n    first_few = {'first': first, 'second': second, 'rest': rest}\n    \n    data = [(1, 2), (3, 4)]\n    [(a, b), (c, d)] = data\n    nested = {'a': a, 'b': b, 'c': c, 'd': d}\n    \n    return {\n        'basic': basic,\n        'extended': extended,\n        'skip': skip,\n        'first_few': first_few,\n        'nested': nested\n    }\n\ndef map_filter_operations():\n    from functools import reduce\n    \n    numbers = [1, 2, 3, 4, 5, 6]\n    \n    squared = list(map(lambda x: x**2, numbers))\n    evens = list(filter(lambda x: x % 2 == 0, numbers))\n    result = list(map(lambda x: x**2, filter(lambda x: x % 2 == 0, numbers)))\n    \n    list1 = [1, 2, 3]\n    list2 = [10, 20, 30]\n    sums = list(map(lambda x, y: x + y, list1, list2))\n    \n    total = reduce(lambda x, y: x + y, numbers)\n    product = reduce(lambda x, y: x * y, numbers, 1)\n    \n    comp_squared = [x**2 for x in numbers]\n    comp_evens = [x for x in numbers if x % 2 == 0]\n    comp_combined = [x**2 for x in numbers if x % 2 == 0]\n    \n    return {\n        'squared': squared,\n        'evens': evens,\n        'combined': result,\n        'sums': sums,\n        'total': total,\n        'product': product,\n        'comp_equals_map': comp_squared == squared,\n        'comp_equals_filter': comp_evens == evens\n    }\n\ndef flatten_nested():\n    nested = [[1, 2], [3, 4], [5, 6]]\n    flat_comp = [item for sublist in nested for item in sublist]\n    \n    from itertools import chain\n    flat_chain = list(chain.from_iterable(nested))\n    \n    def flatten(nested_list):\n        result = []\n        for item in nested_list:\n            if isinstance(item, list):\n                result.extend(flatten(item))\n            else:\n                result.append(item)\n        return result\n    \n    deeply_nested = [1, [2, [3, [4, 5]], 6], 7, [8, 9]]\n    flat_deep = flatten(deeply_nested)\n    \n    mixed = [[1, 2], 3, [4, [5, 6]]]\n    flat_mixed = flatten(mixed)\n    \n    return {\n        'flat_comp': flat_comp,\n        'flat_chain': flat_chain,\n        'methods_equal': flat_comp == flat_chain,\n        'flat_deep': flat_deep,\n        'flat_mixed': flat_mixed\n    }\n\ndef list_as_stack():\n    stack = []\n    \n    stack.append(1)\n    stack.append(2)\n    stack.append(3)\n    after_pushes = stack.copy()\n    \n    popped = stack.pop()\n    after_pop = stack.copy()\n    \n    if stack:\n        top = stack[-1]\n    else:\n        top = None\n    \n    is_empty = len(stack) == 0\n    size = len(stack)\n    \n    stack = [1, 2, 3, 4, 5]\n    processed = []\n    while stack:\n        processed.append(stack.pop())\n    \n    return {\n        'after_pushes': after_pushes,\n        'popped': popped,\n        'after_pop': after_pop,\n        'peek': top,\n        'is_empty': is_empty,\n        'size': size,\n        'processed_order': processed\n    }\n\ndef partition_list():\n    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    \n    evens = [x for x in numbers if x % 2 == 0]\n    odds = [x for x in numbers if x % 2 != 0]\n    \n    evens_filter = list(filter(lambda x: x % 2 == 0, numbers))\n    odds_filter = list(filter(lambda x: x % 2 != 0, numbers))\n    \n    small = [x for x in numbers if x <= 5]\n    large = [x for x in numbers if x > 5]\n    \n    low = [x for x in numbers if x < 4]\n    mid = [x for x in numbers if 4 <= x <= 7]\n    high = [x for x in numbers if x > 7]\n    \n    return {\n        'evens': evens,\n        'odds': odds,\n        'filter_works': evens == evens_filter,\n        'small': small,\n        'large': large,\n        'low': low,\n        'mid': mid,\n        'high': high\n    }\n\ndef advanced_patterns():\n    numbers = [1, 2, 3, 4, 5]\n    pairs = list(zip(numbers, numbers[1:]))\n    \n    def sliding_window(lst, size):\n        return [lst[i:i+size] for i in range(len(lst) - size + 1)]\n    \n    windows = sliding_window(numbers, 3)\n    \n    def chunk(lst, size):\n        return [lst[i:i+size] for i in range(0, len(lst), size)]\n    \n    chunks = chunk(numbers, 2)\n    \n    matrix = [[1, 2, 3], [4, 5, 6]]\n    transposed = list(map(list, zip(*matrix)))\n    \n    list1 = [1, 2]\n    list2 = ['a', 'b']\n    product = [(x, y) for x in list1 for y in list2]\n    \n    return {\n        'pairs': pairs,\n        'windows': windows,\n        'chunks': chunks,\n        'transposed': transposed,\n        'product': product\n    }",
  "hints": [
    "Use * for extended unpacking: first, *rest, last = list",
    "map() transforms, filter() selects, reduce() accumulates",
    "Flatten one level: [x for sub in nested for x in sub]",
    "Stack: append() to push, pop() to remove last (LIFO)",
    "Comprehensions often clearer than map/filter",
    "zip(*matrix) transposes 2D list"
  ],
  "testCases": [
    {
      "id": "tc1",
      "description": "Extended unpacking",
      "input": "list_unpacking()['extended']['middle']",
      "expectedOutput": "[2, 3, 4]",
      "isHidden": false
    },
    {
      "id": "tc2",
      "description": "Map squares",
      "input": "map_filter_operations()['squared']",
      "expectedOutput": "[1, 4, 9, 16, 25, 36]",
      "isHidden": false
    },
    {
      "id": "tc3",
      "description": "Flatten deep",
      "input": "flatten_nested()['flat_deep']",
      "expectedOutput": "[1, 2, 3, 4, 5, 6, 7, 8, 9]",
      "isHidden": false
    },
    {
      "id": "tc4",
      "description": "Stack LIFO",
      "input": "list_as_stack()['processed_order']",
      "expectedOutput": "[5, 4, 3, 2, 1]",
      "isHidden": true
    },
    {
      "id": "tc5",
      "description": "Partition evens",
      "input": "partition_list()['evens']",
      "expectedOutput": "[2, 4, 6, 8, 10]",
      "isHidden": true
    },
    {
      "id": "tc6",
      "description": "Transpose matrix",
      "input": "advanced_patterns()['transposed']",
      "expectedOutput": "[[1, 4], [2, 5], [3, 6]]",
      "isHidden": true
    }
  ]
}