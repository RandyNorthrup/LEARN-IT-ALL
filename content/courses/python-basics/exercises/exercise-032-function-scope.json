{
  "id": "exercise-032-function-scope",
  "lessonId": "lesson-020-function-scope",
  "title": "Variable Scope and LEGB Rule Workshop",
  "description": "Master function scope, global/local variables, and Python's LEGB scope resolution rule.\n\nYour program should:\n1. Understand local vs global scope\n2. Use global and nonlocal keywords\n3. Apply LEGB rule (Local, Enclosing, Global, Built-in)\n4. Create closures with enclosing scope\n5. Avoid common scope pitfalls\n\nImplement these functions:\n- `get_local_demo()`: Demonstrate local scope isolation\n- `use_global_counter()`: Use global keyword to modify global\n- `create_closure_counter(start)`: Return closure with nonlocal\n- `demonstrate_legb()`: Show LEGB scope resolution\n- `safe_global_update(value)`: Safe global variable pattern\n- `nested_scope_access()`: Access variables across nested functions\n\nExample:\n```python\ncounter = create_closure_counter(0)\nprint(counter())  # 1\nprint(counter())  # 2\n```",
  "difficulty": "intermediate",
  "points": 20,
  "language": "python",
  "starterCode": "# Global variables for exercises\nglobal_counter = 0\nglobal_message = \"Hello\"\n\ndef get_local_demo():\n    \"\"\"Demonstrate local scope.\n    Create local variable 'local_var' = 42.\n    Return local_var.\n    \"\"\"\n    # TODO: Create local variable\n    # local_var = 42\n    # return local_var\n    \n    pass\n\ndef use_global_counter():\n    \"\"\"Increment global_counter by 1 using global keyword.\n    Returns new value of global_counter.\n    \"\"\"\n    # TODO: Use global keyword\n    # global global_counter\n    # global_counter += 1\n    # return global_counter\n    \n    pass\n\ndef create_closure_counter(start=0):\n    \"\"\"Create closure that maintains count.\n    Returns function that increments and returns count.\n    \"\"\"\n    # TODO: Use nonlocal in nested function\n    # count = start\n    # \n    # def increment():\n    #     nonlocal count\n    #     count += 1\n    #     return count\n    # \n    # return increment\n    \n    pass\n\ndef demonstrate_legb():\n    \"\"\"Demonstrate LEGB scope resolution.\n    Create variable 'value' in each scope level.\n    Return dict showing which scope is accessed.\n    \"\"\"\n    # TODO: Create nested scopes\n    # value = \"local\"  # Local scope\n    # \n    # def outer():\n    #     value = \"enclosing\"  # Enclosing scope\n    #     \n    #     def inner():\n    #         value = \"inner_local\"  # Inner local\n    #         return value\n    #     \n    #     return inner()\n    # \n    # return {\n    #     \"local\": value,\n    #     \"from_nested\": outer()\n    # }\n    \n    pass\n\ndef safe_global_update(value):\n    \"\"\"Safely update global_message without using global keyword.\n    Return new message (don't modify global).\n    \"\"\"\n    # TODO: Return modified value instead of changing global\n    # return f\"{global_message}, {value}\"\n    \n    pass\n\ndef nested_scope_access():\n    \"\"\"Access variables across nested function levels.\n    Outer function has 'outer_var' = \"outer\".\n    Inner function reads outer_var and returns it.\n    \"\"\"\n    # TODO: Create nested function accessing enclosing scope\n    # outer_var = \"outer\"\n    # \n    # def inner():\n    #     return outer_var  # Read from enclosing scope\n    # \n    # return inner()\n    \n    pass\n\n# Test functions\nprint(\"Local Scope Demonstration:\")\nprint(\"=\"*60)\nlocal_value = get_local_demo()\nprint(f\"Local variable value: {local_value}\")\nprint(f\"Local variable is isolated inside function\\n\")\n\nprint(\"=\"*60)\nprint(\"Global Counter Modification:\")\nprint(\"=\"*60)\nprint(f\"Initial global_counter: {global_counter}\")\nresult1 = use_global_counter()\nprint(f\"After first call: {result1}\")\nresult2 = use_global_counter()\nprint(f\"After second call: {result2}\")\nprint(f\"Global counter is now: {global_counter}\\n\")\n\nprint(\"=\"*60)\nprint(\"Closure Counter:\")\nprint(\"=\"*60)\ncounter1 = create_closure_counter(0)\nprint(\"Counter 1:\")\nprint(f\"  Call 1: {counter1()}\")\nprint(f\"  Call 2: {counter1()}\")\nprint(f\"  Call 3: {counter1()}\")\n\ncounter2 = create_closure_counter(10)\nprint(\"\\nCounter 2 (starts at 10):\")\nprint(f\"  Call 1: {counter2()}\")\nprint(f\"  Call 2: {counter2()}\")\n\nprint(\"\\nEach closure maintains its own state!\\n\")\n\nprint(\"=\"*60)\nprint(\"LEGB Scope Resolution:\")\nprint(\"=\"*60)\nlegb_result = demonstrate_legb()\nprint(\"LEGB Rule: Local -> Enclosing -> Global -> Built-in\")\nfor key, value in legb_result.items():\n    print(f\"  {key}: {value}\")\nprint()\n\nprint(\"=\"*60)\nprint(\"Safe Global Update (No Modification):\")\nprint(\"=\"*60)\nprint(f\"Original global_message: '{global_message}'\")\nnew_message = safe_global_update(\"World\")\nprint(f\"Returned message: '{new_message}'\")\nprint(f\"Global unchanged: '{global_message}'\")\nprint(\"Best practice: Return new values instead of modifying globals\\n\")\n\nprint(\"=\"*60)\nprint(\"Nested Scope Access:\")\nprint(\"=\"*60)\nnested_result = nested_scope_access()\nprint(f\"Inner function accessed outer variable: '{nested_result}'\")\nprint(\"Inner functions can READ from enclosing scope\")\nprint(\"Use 'nonlocal' to WRITE to enclosing scope\\n\")\n\nprint(\"=\"*60)\nprint(\"Scope Best Practices:\")\nprint(\"=\"*60)\nprint(\"1. Minimize global variable usage\")\nprint(\"2. Use UPPERCASE for global constants\")\nprint(\"3. Prefer returning values over modifying globals\")\nprint(\"4. Use 'global' keyword when modifying globals\")\nprint(\"5. Use 'nonlocal' for enclosing scope in closures\")\nprint(\"6. LEGB: Local -> Enclosing -> Global -> Built-in\")",
  "solution": "# Global variables for exercises\nglobal_counter = 0\nglobal_message = \"Hello\"\n\ndef get_local_demo():\n    \"\"\"Demonstrate local scope.\n    Create local variable 'local_var' = 42.\n    Return local_var.\n    \"\"\"\n    local_var = 42\n    return local_var\n\ndef use_global_counter():\n    \"\"\"Increment global_counter by 1 using global keyword.\n    Returns new value of global_counter.\n    \"\"\"\n    global global_counter\n    global_counter += 1\n    return global_counter\n\ndef create_closure_counter(start=0):\n    \"\"\"Create closure that maintains count.\n    Returns function that increments and returns count.\n    \"\"\"\n    count = start\n    \n    def increment():\n        nonlocal count\n        count += 1\n        return count\n    \n    return increment\n\ndef demonstrate_legb():\n    \"\"\"Demonstrate LEGB scope resolution.\n    Create variable 'value' in each scope level.\n    Return dict showing which scope is accessed.\n    \"\"\"\n    value = \"local\"\n    \n    def outer():\n        value = \"enclosing\"\n        \n        def inner():\n            value = \"inner_local\"\n            return value\n        \n        return inner()\n    \n    return {\n        \"local\": value,\n        \"from_nested\": outer()\n    }\n\ndef safe_global_update(value):\n    \"\"\"Safely update global_message without using global keyword.\n    Return new message (don't modify global).\n    \"\"\"\n    return f\"{global_message}, {value}\"\n\ndef nested_scope_access():\n    \"\"\"Access variables across nested function levels.\n    Outer function has 'outer_var' = \"outer\".\n    Inner function reads outer_var and returns it.\n    \"\"\"\n    outer_var = \"outer\"\n    \n    def inner():\n        return outer_var\n    \n    return inner()\n\n# Test code as provided",
  "hints": [
    "Local variables only exist inside their function",
    "Use 'global' keyword to modify global variables",
    "Use 'nonlocal' to modify enclosing scope variables",
    "LEGB: Python searches Local, Enclosing, Global, Built-in",
    "Closures 'remember' variables from enclosing scope",
    "Best practice: Return new values instead of modifying globals"
  ],
  "testCases": [
    {
      "id": "tc1",
      "description": "Local scope isolation",
      "input": "get_local_demo()",
      "expectedOutput": "42",
      "isHidden": false
    },
    {
      "id": "tc2",
      "description": "Global counter increment",
      "input": "global_counter = 0; use_global_counter(); use_global_counter()",
      "expectedOutput": "2",
      "isHidden": false
    },
    {
      "id": "tc3",
      "description": "Closure counter maintains state",
      "input": "c = create_closure_counter(5); c(); c()",
      "expectedOutput": "7",
      "isHidden": false
    },
    {
      "id": "tc4",
      "description": "LEGB demonstration",
      "input": "demonstrate_legb()",
      "expectedOutput": "{'local': 'local', 'from_nested': 'inner_local'}",
      "isHidden": true
    },
    {
      "id": "tc5",
      "description": "Safe global update",
      "input": "safe_global_update('World')",
      "expectedOutput": "'Hello, World'",
      "isHidden": true
    },
    {
      "id": "tc6",
      "description": "Nested scope access",
      "input": "nested_scope_access()",
      "expectedOutput": "'outer'",
      "isHidden": true
    }
  ]
}