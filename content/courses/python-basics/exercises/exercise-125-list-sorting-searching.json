{
  "id": "exercise-125-list-sorting-searching",
  "lessonId": "lesson-115-list-sorting-searching",
  "title": "Sorting and Searching Lists",
  "description": "Master sorting techniques and search algorithms for lists.\n\nYour program should:\n1. Use sort() vs sorted() appropriately\n2. Sort with custom key functions\n3. Search lists efficiently\n4. Find min/max with keys\n5. Use binary search for sorted lists\n6. Understand time complexity\n\nImplement these functions:\n- `sorting_basics()`: sort() vs sorted(), reverse\n- `custom_sorting()`: Sort with key functions\n- `complex_sorting()`: Sort objects, tuples\n- `linear_search()`: Find elements\n- `binary_search()`: Search sorted lists\n- `min_max_operations()`: Find extremes\n\nExample:\n```python\nnums.sort()  # In-place\nsorted(nums)  # New list\nsorted(words, key=len)  # By length\n```",
  "difficulty": "intermediate",
  "points": 20,
  "language": "python",
  "starterCode": "def sorting_basics():\n    \"\"\"Basic sorting with sort() and sorted().\n    \n    Returns:\n        Dict with sorting results.\n    \"\"\"\n    # TODO: Sorting basics\n    # # sort() - in-place, returns None\n    # nums = [3, 1, 4, 1, 5, 9, 2]\n    # result = nums.sort()\n    # sorted_inplace = nums.copy()\n    # returns_none = result\n    # \n    # # sorted() - new list, original unchanged\n    # nums = [3, 1, 4, 1, 5, 9, 2]\n    # sorted_copy = sorted(nums)\n    # original_unchanged = nums.copy()\n    # \n    # # Reverse sorting\n    # nums = [3, 1, 4, 1, 5]\n    # ascending = sorted(nums)\n    # descending = sorted(nums, reverse=True)\n    # \n    # # String sorting (lexicographic)\n    # words = [\"cherry\", \"apple\", \"banana\"]\n    # sorted_words = sorted(words)\n    # \n    # return {\n    #     'sorted_inplace': sorted_inplace,\n    #     'returns_none': returns_none,\n    #     'sorted_copy': sorted_copy,\n    #     'original_unchanged': original_unchanged,\n    #     'ascending': ascending,\n    #     'descending': descending,\n    #     'sorted_words': sorted_words\n    # }\n    pass\n\ndef custom_sorting():\n    \"\"\"Sort with custom key functions.\n    \n    Returns:\n        Dict with custom sort results.\n    \"\"\"\n    # TODO: Custom sorting\n    # # Sort by length\n    # words = [\"python\", \"is\", \"awesome\"]\n    # by_length = sorted(words, key=len)\n    # \n    # # Case-insensitive\n    # words = [\"Banana\", \"apple\", \"Cherry\"]\n    # case_insensitive = sorted(words, key=str.lower)\n    # \n    # # By absolute value\n    # numbers = [-5, 2, -8, 3, -1]\n    # by_abs = sorted(numbers, key=abs)\n    # \n    # # By last character\n    # words = [\"apple\", \"banana\", \"cherry\"]\n    # by_last = sorted(words, key=lambda x: x[-1])\n    # \n    # # Multiple criteria: length, then alphabetically\n    # words = [\"is\", \"python\", \"awesome\", \"hi\"]\n    # by_len_then_alpha = sorted(words, key=lambda x: (len(x), x))\n    # \n    # return {\n    #     'by_length': by_length,\n    #     'case_insensitive': case_insensitive,\n    #     'by_abs': by_abs,\n    #     'by_last': by_last,\n    #     'by_len_then_alpha': by_len_then_alpha\n    # }\n    pass\n\ndef complex_sorting():\n    \"\"\"Sort complex structures.\n    \n    Returns:\n        Dict with complex sort results.\n    \"\"\"\n    # TODO: Complex sorting\n    # # Sort dictionaries\n    # people = [\n    #     {\"name\": \"Alice\", \"age\": 30},\n    #     {\"name\": \"Bob\", \"age\": 25},\n    #     {\"name\": \"Charlie\", \"age\": 35}\n    # ]\n    # by_age = sorted(people, key=lambda x: x[\"age\"])\n    # by_name = sorted(people, key=lambda x: x[\"name\"])\n    # \n    # # Sort tuples\n    # data = [(3, 'c'), (1, 'a'), (2, 'b')]\n    # by_first = sorted(data)  # Natural sort\n    # by_second = sorted(data, key=lambda x: x[1])\n    # \n    # # Sort by multiple fields\n    # students = [\n    #     (\"Alice\", 85),\n    #     (\"Bob\", 92),\n    #     (\"Charlie\", 85),\n    #     (\"David\", 92)\n    # ]\n    # by_grade_then_name = sorted(students, key=lambda x: (-x[1], x[0]))\n    # \n    # return {\n    #     'by_age': [p[\"name\"] for p in by_age],\n    #     'by_name': [p[\"name\"] for p in by_name],\n    #     'by_first': by_first,\n    #     'by_second': by_second,\n    #     'by_grade_then_name': by_grade_then_name\n    # }\n    pass\n\ndef linear_search():\n    \"\"\"Linear search algorithms.\n    \n    Returns:\n        Dict with search results.\n    \"\"\"\n    # TODO: Linear search\n    # numbers = [3, 1, 4, 1, 5, 9, 2]\n    # \n    # # Find first occurrence\n    # target = 1\n    # first_index = None\n    # for i, num in enumerate(numbers):\n    #     if num == target:\n    #         first_index = i\n    #         break\n    # \n    # # Find all occurrences\n    # all_indices = [i for i, num in enumerate(numbers) if num == target]\n    # \n    # # Find first matching condition\n    # first_even = None\n    # for num in numbers:\n    #     if num % 2 == 0:\n    #         first_even = num\n    #         break\n    # \n    # # Check if all match\n    # all_positive = all(num > 0 for num in numbers)\n    # \n    # # Check if any match\n    # has_even = any(num % 2 == 0 for num in numbers)\n    # \n    # return {\n    #     'first_index': first_index,\n    #     'all_indices': all_indices,\n    #     'first_even': first_even,\n    #     'all_positive': all_positive,\n    #     'has_even': has_even\n    # }\n    pass\n\ndef binary_search():\n    \"\"\"Binary search on sorted list.\n    \n    Returns:\n        Dict with binary search results.\n    \"\"\"\n    # TODO: Binary search\n    # def binary_search_impl(sorted_list, target):\n    #     left, right = 0, len(sorted_list) - 1\n    #     while left <= right:\n    #         mid = (left + right) // 2\n    #         if sorted_list[mid] == target:\n    #             return mid\n    #         elif sorted_list[mid] < target:\n    #             left = mid + 1\n    #         else:\n    #             right = mid - 1\n    #     return -1\n    # \n    # numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    # found_5 = binary_search_impl(numbers, 5)\n    # found_1 = binary_search_impl(numbers, 1)\n    # found_9 = binary_search_impl(numbers, 9)\n    # not_found = binary_search_impl(numbers, 10)\n    # \n    # # Using bisect module\n    # import bisect\n    # insert_pos = bisect.bisect_left(numbers, 5)\n    # \n    # # Check if exists\n    # def binary_contains(sorted_list, target):\n    #     i = bisect.bisect_left(sorted_list, target)\n    #     return i < len(sorted_list) and sorted_list[i] == target\n    # \n    # contains_5 = binary_contains(numbers, 5)\n    # contains_10 = binary_contains(numbers, 10)\n    # \n    # return {\n    #     'found_5': found_5,\n    #     'found_1': found_1,\n    #     'found_9': found_9,\n    #     'not_found': not_found,\n    #     'insert_pos': insert_pos,\n    #     'contains_5': contains_5,\n    #     'contains_10': contains_10\n    # }\n    pass\n\ndef min_max_operations():\n    \"\"\"Find minimum and maximum.\n    \n    Returns:\n        Dict with min/max results.\n    \"\"\"\n    # TODO: Min/max operations\n    # numbers = [3, 1, 4, 1, 5, 9, 2]\n    # \n    # # Basic min/max\n    # minimum = min(numbers)\n    # maximum = max(numbers)\n    # \n    # # With key function\n    # words = [\"python\", \"is\", \"awesome\"]\n    # shortest = min(words, key=len)\n    # longest = max(words, key=len)\n    # \n    # # Find with index\n    # min_index = numbers.index(min(numbers))\n    # max_index = numbers.index(max(numbers))\n    # \n    # # Multiple criteria\n    # data = [(\"Alice\", 30), (\"Bob\", 25), (\"Charlie\", 30)]\n    # youngest = min(data, key=lambda x: x[1])\n    # oldest = max(data, key=lambda x: x[1])\n    # \n    # # Custom comparison\n    # points = [(1, 2), (3, 1), (2, 3)]\n    # # Closest to origin\n    # closest = min(points, key=lambda p: p[0]**2 + p[1]**2)\n    # \n    # return {\n    #     'minimum': minimum,\n    #     'maximum': maximum,\n    #     'shortest': shortest,\n    #     'longest': longest,\n    #     'min_index': min_index,\n    #     'max_index': max_index,\n    #     'youngest': youngest,\n    #     'oldest': oldest,\n    #     'closest': closest\n    # }\n    pass\n\n# Test code\nprint(\"List Sorting and Searching:\")\nprint(\"=\"*60)\n\nprint(\"\\nSorting Basics:\")\nprint(\"-\"*60)\nbasics = sorting_basics()\nfor name, value in basics.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Custom Sorting:\")\nprint(\"=\"*60)\ncustom = custom_sorting()\nfor name, value in custom.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Complex Sorting:\")\nprint(\"=\"*60)\ncomplex_demo = complex_sorting()\nfor name, value in complex_demo.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Linear Search:\")\nprint(\"=\"*60)\nlinear = linear_search()\nfor name, value in linear.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Binary Search:\")\nprint(\"=\"*60)\nbinary = binary_search()\nfor name, value in binary.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Min/Max Operations:\")\nprint(\"=\"*60)\nminmax = min_max_operations()\nfor name, value in minmax.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Key Concepts:\")\nprint(\"=\"*60)\nprint(\"Sorting:\")\nprint(\"  - sort(): In-place, returns None, O(n log n)\")\nprint(\"  - sorted(): New list, original unchanged, O(n log n)\")\nprint(\"  - key=func: Custom sort criteria\")\nprint(\"  - reverse=True: Descending order\")\nprint(\"  - Stable sort: Maintains relative order\")\nprint(\"\\nSearching:\")\nprint(\"  - Linear: O(n), works on any list\")\nprint(\"  - Binary: O(log n), requires sorted list\")\nprint(\"  - bisect module: Binary search utilities\")\nprint(\"\\nMin/Max:\")\nprint(\"  - min()/max(): Find extremes\")\nprint(\"  - key=func: Custom comparison\")\nprint(\"  - O(n) - must check all elements\")",
  "solution": "def sorting_basics():\n    nums = [3, 1, 4, 1, 5, 9, 2]\n    result = nums.sort()\n    sorted_inplace = nums.copy()\n    returns_none = result\n    \n    nums = [3, 1, 4, 1, 5, 9, 2]\n    sorted_copy = sorted(nums)\n    original_unchanged = nums.copy()\n    \n    nums = [3, 1, 4, 1, 5]\n    ascending = sorted(nums)\n    descending = sorted(nums, reverse=True)\n    \n    words = [\"cherry\", \"apple\", \"banana\"]\n    sorted_words = sorted(words)\n    \n    return {\n        'sorted_inplace': sorted_inplace,\n        'returns_none': returns_none,\n        'sorted_copy': sorted_copy,\n        'original_unchanged': original_unchanged,\n        'ascending': ascending,\n        'descending': descending,\n        'sorted_words': sorted_words\n    }\n\ndef custom_sorting():\n    words = [\"python\", \"is\", \"awesome\"]\n    by_length = sorted(words, key=len)\n    \n    words = [\"Banana\", \"apple\", \"Cherry\"]\n    case_insensitive = sorted(words, key=str.lower)\n    \n    numbers = [-5, 2, -8, 3, -1]\n    by_abs = sorted(numbers, key=abs)\n    \n    words = [\"apple\", \"banana\", \"cherry\"]\n    by_last = sorted(words, key=lambda x: x[-1])\n    \n    words = [\"is\", \"python\", \"awesome\", \"hi\"]\n    by_len_then_alpha = sorted(words, key=lambda x: (len(x), x))\n    \n    return {\n        'by_length': by_length,\n        'case_insensitive': case_insensitive,\n        'by_abs': by_abs,\n        'by_last': by_last,\n        'by_len_then_alpha': by_len_then_alpha\n    }\n\ndef complex_sorting():\n    people = [\n        {\"name\": \"Alice\", \"age\": 30},\n        {\"name\": \"Bob\", \"age\": 25},\n        {\"name\": \"Charlie\", \"age\": 35}\n    ]\n    by_age = sorted(people, key=lambda x: x[\"age\"])\n    by_name = sorted(people, key=lambda x: x[\"name\"])\n    \n    data = [(3, 'c'), (1, 'a'), (2, 'b')]\n    by_first = sorted(data)\n    by_second = sorted(data, key=lambda x: x[1])\n    \n    students = [\n        (\"Alice\", 85),\n        (\"Bob\", 92),\n        (\"Charlie\", 85),\n        (\"David\", 92)\n    ]\n    by_grade_then_name = sorted(students, key=lambda x: (-x[1], x[0]))\n    \n    return {\n        'by_age': [p[\"name\"] for p in by_age],\n        'by_name': [p[\"name\"] for p in by_name],\n        'by_first': by_first,\n        'by_second': by_second,\n        'by_grade_then_name': by_grade_then_name\n    }\n\ndef linear_search():\n    numbers = [3, 1, 4, 1, 5, 9, 2]\n    \n    target = 1\n    first_index = None\n    for i, num in enumerate(numbers):\n        if num == target:\n            first_index = i\n            break\n    \n    all_indices = [i for i, num in enumerate(numbers) if num == target]\n    \n    first_even = None\n    for num in numbers:\n        if num % 2 == 0:\n            first_even = num\n            break\n    \n    all_positive = all(num > 0 for num in numbers)\n    has_even = any(num % 2 == 0 for num in numbers)\n    \n    return {\n        'first_index': first_index,\n        'all_indices': all_indices,\n        'first_even': first_even,\n        'all_positive': all_positive,\n        'has_even': has_even\n    }\n\ndef binary_search():\n    def binary_search_impl(sorted_list, target):\n        left, right = 0, len(sorted_list) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if sorted_list[mid] == target:\n                return mid\n            elif sorted_list[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n    \n    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    found_5 = binary_search_impl(numbers, 5)\n    found_1 = binary_search_impl(numbers, 1)\n    found_9 = binary_search_impl(numbers, 9)\n    not_found = binary_search_impl(numbers, 10)\n    \n    import bisect\n    insert_pos = bisect.bisect_left(numbers, 5)\n    \n    def binary_contains(sorted_list, target):\n        i = bisect.bisect_left(sorted_list, target)\n        return i < len(sorted_list) and sorted_list[i] == target\n    \n    contains_5 = binary_contains(numbers, 5)\n    contains_10 = binary_contains(numbers, 10)\n    \n    return {\n        'found_5': found_5,\n        'found_1': found_1,\n        'found_9': found_9,\n        'not_found': not_found,\n        'insert_pos': insert_pos,\n        'contains_5': contains_5,\n        'contains_10': contains_10\n    }\n\ndef min_max_operations():\n    numbers = [3, 1, 4, 1, 5, 9, 2]\n    \n    minimum = min(numbers)\n    maximum = max(numbers)\n    \n    words = [\"python\", \"is\", \"awesome\"]\n    shortest = min(words, key=len)\n    longest = max(words, key=len)\n    \n    min_index = numbers.index(min(numbers))\n    max_index = numbers.index(max(numbers))\n    \n    data = [(\"Alice\", 30), (\"Bob\", 25), (\"Charlie\", 30)]\n    youngest = min(data, key=lambda x: x[1])\n    oldest = max(data, key=lambda x: x[1])\n    \n    points = [(1, 2), (3, 1), (2, 3)]\n    closest = min(points, key=lambda p: p[0]**2 + p[1]**2)\n    \n    return {\n        'minimum': minimum,\n        'maximum': maximum,\n        'shortest': shortest,\n        'longest': longest,\n        'min_index': min_index,\n        'max_index': max_index,\n        'youngest': youngest,\n        'oldest': oldest,\n        'closest': closest\n    }",
  "hints": [
    "sort() modifies in-place and returns None, sorted() returns new list",
    "Use key= parameter for custom sorting: key=len, key=str.lower",
    "Linear search is O(n), checks every element sequentially",
    "Binary search is O(log n) but requires sorted list",
    "min()/max() with key= parameter finds custom extremes",
    "bisect module provides efficient binary search utilities"
  ],
  "testCases": [
    {
      "id": "tc1",
      "description": "Sort returns None",
      "input": "sorting_basics()['returns_none']",
      "expectedOutput": "None",
      "isHidden": false
    },
    {
      "id": "tc2",
      "description": "Sort by length",
      "input": "custom_sorting()['by_length']",
      "expectedOutput": "['is', 'python', 'awesome']",
      "isHidden": false
    },
    {
      "id": "tc3",
      "description": "Linear search finds first",
      "input": "linear_search()['first_index']",
      "expectedOutput": "1",
      "isHidden": false
    },
    {
      "id": "tc4",
      "description": "Binary search middle",
      "input": "binary_search()['found_5']",
      "expectedOutput": "4",
      "isHidden": true
    },
    {
      "id": "tc5",
      "description": "Min with key",
      "input": "min_max_operations()['shortest']",
      "expectedOutput": "'is'",
      "isHidden": true
    },
    {
      "id": "tc6",
      "description": "Complex sort by age",
      "input": "complex_sorting()['by_age']",
      "expectedOutput": "['Bob', 'Alice', 'Charlie']",
      "isHidden": true
    }
  ]
}