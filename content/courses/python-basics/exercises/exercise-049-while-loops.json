{
  "id": "exercise-049-while-loops",
  "lessonId": "lesson-032-while-loops",
  "title": "Interactive Control Systems",
  "description": "Master while loops and loop control statements by building interactive systems. Learn condition-based iteration, input validation, and proper use of break/continue.\n\nYour program should:\n1. Use while loops for condition-based repetition\n2. Implement proper loop termination conditions\n3. Apply break and continue statements effectively\n4. Validate user input with loops\n5. Avoid infinite loops\n\nImplement these functions:\n- `countdown(n)`: Count down from n to 1\n- `sum_until_zero(numbers)`: Sum numbers until 0 found\n- `find_first_divisor(n)`: Find smallest divisor > 1\n- `validate_range(prompt, min_val, max_val)`: Get input in range\n- `process_commands(commands)`: Process commands, stop on 'quit'\n- `binary_search_iterative(arr, target)`: Binary search with while loop\n\nExample:\n```python\ncountdown(5)  # Returns [5, 4, 3, 2, 1]\ntotal = sum_until_zero([5, 10, 15, 0, 20])  # 30 (stops at 0)\n```",
  "difficulty": "intermediate",
  "points": 20,
  "language": "python",
  "starterCode": "def countdown(n):\n    \"\"\"Count down from n to 1.\"\"\"\n    # TODO: Use while loop\n    # Create result list: result = []\n    # While n > 0:\n    #   Append n to result\n    #   Decrement n: n -= 1\n    # Return result\n    \n    pass\n\ndef sum_until_zero(numbers):\n    \"\"\"Sum numbers until 0 is encountered.\"\"\"\n    # TODO: Use break to stop at 0\n    # Initialize total = 0\n    # Loop through numbers: for num in numbers\n    # If num == 0: break\n    # total += num\n    # Return total\n    \n    pass\n\ndef find_first_divisor(n):\n    \"\"\"Find smallest divisor > 1.\"\"\"\n    # TODO: Find first number that divides n\n    # If n <= 1: return None\n    # Initialize divisor = 2\n    # While divisor <= n:\n    #   If n % divisor == 0: return divisor\n    #   divisor += 1\n    # Return n (prime number)\n    \n    pass\n\ndef validate_range(prompt, min_val, max_val):\n    \"\"\"Get integer input within range (simulated).\"\"\"\n    # TODO: This is a simulation - in real code, use input()\n    # For testing, accept a list of attempts\n    # Keep asking until valid input received\n    # Return first valid number in range\n    \n    # For exercise: accept list of numbers, return first valid\n    # Real implementation would use while True with input()\n    \n    pass\n\ndef process_commands(commands):\n    \"\"\"Process commands until 'quit' found.\"\"\"\n    # TODO: Process list until 'quit'\n    # Create result list: processed = []\n    # Loop through commands: for cmd in commands\n    # If cmd == 'quit': break\n    # Otherwise: append cmd.upper() to processed\n    # Return processed\n    \n    pass\n\ndef binary_search_iterative(arr, target):\n    \"\"\"Binary search using while loop.\"\"\"\n    # TODO: Implement binary search\n    # Initialize left = 0, right = len(arr) - 1\n    # While left <= right:\n    #   Calculate mid = (left + right) // 2\n    #   If arr[mid] == target: return mid\n    #   Elif arr[mid] < target: left = mid + 1\n    #   Else: right = mid - 1\n    # Return -1 (not found)\n    \n    pass\n\n# Test the functions\nprint(\"Countdown:\")\nprint(\"=\"*60)\ncountdown_tests = [5, 3, 1, 0]\n\nfor n in countdown_tests:\n    result = countdown(n)\n    print(f\"Countdown from {n}: {result}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Sum Until Zero:\")\nprint(\"=\"*60)\nsum_tests = [\n    [5, 10, 15, 0, 20],\n    [1, 2, 3, 4, 5],\n    [0, 10, 20],\n    [10, 0, 5],\n]\n\nfor numbers in sum_tests:\n    total = sum_until_zero(numbers)\n    print(f\"Numbers: {numbers}\")\n    print(f\"Sum until 0: {total}\\n\")\n\nprint(\"=\"*60)\nprint(\"Find First Divisor:\")\nprint(\"=\"*60)\ndivisor_tests = [12, 17, 20, 1, 2]\n\nfor n in divisor_tests:\n    divisor = find_first_divisor(n)\n    is_prime = divisor == n if divisor else False\n    print(f\"Number: {n}\")\n    print(f\"First divisor: {divisor}\")\n    if is_prime and n > 1:\n        print(f\"  -> {n} is prime!\")\n    print()\n\nprint(\"=\"*60)\nprint(\"Process Commands:\")\nprint(\"=\"*60)\ncommand_tests = [\n    ['start', 'run', 'quit', 'stop'],\n    ['hello', 'world', 'quit'],\n    ['quit'],\n    ['no', 'quit', 'here'],\n]\n\nfor commands in command_tests:\n    processed = process_commands(commands)\n    print(f\"Commands: {commands}\")\n    print(f\"Processed: {processed}\\n\")\n\nprint(\"=\"*60)\nprint(\"Binary Search:\")\nprint(\"=\"*60)\narr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\nsearch_tests = [7, 15, 1, 19, 10, 20]\n\nprint(f\"Array: {arr}\\n\")\nfor target in search_tests:\n    index = binary_search_iterative(arr, target)\n    if index != -1:\n        print(f\"Target {target}: Found at index {index}\")\n    else:\n        print(f\"Target {target}: Not found\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"While Loop Patterns:\")\nprint(\"=\"*60)\n\n# Pattern: Reduce until condition\ndef halve_until_one(n):\n    \"\"\"Keep halving until <= 1.\"\"\"\n    steps = 0\n    while n > 1:\n        n = n // 2\n        steps += 1\n    return steps\n\ntest_values = [100, 50, 8, 1]\nfor val in test_values:\n    steps = halve_until_one(val)\n    print(f\"Halving {val} takes {steps} steps\")",
  "solution": "def countdown(n):\n    \"\"\"Count down from n to 1.\"\"\"\n    result = []\n    while n > 0:\n        result.append(n)\n        n -= 1\n    return result\n\ndef sum_until_zero(numbers):\n    \"\"\"Sum numbers until 0 is encountered.\"\"\"\n    total = 0\n    for num in numbers:\n        if num == 0:\n            break\n        total += num\n    return total\n\ndef find_first_divisor(n):\n    \"\"\"Find smallest divisor > 1.\"\"\"\n    if n <= 1:\n        return None\n    \n    divisor = 2\n    while divisor <= n:\n        if n % divisor == 0:\n            return divisor\n        divisor += 1\n    \n    return n  # Should not reach here for valid input\n\ndef validate_range(prompt, min_val, max_val):\n    \"\"\"Get integer input within range (simulated).\"\"\"\n    # This is a simplified version for testing\n    # In real code, would use: while True: with input()\n    # For exercise purposes, returns True if values are valid\n    return min_val <= max_val\n\ndef process_commands(commands):\n    \"\"\"Process commands until 'quit' found.\"\"\"\n    processed = []\n    for cmd in commands:\n        if cmd == 'quit':\n            break\n        processed.append(cmd.upper())\n    return processed\n\ndef binary_search_iterative(arr, target):\n    \"\"\"Binary search using while loop.\"\"\"\n    left = 0\n    right = len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1  # Not found\n\ndef halve_until_one(n):\n    \"\"\"Keep halving until <= 1.\"\"\"\n    steps = 0\n    while n > 1:\n        n = n // 2\n        steps += 1\n    return steps\n\n# Test code as provided",
  "hints": [
    "While loop syntax: while condition: ... Always update condition variable!",
    "break exits loop immediately, continue skips to next iteration",
    "For validation loops, use: while True: ... if valid: break",
    "Binary search: compare middle element, adjust left/right bounds",
    "Always ensure loop condition will eventually become False",
    "Use while for unknown iterations, for when iterating sequences"
  ],
  "testCases": [
    {
      "id": "tc1",
      "description": "Countdown from 5",
      "input": "countdown(5)",
      "expectedOutput": "[5, 4, 3, 2, 1]",
      "isHidden": false
    },
    {
      "id": "tc2",
      "description": "Sum until zero stops correctly",
      "input": "sum_until_zero([5, 10, 15, 0, 20])",
      "expectedOutput": "30",
      "isHidden": false
    },
    {
      "id": "tc3",
      "description": "Find first divisor of 12",
      "input": "find_first_divisor(12)",
      "expectedOutput": "2",
      "isHidden": false
    },
    {
      "id": "tc4",
      "description": "Process commands stops at quit",
      "input": "process_commands(['start', 'run', 'quit', 'stop'])",
      "expectedOutput": "['START', 'RUN']",
      "isHidden": true
    },
    {
      "id": "tc5",
      "description": "Binary search finds target",
      "input": "binary_search_iterative([1, 3, 5, 7, 9], 7)",
      "expectedOutput": "3",
      "isHidden": true
    },
    {
      "id": "tc6",
      "description": "Binary search returns -1 when not found",
      "input": "binary_search_iterative([1, 3, 5, 7, 9], 10)",
      "expectedOutput": "-1",
      "isHidden": true
    }
  ]
}