{
  "id": "exercise-119-scope-anti-patterns",
  "lessonId": "lesson-109-scope-anti-patterns",
  "title": "Scope Anti-Patterns and Common Mistakes",
  "description": "Identify and avoid common scope-related anti-patterns. Learn better alternatives for cleaner, maintainable code.\n\nYour program should:\n1. Recognize global abuse anti-pattern\n2. Avoid hidden dependencies\n3. Never use mutable globals\n4. Prevent shadowing built-ins\n5. Avoid late binding closure trap\n6. Use better alternatives\n\nImplement these anti-pattern demonstrations:\n- `global_abuse()`: Show excessive global usage\n- `hidden_dependency()`: Function depends on hidden state\n- `mutable_global_trap()`: Dangerous shared mutable state\n- `builtin_shadow()`: Accidentally shadow built-in\n- `late_binding_trap()`: Closure loop variable issue\n- `better_alternatives()`: Refactored versions\n\nExample:\n```python\n# ❌ BAD: Global abuse\n# ✅ GOOD: Pass parameters\n```",
  "difficulty": "advanced",
  "points": 25,
  "language": "python",
  "starterCode": "# Anti-pattern 1: Global abuse\nuser_data = {}  # Global state\n\ndef global_abuse(user_id, email):\n    \"\"\"BAD: Relies on and modifies global state.\n    \n    Returns:\n        Dict showing problems.\n    \"\"\"\n    # TODO: Show global abuse pattern\n    # global user_data\n    # user_data[user_id] = email\n    # return {\n    #     'pattern': 'Global abuse',\n    #     'problem': 'Hidden state, hard to test, race conditions',\n    #     'affected': len(user_data)\n    # }\n    pass\n\ndef better_global_abuse(user_data, user_id, email):\n    \"\"\"GOOD: Pass state as parameter.\n    \n    Returns:\n        Updated dict.\n    \"\"\"\n    # TODO: Better alternative\n    # user_data = user_data.copy()\n    # user_data[user_id] = email\n    # return user_data\n    pass\n\n# Anti-pattern 2: Hidden dependency\nconfig_value = 10\n\ndef hidden_dependency(x):\n    \"\"\"BAD: Depends on hidden global.\n    \n    Returns:\n        Result with hidden dependency.\n    \"\"\"\n    # TODO: Uses global without indication\n    # return x * config_value  # Where does config_value come from?\n    pass\n\ndef better_hidden_dependency(x, multiplier):\n    \"\"\"GOOD: Explicit dependency.\n    \n    Returns:\n        Result with explicit parameter.\n    \"\"\"\n    # TODO: All inputs visible\n    # return x * multiplier\n    pass\n\n# Anti-pattern 3: Mutable global\nshared_list = []\n\ndef mutable_global_trap(item):\n    \"\"\"BAD: Modifies shared mutable global.\n    \n    Returns:\n        Dict showing trap.\n    \"\"\"\n    # TODO: Dangerous shared state\n    # shared_list.append(item)\n    # return {\n    #     'pattern': 'Mutable global',\n    #     'problem': 'Unexpected state changes, debugging nightmare',\n    #     'list': shared_list.copy()\n    # }\n    pass\n\ndef better_mutable_global(items, new_item):\n    \"\"\"GOOD: Return new list.\n    \n    Returns:\n        New list with item added.\n    \"\"\"\n    # TODO: Immutable approach\n    # return items + [new_item]\n    pass\n\n# Anti-pattern 4: Shadowing built-ins\ndef builtin_shadow():\n    \"\"\"BAD: Shadows built-in function.\n    \n    Returns:\n        Dict showing problem.\n    \"\"\"\n    # TODO: Accidentally shadow built-in\n    # list = [1, 2, 3]  # Shadows list() built-in\n    # max = 100         # Shadows max() built-in\n    # return {\n    #     'pattern': 'Builtin shadow',\n    #     'problem': 'Loses access to built-in functions',\n    #     'shadowed': ['list', 'max']\n    # }\n    pass\n\ndef better_builtin_shadow():\n    \"\"\"GOOD: Use descriptive names.\n    \n    Returns:\n        Dict with good names.\n    \"\"\"\n    # TODO: Descriptive names\n    # items = [1, 2, 3]\n    # max_value = 100\n    # return {\n    #     'items': items,\n    #     'max_value': max_value,\n    #     'can_use_max': max(items)  # Built-in still available\n    # }\n    pass\n\n# Anti-pattern 5: Late binding closure\ndef late_binding_trap():\n    \"\"\"BAD: Closure loop variable trap.\n    \n    Returns:\n        List of functions (all return 4).\n    \"\"\"\n    # TODO: All closures capture same variable\n    # functions = []\n    # for i in range(5):\n    #     functions.append(lambda: i)  # All capture i, not i's value\n    # return [f() for f in functions]  # All return 4!\n    pass\n\ndef better_late_binding():\n    \"\"\"GOOD: Capture value with default parameter.\n    \n    Returns:\n        List of functions (return 0,1,2,3,4).\n    \"\"\"\n    # TODO: Capture value immediately\n    # functions = []\n    # for i in range(5):\n    #     functions.append(lambda x=i: x)  # Default captures current value\n    # return [f() for f in functions]\n    pass\n\ndef better_alternatives():\n    \"\"\"Summary of better patterns.\n    \n    Returns:\n        Dict of anti-patterns and solutions.\n    \"\"\"\n    # TODO: Return summary\n    # return {\n    #     'global_abuse': 'Pass state as parameters',\n    #     'hidden_dependency': 'Explicit function parameters',\n    #     'mutable_global': 'Return new values (immutable)',\n    #     'builtin_shadow': 'Use descriptive variable names',\n    #     'late_binding': 'Use default parameters or comprehensions'\n    # }\n    pass\n\n# Test code\nprint(\"Scope Anti-Patterns and Solutions:\")\nprint(\"=\"*60)\n\nprint(\"\\n❌ Anti-Pattern 1: Global Abuse\")\nprint(\"-\"*60)\nglobal_result = global_abuse('user1', 'email@example.com')\nprint(f\"Pattern: {global_result['pattern']}\")\nprint(f\"Problem: {global_result['problem']}\")\nprint(f\"Affected users: {global_result['affected']}\")\nprint(\"\\n✅ Better: Pass state as parameter\")\nbetter_data = better_global_abuse({}, 'user1', 'email@example.com')\nprint(f\"Result: {better_data}\")\nprint(\"State explicit, testable, no side effects\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"❌ Anti-Pattern 2: Hidden Dependency\")\nprint(\"-\"*60)\nhidden_result = hidden_dependency(5)\nprint(f\"Result: {hidden_result}\")\nprint(\"Problem: Where does config_value come from?\")\nprint(\"Hard to test, hard to understand\")\nprint(\"\\n✅ Better: Explicit parameters\")\nbetter_result = better_hidden_dependency(5, 10)\nprint(f\"Result: {better_result}\")\nprint(\"All inputs visible in function signature\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"❌ Anti-Pattern 3: Mutable Global\")\nprint(\"-\"*60)\nmutable_result = mutable_global_trap('item1')\nprint(f\"Pattern: {mutable_result['pattern']}\")\nprint(f\"Problem: {mutable_result['problem']}\")\nprint(f\"Current list: {mutable_result['list']}\")\nprint(\"\\n✅ Better: Return new values\")\nbetter_list = better_mutable_global([1, 2], 3)\nprint(f\"Result: {better_list}\")\nprint(\"Original unchanged, predictable behavior\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"❌ Anti-Pattern 4: Shadowing Built-ins\")\nprint(\"-\"*60)\nshadow_result = builtin_shadow()\nprint(f\"Pattern: {shadow_result['pattern']}\")\nprint(f\"Problem: {shadow_result['problem']}\")\nprint(f\"Shadowed: {shadow_result['shadowed']}\")\nprint(\"\\n✅ Better: Descriptive names\")\nbetter_names = better_builtin_shadow()\nprint(f\"Items: {better_names['items']}\")\nprint(f\"Max value: {better_names['max_value']}\")\nprint(f\"Can still use max(): {better_names['can_use_max']}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"❌ Anti-Pattern 5: Late Binding Closure\")\nprint(\"-\"*60)\nlate_result = late_binding_trap()\nprint(f\"Results: {late_result}\")\nprint(\"Problem: All closures see final loop value\")\nprint(\"Expected [0,1,2,3,4], got [4,4,4,4,4]\")\nprint(\"\\n✅ Better: Default parameter\")\nbetter_closure = better_late_binding()\nprint(f\"Results: {better_closure}\")\nprint(\"Each closure captures value at creation time\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Summary: Better Alternatives\")\nprint(\"=\"*60)\nalternatives = better_alternatives()\nfor anti_pattern, solution in alternatives.items():\n    print(f\"{anti_pattern}: {solution}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Key Takeaways:\")\nprint(\"=\"*60)\nprint(\"1. Minimize globals - Pass parameters instead\")\nprint(\"2. Make dependencies explicit - All inputs visible\")\nprint(\"3. Avoid mutable globals - Return new values\")\nprint(\"4. Don't shadow built-ins - Use descriptive names\")\nprint(\"5. Watch closure loops - Use defaults or comprehensions\")\nprint(\"\\nGood scope hygiene = Maintainable code!\")",
  "solution": "user_data = {}\n\ndef global_abuse(user_id, email):\n    global user_data\n    user_data[user_id] = email\n    return {\n        'pattern': 'Global abuse',\n        'problem': 'Hidden state, hard to test, race conditions',\n        'affected': len(user_data)\n    }\n\ndef better_global_abuse(user_data, user_id, email):\n    user_data = user_data.copy()\n    user_data[user_id] = email\n    return user_data\n\nconfig_value = 10\n\ndef hidden_dependency(x):\n    return x * config_value\n\ndef better_hidden_dependency(x, multiplier):\n    return x * multiplier\n\nshared_list = []\n\ndef mutable_global_trap(item):\n    shared_list.append(item)\n    return {\n        'pattern': 'Mutable global',\n        'problem': 'Unexpected state changes, debugging nightmare',\n        'list': shared_list.copy()\n    }\n\ndef better_mutable_global(items, new_item):\n    return items + [new_item]\n\ndef builtin_shadow():\n    list = [1, 2, 3]\n    max = 100\n    return {\n        'pattern': 'Builtin shadow',\n        'problem': 'Loses access to built-in functions',\n        'shadowed': ['list', 'max']\n    }\n\ndef better_builtin_shadow():\n    items = [1, 2, 3]\n    max_value = 100\n    return {\n        'items': items,\n        'max_value': max_value,\n        'can_use_max': max(items)\n    }\n\ndef late_binding_trap():\n    functions = []\n    for i in range(5):\n        functions.append(lambda: i)\n    return [f() for f in functions]\n\ndef better_late_binding():\n    functions = []\n    for i in range(5):\n        functions.append(lambda x=i: x)\n    return [f() for f in functions]\n\ndef better_alternatives():\n    return {\n        'global_abuse': 'Pass state as parameters',\n        'hidden_dependency': 'Explicit function parameters',\n        'mutable_global': 'Return new values (immutable)',\n        'builtin_shadow': 'Use descriptive variable names',\n        'late_binding': 'Use default parameters or comprehensions'\n    }\n\n# Test code as provided",
  "hints": [
    "Global abuse: Pass state as explicit parameters",
    "Hidden dependency: All inputs visible in signature",
    "Mutable global: Return new values, don't modify shared state",
    "Builtin shadow: Use descriptive names (items not list, max_val not max)",
    "Late binding: lambda x=i captures value, lambda: i captures variable",
    "Better alternative: Always prefer explicit over implicit"
  ],
  "testCases": [
    {
      "id": "tc1",
      "description": "Global abuse detected",
      "input": "global_abuse('u1', 'e@x.com')['pattern']",
      "expectedOutput": "'Global abuse'",
      "isHidden": false
    },
    {
      "id": "tc2",
      "description": "Better approach works",
      "input": "better_global_abuse({}, 'u1', 'e@x.com')['u1']",
      "expectedOutput": "'e@x.com'",
      "isHidden": false
    },
    {
      "id": "tc3",
      "description": "Late binding trap all same",
      "input": "len(set(late_binding_trap()))",
      "expectedOutput": "1",
      "isHidden": false
    },
    {
      "id": "tc4",
      "description": "Better late binding unique",
      "input": "len(set(better_late_binding()))",
      "expectedOutput": "5",
      "isHidden": true
    },
    {
      "id": "tc5",
      "description": "Builtin shadow problem",
      "input": "'list' in builtin_shadow()['shadowed']",
      "expectedOutput": "True",
      "isHidden": true
    },
    {
      "id": "tc6",
      "description": "Better alternatives provided",
      "input": "'parameters' in better_alternatives()['global_abuse']",
      "expectedOutput": "True",
      "isHidden": true
    }
  ]
}