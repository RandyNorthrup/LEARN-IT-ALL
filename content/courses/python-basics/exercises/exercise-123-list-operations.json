{
  "id": "exercise-123-list-operations",
  "lessonId": "lesson-113-list-operations",
  "title": "List Operations and Operators",
  "description": "Master list arithmetic, comparison, and membership operators.\n\nYour program should:\n1. Concatenate lists with +\n2. Repeat lists with *\n3. Test membership with in/not in\n4. Compare lists with ==, !=, <, >\n5. Get list length, min, max, sum\n6. Understand operator behaviors and limitations\n\nImplement these functions:\n- `concatenation()`: Combine lists with +\n- `repetition()`: Repeat with * operator\n- `membership_testing()`: Use in and not in\n- `comparison_operators()`: Compare lists\n- `aggregate_functions()`: len, min, max, sum\n- `operator_limitations()`: What doesn't work\n\nExample:\n```python\n[1,2] + [3,4]  # [1,2,3,4]\n[0] * 3  # [0,0,0]\n2 in [1,2,3]  # True\n```",
  "difficulty": "beginner",
  "points": 15,
  "language": "python",
  "starterCode": "def concatenation():\n    \"\"\"Concatenate lists with +.\n    \n    Returns:\n        Dict with concatenation results.\n    \"\"\"\n    # TODO: Concatenation\n    # list1 = [1, 2, 3]\n    # list2 = [4, 5, 6]\n    # combined = list1 + list2\n    # \n    # # Original lists unchanged\n    # original1 = list1.copy()\n    # original2 = list2.copy()\n    # \n    # # Multiple concatenation\n    # multi = [1] + [2] + [3] + [4]\n    # \n    # # Empty list\n    # with_empty = [1, 2] + []\n    # \n    # # Different types\n    # mixed = [1, 2] + [\"a\", \"b\"]\n    # \n    # return {\n    #     'combined': combined,\n    #     'original1': original1,\n    #     'original2': original2,\n    #     'multi': multi,\n    #     'with_empty': with_empty,\n    #     'mixed': mixed\n    # }\n    pass\n\ndef repetition():\n    \"\"\"Repeat lists with *.\n    \n    Returns:\n        Dict with repetition results.\n    \"\"\"\n    # TODO: Repetition\n    # pattern = [1, 2] * 3\n    # zeros = [0] * 5\n    # empty = [1, 2] * 0\n    # negative = [1, 2] * -1\n    # \n    # # Order doesn't matter\n    # forward = [1, 2] * 3\n    # backward = 3 * [1, 2]\n    # same_result = forward == backward\n    # \n    # return {\n    #     'pattern': pattern,\n    #     'zeros': zeros,\n    #     'empty': empty,\n    #     'negative': negative,\n    #     'same_result': same_result\n    # }\n    pass\n\ndef membership_testing():\n    \"\"\"Test membership with in/not in.\n    \n    Returns:\n        Dict with membership results.\n    \"\"\"\n    # TODO: Membership testing\n    # fruits = [\"apple\", \"banana\", \"cherry\"]\n    # has_apple = \"apple\" in fruits\n    # has_grape = \"grape\" in fruits\n    # no_grape = \"grape\" not in fruits\n    # \n    # numbers = [1, 2, 3, 4, 5]\n    # has_three = 3 in numbers\n    # has_ten = 10 in numbers\n    # \n    # # Nested lists\n    # nested = [[1, 2], [3, 4]]\n    # has_list = [1, 2] in nested\n    # has_one = 1 in nested  # False - checks outer level only\n    # \n    # # Strings in list\n    # words = [\"hello\", \"world\"]\n    # has_substring = \"hel\" in words  # False - exact match only\n    # has_hello = \"hello\" in words  # True\n    # \n    # return {\n    #     'has_apple': has_apple,\n    #     'has_grape': has_grape,\n    #     'no_grape': no_grape,\n    #     'has_three': has_three,\n    #     'has_ten': has_ten,\n    #     'nested_has_list': has_list,\n    #     'nested_has_one': has_one,\n    #     'has_substring': has_substring,\n    #     'has_hello': has_hello\n    # }\n    pass\n\ndef comparison_operators():\n    \"\"\"Compare lists.\n    \n    Returns:\n        Dict with comparison results.\n    \"\"\"\n    # TODO: Comparison operators\n    # # Equality\n    # list1 = [1, 2, 3]\n    # list2 = [1, 2, 3]\n    # list3 = [1, 2, 4]\n    # equal = list1 == list2\n    # not_equal = list1 != list3\n    # \n    # # Lexicographic comparison\n    # less = [1, 2] < [1, 3]\n    # greater = [2, 1] > [1, 3]\n    # \n    # # Length doesn't matter for comparison\n    # short_vs_long = [1] < [1, 0]  # False, 1 not < 1\n    # short_equal_prefix = [1, 2] < [1, 2, 3]  # True\n    # \n    # # Empty list\n    # empty_less = [] < [1]\n    # \n    # return {\n    #     'equal': equal,\n    #     'not_equal': not_equal,\n    #     'less': less,\n    #     'greater': greater,\n    #     'short_vs_long': short_vs_long,\n    #     'short_equal_prefix': short_equal_prefix,\n    #     'empty_less': empty_less\n    # }\n    pass\n\ndef aggregate_functions():\n    \"\"\"Aggregate functions on lists.\n    \n    Returns:\n        Dict with aggregate results.\n    \"\"\"\n    # TODO: Aggregate functions\n    # numbers = [1, 2, 3, 4, 5]\n    # length = len(numbers)\n    # minimum = min(numbers)\n    # maximum = max(numbers)\n    # total = sum(numbers)\n    # \n    # # Empty list behavior\n    # empty = []\n    # empty_len = len(empty)\n    # # min([]) would raise ValueError\n    # # sum([]) returns 0\n    # empty_sum = sum(empty)\n    # \n    # # With strings\n    # words = [\"apple\", \"banana\", \"cherry\"]\n    # word_count = len(words)\n    # shortest = min(words)  # Lexicographic\n    # longest_by_lex = max(words)\n    # \n    # # Custom key\n    # longest_by_len = max(words, key=len)\n    # shortest_by_len = min(words, key=len)\n    # \n    # return {\n    #     'length': length,\n    #     'minimum': minimum,\n    #     'maximum': maximum,\n    #     'total': total,\n    #     'empty_len': empty_len,\n    #     'empty_sum': empty_sum,\n    #     'word_count': word_count,\n    #     'shortest': shortest,\n    #     'longest_by_lex': longest_by_lex,\n    #     'longest_by_len': longest_by_len,\n    #     'shortest_by_len': shortest_by_len\n    # }\n    pass\n\ndef operator_limitations():\n    \"\"\"What doesn't work.\n    \n    Returns:\n        Dict explaining limitations.\n    \"\"\"\n    # TODO: Limitations\n    # limitations = {\n    #     'cant_add_non_list': 'list + 3 raises TypeError',\n    #     'cant_multiply_float': 'list * 2.5 raises TypeError',\n    #     'in_checks_equality': '\"hel\" in [\"hello\"] is False',\n    #     'nested_not_checked': '1 in [[1, 2]] is False',\n    #     'comparison_element_wise': '[1, 2] < [2] is True (compares first elements)'\n    # }\n    # \n    # # Demonstrate concat limitation\n    # try:\n    #     result = [1, 2] + 3\n    #     concat_error = False\n    # except TypeError:\n    #     concat_error = True\n    # \n    # # Demonstrate multiply limitation\n    # try:\n    #     result = [1, 2] * 2.5\n    #     multiply_error = False\n    # except TypeError:\n    #     multiply_error = True\n    # \n    # return {\n    #     'limitations': limitations,\n    #     'concat_error': concat_error,\n    #     'multiply_error': multiply_error\n    # }\n    pass\n\n# Test code\nprint(\"List Operations:\")\nprint(\"=\"*60)\n\nprint(\"\\nConcatenation (+):\")\nprint(\"-\"*60)\nconcat = concatenation()\nfor name, value in concat.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Repetition (*):\")\nprint(\"=\"*60)\nrepeat = repetition()\nfor name, value in repeat.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Membership Testing (in/not in):\")\nprint(\"=\"*60)\nmembership = membership_testing()\nfor name, value in membership.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Comparison Operators:\")\nprint(\"=\"*60)\ncomparison = comparison_operators()\nfor name, value in comparison.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Aggregate Functions:\")\nprint(\"=\"*60)\naggregates = aggregate_functions()\nfor name, value in aggregates.items():\n    print(f\"{name}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Operator Limitations:\")\nprint(\"=\"*60)\nlimits = operator_limitations()\nprint(f\"Concat error: {limits['concat_error']}\")\nprint(f\"Multiply error: {limits['multiply_error']}\")\nprint(\"\\nLimitations:\")\nfor key, value in limits['limitations'].items():\n    print(f\"  {key}: {value}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Key Concepts:\")\nprint(\"=\"*60)\nprint(\"Operators:\")\nprint(\"  - +: Concatenate (creates new list)\")\nprint(\"  - *: Repeat (creates new list)\")\nprint(\"  - in/not in: Membership test\")\nprint(\"  - ==, !=: Equality comparison\")\nprint(\"  - <, >, <=, >=: Lexicographic comparison\")\nprint(\"\\nFunctions:\")\nprint(\"  - len(): Number of elements\")\nprint(\"  - min(): Smallest element\")\nprint(\"  - max(): Largest element\")\nprint(\"  - sum(): Total of numeric elements\")\nprint(\"\\nLimitations:\")\nprint(\"  - Can't add non-list: [1] + 2 fails\")\nprint(\"  - Can't multiply by float: [1] * 2.5 fails\")\nprint(\"  - in checks exact equality, not substrings\")\nprint(\"  - Nested structures not searched recursively\")",
  "solution": "def concatenation():\n    list1 = [1, 2, 3]\n    list2 = [4, 5, 6]\n    combined = list1 + list2\n    \n    original1 = list1.copy()\n    original2 = list2.copy()\n    \n    multi = [1] + [2] + [3] + [4]\n    with_empty = [1, 2] + []\n    mixed = [1, 2] + [\"a\", \"b\"]\n    \n    return {\n        'combined': combined,\n        'original1': original1,\n        'original2': original2,\n        'multi': multi,\n        'with_empty': with_empty,\n        'mixed': mixed\n    }\n\ndef repetition():\n    pattern = [1, 2] * 3\n    zeros = [0] * 5\n    empty = [1, 2] * 0\n    negative = [1, 2] * -1\n    \n    forward = [1, 2] * 3\n    backward = 3 * [1, 2]\n    same_result = forward == backward\n    \n    return {\n        'pattern': pattern,\n        'zeros': zeros,\n        'empty': empty,\n        'negative': negative,\n        'same_result': same_result\n    }\n\ndef membership_testing():\n    fruits = [\"apple\", \"banana\", \"cherry\"]\n    has_apple = \"apple\" in fruits\n    has_grape = \"grape\" in fruits\n    no_grape = \"grape\" not in fruits\n    \n    numbers = [1, 2, 3, 4, 5]\n    has_three = 3 in numbers\n    has_ten = 10 in numbers\n    \n    nested = [[1, 2], [3, 4]]\n    has_list = [1, 2] in nested\n    has_one = 1 in nested\n    \n    words = [\"hello\", \"world\"]\n    has_substring = \"hel\" in words\n    has_hello = \"hello\" in words\n    \n    return {\n        'has_apple': has_apple,\n        'has_grape': has_grape,\n        'no_grape': no_grape,\n        'has_three': has_three,\n        'has_ten': has_ten,\n        'nested_has_list': has_list,\n        'nested_has_one': has_one,\n        'has_substring': has_substring,\n        'has_hello': has_hello\n    }\n\ndef comparison_operators():\n    list1 = [1, 2, 3]\n    list2 = [1, 2, 3]\n    list3 = [1, 2, 4]\n    equal = list1 == list2\n    not_equal = list1 != list3\n    \n    less = [1, 2] < [1, 3]\n    greater = [2, 1] > [1, 3]\n    \n    short_vs_long = [1] < [1, 0]\n    short_equal_prefix = [1, 2] < [1, 2, 3]\n    \n    empty_less = [] < [1]\n    \n    return {\n        'equal': equal,\n        'not_equal': not_equal,\n        'less': less,\n        'greater': greater,\n        'short_vs_long': short_vs_long,\n        'short_equal_prefix': short_equal_prefix,\n        'empty_less': empty_less\n    }\n\ndef aggregate_functions():\n    numbers = [1, 2, 3, 4, 5]\n    length = len(numbers)\n    minimum = min(numbers)\n    maximum = max(numbers)\n    total = sum(numbers)\n    \n    empty = []\n    empty_len = len(empty)\n    empty_sum = sum(empty)\n    \n    words = [\"apple\", \"banana\", \"cherry\"]\n    word_count = len(words)\n    shortest = min(words)\n    longest_by_lex = max(words)\n    \n    longest_by_len = max(words, key=len)\n    shortest_by_len = min(words, key=len)\n    \n    return {\n        'length': length,\n        'minimum': minimum,\n        'maximum': maximum,\n        'total': total,\n        'empty_len': empty_len,\n        'empty_sum': empty_sum,\n        'word_count': word_count,\n        'shortest': shortest,\n        'longest_by_lex': longest_by_lex,\n        'longest_by_len': longest_by_len,\n        'shortest_by_len': shortest_by_len\n    }\n\ndef operator_limitations():\n    limitations = {\n        'cant_add_non_list': 'list + 3 raises TypeError',\n        'cant_multiply_float': 'list * 2.5 raises TypeError',\n        'in_checks_equality': '\"hel\" in [\"hello\"] is False',\n        'nested_not_checked': '1 in [[1, 2]] is False',\n        'comparison_element_wise': '[1, 2] < [2] is True (compares first elements)'\n    }\n    \n    try:\n        result = [1, 2] + 3\n        concat_error = False\n    except TypeError:\n        concat_error = True\n    \n    try:\n        result = [1, 2] * 2.5\n        multiply_error = False\n    except TypeError:\n        multiply_error = True\n    \n    return {\n        'limitations': limitations,\n        'concat_error': concat_error,\n        'multiply_error': multiply_error\n    }",
  "hints": [
    "+ concatenates, creates new list, originals unchanged",
    "* repeats list n times, n * list same as list * n",
    "in checks exact equality, not substrings or nested elements",
    "Comparison is lexicographic: compares element by element",
    "len(), min(), max(), sum() are aggregate functions",
    "Can't add non-list or multiply by float"
  ],
  "testCases": [
    {
      "id": "tc1",
      "description": "Concatenate lists",
      "input": "concatenation()['combined']",
      "expectedOutput": "[1, 2, 3, 4, 5, 6]",
      "isHidden": false
    },
    {
      "id": "tc2",
      "description": "Repeat pattern",
      "input": "repetition()['pattern']",
      "expectedOutput": "[1, 2, 1, 2, 1, 2]",
      "isHidden": false
    },
    {
      "id": "tc3",
      "description": "Membership test",
      "input": "membership_testing()['has_apple']",
      "expectedOutput": "True",
      "isHidden": false
    },
    {
      "id": "tc4",
      "description": "Comparison",
      "input": "comparison_operators()['less']",
      "expectedOutput": "True",
      "isHidden": true
    },
    {
      "id": "tc5",
      "description": "Sum aggregate",
      "input": "aggregate_functions()['total']",
      "expectedOutput": "15",
      "isHidden": true
    },
    {
      "id": "tc6",
      "description": "Concat limitation",
      "input": "operator_limitations()['concat_error']",
      "expectedOutput": "True",
      "isHidden": true
    }
  ]
}