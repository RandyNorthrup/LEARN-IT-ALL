{
  "id": "exercise-113-loop-best-practices",
  "lessonId": "lesson-103-loop-best-practices",
  "title": "Pythonic Loop Patterns Refactoring",
  "description": "Refactor poorly-written loops into clean, pythonic code. Apply best practices and avoid anti-patterns.\n\nYour program should:\n1. Use descriptive variable names\n2. Apply comprehensions where appropriate\n3. Use built-in functions (enumerate, zip, sum, any, all)\n4. Avoid modifying lists while iterating\n5. Simplify nested conditions\n6. Handle errors properly\n\nImplement these functions:\n- `refactor_bad_sum(numbers)`: Replace manual sum with built-in\n- `refactor_bad_enumerate(items)`: Use enumerate() not range(len())\n- `refactor_bad_zip(names, ages)`: Use zip() for parallel iteration\n- `refactor_nested_conditions(items)`: Flatten deeply nested if statements\n- `refactor_modify_while_iterate(numbers)`: Safe list modification\n- `refactor_bad_any(numbers, target)`: Use any() instead of manual loop\n\nExample:\n```python\n# BAD: for i in range(len(items)): print(items[i])\n# GOOD: for item in items: print(item)\n```",
  "difficulty": "intermediate",
  "points": 20,
  "language": "python",
  "starterCode": "def refactor_bad_sum(numbers):\n    \"\"\"Refactor manual summation to use built-in sum().\n    \n    Original (bad) code:\n        total = 0\n        for num in numbers:\n            total += num\n        return total\n    \"\"\"\n    # TODO: Use built-in sum()\n    # return sum(numbers)\n    \n    pass\n\ndef refactor_bad_enumerate(items):\n    \"\"\"Refactor range(len()) to use enumerate().\n    Returns list of strings: \"index: item\"\n    \n    Original (bad) code:\n        result = []\n        for i in range(len(items)):\n            result.append(f\"{i}: {items[i]}\")\n        return result\n    \"\"\"\n    # TODO: Use enumerate()\n    # return [f\"{i}: {item}\" for i, item in enumerate(items)]\n    \n    pass\n\ndef refactor_bad_zip(names, ages):\n    \"\"\"Refactor parallel iteration to use zip().\n    Returns list of strings: \"name is age years old\"\n    \n    Original (bad) code:\n        result = []\n        for i in range(len(names)):\n            result.append(f\"{names[i]} is {ages[i]} years old\")\n        return result\n    \"\"\"\n    # TODO: Use zip()\n    # return [f\"{name} is {age} years old\" for name, age in zip(names, ages)]\n    \n    pass\n\ndef refactor_nested_conditions(items):\n    \"\"\"Refactor deeply nested conditions using early returns.\n    Filter items where: score > 50 AND age >= 18 AND active is True\n    \n    Original (bad) code:\n        result = []\n        for item in items:\n            if item['score'] > 50:\n                if item['age'] >= 18:\n                    if item['active']:\n                        result.append(item)\n        return result\n    \"\"\"\n    # TODO: Use combined conditions or comprehension\n    # return [\n    #   item for item in items\n    #   if item['score'] > 50 and item['age'] >= 18 and item['active']\n    # ]\n    \n    pass\n\ndef refactor_modify_while_iterate(numbers):\n    \"\"\"Safely remove even numbers from list.\n    \n    Original (bad) code:\n        for num in numbers:\n            if num % 2 == 0:\n                numbers.remove(num)  # DANGEROUS!\n        return numbers\n    \"\"\"\n    # TODO: Create new list with comprehension\n    # return [num for num in numbers if num % 2 != 0]\n    \n    pass\n\ndef refactor_bad_any(numbers, target):\n    \"\"\"Check if target exists in numbers using any().\n    \n    Original (bad) code:\n        for num in numbers:\n            if num == target:\n                return True\n        return False\n    \"\"\"\n    # TODO: Use built-in any()\n    # return target in numbers  # Even simpler!\n    # OR: return any(num == target for num in numbers)\n    \n    pass\n\n# Test functions\nprint(\"Refactor Manual Sum to Built-in:\")\nprint(\"=\"*60)\ntest_lists = [\n    [1, 2, 3, 4, 5],\n    [10, 20, 30, 40],\n    [100, 200, 300],\n]\n\nfor numbers in test_lists:\n    result = refactor_bad_sum(numbers)\n    print(f\"sum({numbers}): {result}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Refactor range(len()) to enumerate():\")\nprint(\"=\"*60)\ntest_items = [\n    ['apple', 'banana', 'cherry'],\n    ['Python', 'Java', 'JavaScript'],\n    ['red', 'green', 'blue'],\n]\n\nfor items in test_items:\n    result = refactor_bad_enumerate(items)\n    print(f\"Items: {items}\")\n    for line in result:\n        print(f\"  {line}\")\n    print()\n\nprint(\"=\"*60)\nprint(\"Refactor Parallel Iteration to zip():\")\nprint(\"=\"*60)\nnames = ['Alice', 'Bob', 'Charlie']\nages = [25, 30, 35]\nresult = refactor_bad_zip(names, ages)\nprint(f\"Names: {names}\")\nprint(f\"Ages: {ages}\")\nprint(\"Result:\")\nfor line in result:\n    print(f\"  {line}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Refactor Nested Conditions:\")\nprint(\"=\"*60)\ntest_items = [\n    {'name': 'Alice', 'score': 60, 'age': 20, 'active': True},\n    {'name': 'Bob', 'score': 40, 'age': 25, 'active': True},\n    {'name': 'Charlie', 'score': 70, 'age': 17, 'active': True},\n    {'name': 'David', 'score': 80, 'age': 22, 'active': False},\n    {'name': 'Eve', 'score': 90, 'age': 30, 'active': True},\n]\n\nfiltered = refactor_nested_conditions(test_items)\nprint(\"Items passing filter (score > 50, age >= 18, active):\")\nfor item in filtered:\n    print(f\"  {item['name']}: score={item['score']}, age={item['age']}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Refactor Modify While Iterating:\")\nprint(\"=\"*60)\ntest_lists = [\n    [1, 2, 3, 4, 5, 6],\n    [1, 3, 5, 7, 9],\n    [2, 4, 6, 8, 10],\n]\n\nfor numbers in test_lists:\n    original = numbers.copy()\n    result = refactor_modify_while_iterate(numbers)\n    print(f\"Original: {original}\")\n    print(f\"After removing evens: {result}\\n\")\n\nprint(\"=\"*60)\nprint(\"Refactor Manual Search to any():\")\nprint(\"=\"*60)\ntest_cases = [\n    ([1, 2, 3, 4, 5], 3, True),\n    ([10, 20, 30], 15, False),\n    ([5, 10, 15, 20], 20, True),\n]\n\nfor numbers, target, expected in test_cases:\n    result = refactor_bad_any(numbers, target)\n    status = \"✓\" if result == expected else \"✗\"\n    print(f\"{status} {target} in {numbers}: {result}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Best Practices Summary:\")\nprint(\"=\"*60)\nprint(\"1. Use built-in functions: sum(), min(), max(), any(), all()\")\nprint(\"2. Use enumerate() instead of range(len())\")\nprint(\"3. Use zip() for parallel iteration\")\nprint(\"4. Use comprehensions for simple transformations\")\nprint(\"5. Flatten nested conditions with combined logic\")\nprint(\"6. Create new list instead of modifying while iterating\")\nprint(\"7. Use 'in' operator for membership testing\")\nprint(\"\\nPythonic code is readable, maintainable, and efficient!\")",
  "solution": "def refactor_bad_sum(numbers):\n    \"\"\"Refactor manual summation to use built-in sum().\"\"\"\n    return sum(numbers)\n\ndef refactor_bad_enumerate(items):\n    \"\"\"Refactor range(len()) to use enumerate().\n    Returns list of strings: \"index: item\"\"\"\n    return [f\"{i}: {item}\" for i, item in enumerate(items)]\n\ndef refactor_bad_zip(names, ages):\n    \"\"\"Refactor parallel iteration to use zip().\n    Returns list of strings: \"name is age years old\"\"\"\n    return [f\"{name} is {age} years old\" for name, age in zip(names, ages)]\n\ndef refactor_nested_conditions(items):\n    \"\"\"Refactor deeply nested conditions using early returns.\n    Filter items where: score > 50 AND age >= 18 AND active is True\"\"\"\n    return [\n        item for item in items\n        if item['score'] > 50 and item['age'] >= 18 and item['active']\n    ]\n\ndef refactor_modify_while_iterate(numbers):\n    \"\"\"Safely remove even numbers from list.\"\"\"\n    return [num for num in numbers if num % 2 != 0]\n\ndef refactor_bad_any(numbers, target):\n    \"\"\"Check if target exists in numbers using any().\"\"\"\n    return target in numbers\n\n# Test code as provided",
  "hints": [
    "Built-in sum() is C-optimized and faster than manual loops",
    "enumerate() returns (index, item) tuples automatically",
    "zip() pairs elements from multiple iterables",
    "Combine conditions with 'and' instead of nesting",
    "List comprehensions create new lists safely",
    "'in' operator is pythonic for membership testing"
  ],
  "testCases": [
    {
      "id": "tc1",
      "description": "Refactor sum using built-in",
      "input": "refactor_bad_sum([1, 2, 3, 4, 5])",
      "expectedOutput": "15",
      "isHidden": false
    },
    {
      "id": "tc2",
      "description": "Refactor to enumerate()",
      "input": "refactor_bad_enumerate(['a', 'b', 'c'])",
      "expectedOutput": "['0: a', '1: b', '2: c']",
      "isHidden": false
    },
    {
      "id": "tc3",
      "description": "Refactor to zip()",
      "input": "refactor_bad_zip(['Alice', 'Bob'], [25, 30])",
      "expectedOutput": "['Alice is 25 years old', 'Bob is 30 years old']",
      "isHidden": false
    },
    {
      "id": "tc4",
      "description": "Flatten nested conditions",
      "input": "refactor_nested_conditions([{'score': 60, 'age': 20, 'active': True}, {'score': 40, 'age': 25, 'active': True}])",
      "expectedOutput": "[{'score': 60, 'age': 20, 'active': True}]",
      "isHidden": true
    },
    {
      "id": "tc5",
      "description": "Safe list modification",
      "input": "refactor_modify_while_iterate([1, 2, 3, 4, 5])",
      "expectedOutput": "[1, 3, 5]",
      "isHidden": true
    },
    {
      "id": "tc6",
      "description": "Refactor to membership test",
      "input": "refactor_bad_any([1, 2, 3], 2)",
      "expectedOutput": "True",
      "isHidden": true
    }
  ]
}