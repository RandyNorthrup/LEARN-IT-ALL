{
  "id": "exercise-129-list-best-practices",
  "lessonId": "lesson-119-list-best-practices",
  "title": "List Best Practices and Patterns",
  "description": "Master idiomatic list usage and avoid common pitfalls.\n\nYour program should:\n1. Choose appropriate data structures\n2. Write idiomatic list comprehensions\n3. Follow naming conventions\n4. Use efficient iteration patterns\n5. Avoid common anti-patterns\n6. Apply pythonic list techniques\n\nImplement these functions:\n- `choosing_lists()`: When to use lists vs alternatives\n- `comprehension_guidelines()`: Good vs bad comprehensions\n- `naming_conventions()`: Proper list naming\n- `iteration_best_practices()`: Efficient iteration\n- `common_pitfalls()`: Avoid mistakes\n- `pythonic_patterns()`: Idiomatic code\n\nExample:\n```python\n# Good: [x**2 for x in nums]\n# Bad: map(lambda x: x**2, nums)\n# Use set for membership testing\n```",
  "difficulty": "advanced",
  "points": 25,
  "language": "python",
  "starterCode": "def choosing_lists():\n    \"\"\"When to use lists vs alternatives.\n    \n    Returns:\n        Dict with data structure choices.\n    \"\"\"\n    # TODO: Choosing lists\n    # # ✅ Use list when:\n    # use_list = {\n    #     'ordered': 'Order matters',\n    #     'duplicates': 'Duplicate elements allowed',\n    #     'indexing': 'Need list[i] access',\n    #     'appending': 'Frequent appends'\n    # }\n    # \n    # # Example: Shopping cart\n    # cart = ['apple', 'banana', 'apple']  # Order, duplicates OK\n    # \n    # # ❌ DON'T use list for:\n    # dont_use_list = {\n    #     'membership': 'Use set - O(1) vs O(n)',\n    #     'lookup': 'Use dict - O(1) vs O(n)',\n    #     'queue': 'Use deque - O(1) vs O(n) for pop(0)'\n    # }\n    # \n    # # BAD: List for membership\n    # banned = ['user1', 'user2', 'user3']\n    # check_list = 'user2' in banned  # O(n)\n    # \n    # # GOOD: Set for membership\n    # banned_set = {'user1', 'user2', 'user3'}\n    # check_set = 'user2' in banned_set  # O(1)\n    # \n    # # BAD: List for lookup\n    # users = [('alice', 30), ('bob', 25)]\n    # # Must iterate to find\n    # \n    # # GOOD: Dict for lookup\n    # users_dict = {'alice': 30, 'bob': 25}\n    # age = users_dict['alice']  # O(1)\n    # \n    # return {\n    #     'use_list_when': use_list,\n    #     'dont_use_list_for': dont_use_list,\n    #     'cart_example': cart,\n    #     'set_faster': check_set == check_list,\n    #     'dict_age': age\n    # }\n    pass\n\ndef comprehension_guidelines():\n    \"\"\"Good vs bad list comprehensions.\n    \n    Returns:\n        Dict with comprehension examples.\n    \"\"\"\n    # TODO: Comprehension guidelines\n    # # ✅ GOOD: Clear and concise\n    # good_simple = [x**2 for x in range(10)]\n    # good_filter = [x for x in range(20) if x % 2 == 0]\n    # good_matrix = [[i*j for j in range(3)] for i in range(3)]\n    # \n    # # ⚠️ OK: Still readable\n    # ok_multi = [x for x in range(20) if x % 2 == 0 if x % 3 == 0]\n    # \n    # # ❌ BAD: Too complex\n    # # Use regular loop instead\n    # def transform(x):\n    #     if x > 0:\n    #         return x**2\n    #     elif x < 0:\n    #         return x**3\n    #     else:\n    #         return 0\n    # \n    # better = [transform(x) for x in range(-5, 6) if abs(x) > 2]\n    # \n    # # ✅ GOOD: Nested for flattening\n    # nested = [[1, 2], [3, 4], [5, 6]]\n    # flat = [item for sublist in nested for item in sublist]\n    # \n    # # Guideline: Max 2 levels of nesting\n    # guidelines = {\n    #     'simple': 'Single expression, clear intent',\n    #     'filter': 'One or two conditions max',\n    #     'nested': 'Max 2 levels deep',\n    #     'complex': 'Use function or loop'\n    # }\n    # \n    # return {\n    #     'good_simple': good_simple,\n    #     'good_filter': good_filter,\n    #     'good_matrix': good_matrix,\n    #     'better_complex': better,\n    #     'flat': flat,\n    #     'guidelines': guidelines\n    # }\n    pass\n\ndef naming_conventions():\n    \"\"\"Proper list naming.\n    \n    Returns:\n        Dict with naming examples.\n    \"\"\"\n    # TODO: Naming conventions\n    # # ✅ GOOD: Plural names\n    # users = ['alice', 'bob', 'charlie']\n    # numbers = [1, 2, 3, 4, 5]\n    # fruits = ['apple', 'banana', 'cherry']\n    # \n    # # ✅ GOOD: Descriptive names\n    # active_users = [u for u in users if u != 'bob']\n    # sorted_numbers = sorted(numbers, reverse=True)\n    # filtered_fruits = [f for f in fruits if len(f) > 5]\n    # \n    # # ✅ GOOD: Singular in loops\n    # user_lengths = []\n    # for user in users:\n    #     user_lengths.append(len(user))\n    # \n    # # ❌ BAD: Unclear names\n    # # list1 = [...]  # What is this?\n    # # data = [...]   # Too generic\n    # # tmp = [...]    # Temporary what?\n    # # x = [...]      # Single letter\n    # \n    # naming_rules = {\n    #     'plural_names': 'users not user for lists',\n    #     'descriptive': 'active_users not au',\n    #     'singular_loop': 'for user in users',\n    #     'avoid': 'list1, data, tmp, x'\n    # }\n    # \n    # return {\n    #     'users': users,\n    #     'active_users': active_users,\n    #     'sorted_numbers': sorted_numbers,\n    #     'user_lengths': user_lengths,\n    #     'naming_rules': naming_rules\n    # }\n    pass\n\ndef iteration_best_practices():\n    \"\"\"Efficient iteration patterns.\n    \n    Returns:\n        Dict with iteration examples.\n    \"\"\"\n    # TODO: Iteration best practices\n    # items = ['a', 'b', 'c', 'd', 'e']\n    # \n    # # ✅ GOOD: Direct iteration\n    # good_direct = [item.upper() for item in items]\n    # \n    # # ❌ BAD: Using range(len()) unnecessarily\n    # bad_range = [items[i].upper() for i in range(len(items))]\n    # \n    # # ✅ GOOD: Use enumerate when you need index\n    # good_enum = [f\"{i}: {item}\" for i, item in enumerate(items)]\n    # \n    # # ✅ GOOD: Use zip for parallel iteration\n    # names = ['Alice', 'Bob', 'Charlie']\n    # ages = [25, 30, 35]\n    # good_zip = [f\"{name} is {age}\" for name, age in zip(names, ages)]\n    # \n    # # ✅ GOOD: Early termination with any/all\n    # numbers = [1, 2, 3, 4, 5, 6]\n    # has_even = any(n % 2 == 0 for n in numbers)\n    # all_positive = all(n > 0 for n in numbers)\n    # \n    # # ✅ GOOD: Reverse iteration\n    # reversed_items = list(reversed(items))\n    # # or\n    # reversed_slice = items[::-1]\n    # \n    # patterns = {\n    #     'direct': 'for item in items',\n    #     'enumerate': 'for i, item in enumerate(items)',\n    #     'zip': 'for x, y in zip(list1, list2)',\n    #     'any_all': 'any()/all() for early exit',\n    #     'reversed': 'reversed() or [::-1]'\n    # }\n    # \n    # return {\n    #     'good_direct': good_direct,\n    #     'results_equal': good_direct == bad_range,\n    #     'with_index': good_enum,\n    #     'parallel': good_zip,\n    #     'has_even': has_even,\n    #     'all_positive': all_positive,\n    #     'patterns': patterns\n    # }\n    pass\n\ndef common_pitfalls():\n    \"\"\"Avoid common mistakes.\n    \n    Returns:\n        Dict showing pitfalls and solutions.\n    \"\"\"\n    # TODO: Common pitfalls\n    # # PITFALL 1: Modifying while iterating\n    # # BAD\n    # # nums = [1, 2, 3, 4, 5]\n    # # for num in nums:\n    # #     if num % 2 == 0:\n    # #         nums.remove(num)  # Skips elements!\n    # \n    # # GOOD: Iterate over copy\n    # nums = [1, 2, 3, 4, 5]\n    # for num in nums.copy():\n    #     if num % 2 == 0:\n    #         nums.remove(num)\n    # pitfall1_result = nums.copy()\n    # \n    # # PITFALL 2: Mutable default argument\n    # # BAD\n    # def bad_append(item, lst=[]):\n    #     lst.append(item)\n    #     return lst\n    # \n    # # r1 = bad_append(1)  # [1]\n    # # r2 = bad_append(2)  # [1, 2] - Oops!\n    # \n    # # GOOD: Use None\n    # def good_append(item, lst=None):\n    #     if lst is None:\n    #         lst = []\n    #     lst.append(item)\n    #     return lst\n    # \n    # g1 = good_append(1)\n    # g2 = good_append(2)\n    # \n    # # PITFALL 3: Shallow copy trap\n    # nested = [[1, 2], [3, 4]]\n    # shallow = nested[:]\n    # shallow[0][0] = 99\n    # # nested is affected!\n    # \n    # # GOOD: Deep copy\n    # import copy\n    # nested2 = [[1, 2], [3, 4]]\n    # deep = copy.deepcopy(nested2)\n    # deep[0][0] = 99\n    # # nested2 is safe\n    # \n    # pitfalls = {\n    #     'modify_iterate': 'Iterate over copy',\n    #     'mutable_default': 'Use None, create in function',\n    #     'shallow_copy': 'Use deepcopy for nested'\n    # }\n    # \n    # return {\n    #     'pitfall1_fixed': pitfall1_result,\n    #     'good_g1': g1,\n    #     'good_g2': g2,\n    #     'nested2_safe': nested2,\n    #     'pitfalls': pitfalls\n    # }\n    pass\n\ndef pythonic_patterns():\n    \"\"\"Idiomatic Python list code.\n    \n    Returns:\n        Dict with pythonic examples.\n    \"\"\"\n    # TODO: Pythonic patterns\n    # # ✅ Swap elements\n    # a, b = 1, 2\n    # a, b = b, a  # Pythonic swap\n    # swapped = (a, b)\n    # \n    # # ✅ Multiple assignment\n    # nums = [1, 2, 3]\n    # x, y, z = nums\n    # assigned = (x, y, z)\n    # \n    # # ✅ Unpack with *\n    # first, *rest = [1, 2, 3, 4, 5]\n    # unpacked = {'first': first, 'rest': rest}\n    # \n    # # ✅ Chain comparisons\n    # x = 5\n    # chained = 1 < x < 10  # Pythonic\n    # # Not: x > 1 and x < 10\n    # \n    # # ✅ Use in for membership\n    # allowed = ['read', 'write', 'execute']\n    # can_write = 'write' in allowed\n    # \n    # # ✅ Use enumerate instead of range(len())\n    # items = ['a', 'b', 'c']\n    # indexed = {i: item for i, item in enumerate(items)}\n    # \n    # # ✅ Use zip for parallel iteration\n    # keys = ['name', 'age', 'city']\n    # values = ['Alice', 25, 'NYC']\n    # paired = dict(zip(keys, values))\n    # \n    # # ✅ Comprehension over map/filter\n    # nums = [1, 2, 3, 4, 5, 6]\n    # pythonic = [x**2 for x in nums if x % 2 == 0]\n    # # More readable than: list(map(lambda x: x**2, filter(...)))\n    # \n    # patterns = {\n    #     'swap': 'a, b = b, a',\n    #     'unpack': 'first, *rest = list',\n    #     'chain': '1 < x < 10',\n    #     'membership': 'x in list',\n    #     'enumerate': 'for i, x in enumerate(list)',\n    #     'zip': 'zip(list1, list2)',\n    #     'comprehension': '[x for x in list if ...]'\n    # }\n    # \n    # return {\n    #     'swapped': swapped,\n    #     'assigned': assigned,\n    #     'unpacked': unpacked,\n    #     'chained': chained,\n    #     'can_write': can_write,\n    #     'indexed': indexed,\n    #     'paired': paired,\n    #     'pythonic': pythonic,\n    #     'patterns': patterns\n    # }\n    pass\n\n# Test code\nprint(\"List Best Practices:\")\nprint(\"=\"*60)\n\nprint(\"\\nChoosing Lists:\")\nprint(\"-\"*60)\nchoosing = choosing_lists()\nprint(\"Use list when:\")\nfor key, val in choosing['use_list_when'].items():\n    print(f\"  - {val}\")\nprint(\"\\nDon't use list for:\")\nfor key, val in choosing['dont_use_list_for'].items():\n    print(f\"  - {key}: {val}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Comprehension Guidelines:\")\nprint(\"=\"*60)\ncomp = comprehension_guidelines()\nprint(\"Guidelines:\")\nfor key, val in comp['guidelines'].items():\n    print(f\"  {key}: {val}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Naming Conventions:\")\nprint(\"=\"*60)\nnaming = naming_conventions()\nprint(\"Naming rules:\")\nfor key, val in naming['naming_rules'].items():\n    print(f\"  {key}: {val}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Iteration Best Practices:\")\nprint(\"=\"*60)\niteration = iteration_best_practices()\nprint(\"Patterns:\")\nfor key, val in iteration['patterns'].items():\n    print(f\"  {key}: {val}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Common Pitfalls:\")\nprint(\"=\"*60)\npitfalls = common_pitfalls()\nprint(\"Avoid:\")\nfor key, val in pitfalls['pitfalls'].items():\n    print(f\"  {key}: {val}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Pythonic Patterns:\")\nprint(\"=\"*60)\npythonic = pythonic_patterns()\nprint(\"Idiomatic Python:\")\nfor key, val in pythonic['patterns'].items():\n    print(f\"  {key}: {val}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Golden Rules:\")\nprint(\"=\"*60)\nprint(\"1. Readability counts - clear beats clever\")\nprint(\"2. Use comprehensions for simple transformations\")\nprint(\"3. Choose right data structure - set/dict when appropriate\")\nprint(\"4. Iterate directly - avoid range(len())\")\nprint(\"5. Don't modify while iterating\")\nprint(\"6. Never use mutable default arguments\")\nprint(\"7. Use deepcopy for nested structures\")\nprint(\"8. Profile before optimizing\")\nprint(\"9. Explicit is better than implicit\")\nprint(\"10. There should be one obvious way to do it\")",
  "solution": "def choosing_lists():\n    use_list = {\n        'ordered': 'Order matters',\n        'duplicates': 'Duplicate elements allowed',\n        'indexing': 'Need list[i] access',\n        'appending': 'Frequent appends'\n    }\n    \n    cart = ['apple', 'banana', 'apple']\n    \n    dont_use_list = {\n        'membership': 'Use set - O(1) vs O(n)',\n        'lookup': 'Use dict - O(1) vs O(n)',\n        'queue': 'Use deque - O(1) vs O(n) for pop(0)'\n    }\n    \n    banned = ['user1', 'user2', 'user3']\n    check_list = 'user2' in banned\n    \n    banned_set = {'user1', 'user2', 'user3'}\n    check_set = 'user2' in banned_set\n    \n    users_dict = {'alice': 30, 'bob': 25}\n    age = users_dict['alice']\n    \n    return {\n        'use_list_when': use_list,\n        'dont_use_list_for': dont_use_list,\n        'cart_example': cart,\n        'set_faster': check_set == check_list,\n        'dict_age': age\n    }\n\ndef comprehension_guidelines():\n    good_simple = [x**2 for x in range(10)]\n    good_filter = [x for x in range(20) if x % 2 == 0]\n    good_matrix = [[i*j for j in range(3)] for i in range(3)]\n    \n    ok_multi = [x for x in range(20) if x % 2 == 0 if x % 3 == 0]\n    \n    def transform(x):\n        if x > 0:\n            return x**2\n        elif x < 0:\n            return x**3\n        else:\n            return 0\n    \n    better = [transform(x) for x in range(-5, 6) if abs(x) > 2]\n    \n    nested = [[1, 2], [3, 4], [5, 6]]\n    flat = [item for sublist in nested for item in sublist]\n    \n    guidelines = {\n        'simple': 'Single expression, clear intent',\n        'filter': 'One or two conditions max',\n        'nested': 'Max 2 levels deep',\n        'complex': 'Use function or loop'\n    }\n    \n    return {\n        'good_simple': good_simple,\n        'good_filter': good_filter,\n        'good_matrix': good_matrix,\n        'better_complex': better,\n        'flat': flat,\n        'guidelines': guidelines\n    }\n\ndef naming_conventions():\n    users = ['alice', 'bob', 'charlie']\n    numbers = [1, 2, 3, 4, 5]\n    fruits = ['apple', 'banana', 'cherry']\n    \n    active_users = [u for u in users if u != 'bob']\n    sorted_numbers = sorted(numbers, reverse=True)\n    filtered_fruits = [f for f in fruits if len(f) > 5]\n    \n    user_lengths = []\n    for user in users:\n        user_lengths.append(len(user))\n    \n    naming_rules = {\n        'plural_names': 'users not user for lists',\n        'descriptive': 'active_users not au',\n        'singular_loop': 'for user in users',\n        'avoid': 'list1, data, tmp, x'\n    }\n    \n    return {\n        'users': users,\n        'active_users': active_users,\n        'sorted_numbers': sorted_numbers,\n        'user_lengths': user_lengths,\n        'naming_rules': naming_rules\n    }\n\ndef iteration_best_practices():\n    items = ['a', 'b', 'c', 'd', 'e']\n    \n    good_direct = [item.upper() for item in items]\n    bad_range = [items[i].upper() for i in range(len(items))]\n    good_enum = [f\"{i}: {item}\" for i, item in enumerate(items)]\n    \n    names = ['Alice', 'Bob', 'Charlie']\n    ages = [25, 30, 35]\n    good_zip = [f\"{name} is {age}\" for name, age in zip(names, ages)]\n    \n    numbers = [1, 2, 3, 4, 5, 6]\n    has_even = any(n % 2 == 0 for n in numbers)\n    all_positive = all(n > 0 for n in numbers)\n    \n    reversed_items = list(reversed(items))\n    reversed_slice = items[::-1]\n    \n    patterns = {\n        'direct': 'for item in items',\n        'enumerate': 'for i, item in enumerate(items)',\n        'zip': 'for x, y in zip(list1, list2)',\n        'any_all': 'any()/all() for early exit',\n        'reversed': 'reversed() or [::-1]'\n    }\n    \n    return {\n        'good_direct': good_direct,\n        'results_equal': good_direct == bad_range,\n        'with_index': good_enum,\n        'parallel': good_zip,\n        'has_even': has_even,\n        'all_positive': all_positive,\n        'patterns': patterns\n    }\n\ndef common_pitfalls():\n    nums = [1, 2, 3, 4, 5]\n    for num in nums.copy():\n        if num % 2 == 0:\n            nums.remove(num)\n    pitfall1_result = nums.copy()\n    \n    def good_append(item, lst=None):\n        if lst is None:\n            lst = []\n        lst.append(item)\n        return lst\n    \n    g1 = good_append(1)\n    g2 = good_append(2)\n    \n    import copy\n    nested2 = [[1, 2], [3, 4]]\n    deep = copy.deepcopy(nested2)\n    deep[0][0] = 99\n    \n    pitfalls = {\n        'modify_iterate': 'Iterate over copy',\n        'mutable_default': 'Use None, create in function',\n        'shallow_copy': 'Use deepcopy for nested'\n    }\n    \n    return {\n        'pitfall1_fixed': pitfall1_result,\n        'good_g1': g1,\n        'good_g2': g2,\n        'nested2_safe': nested2,\n        'pitfalls': pitfalls\n    }\n\ndef pythonic_patterns():\n    a, b = 1, 2\n    a, b = b, a\n    swapped = (a, b)\n    \n    nums = [1, 2, 3]\n    x, y, z = nums\n    assigned = (x, y, z)\n    \n    first, *rest = [1, 2, 3, 4, 5]\n    unpacked = {'first': first, 'rest': rest}\n    \n    x = 5\n    chained = 1 < x < 10\n    \n    allowed = ['read', 'write', 'execute']\n    can_write = 'write' in allowed\n    \n    items = ['a', 'b', 'c']\n    indexed = {i: item for i, item in enumerate(items)}\n    \n    keys = ['name', 'age', 'city']\n    values = ['Alice', 25, 'NYC']\n    paired = dict(zip(keys, values))\n    \n    nums = [1, 2, 3, 4, 5, 6]\n    pythonic = [x**2 for x in nums if x % 2 == 0]\n    \n    patterns = {\n        'swap': 'a, b = b, a',\n        'unpack': 'first, *rest = list',\n        'chain': '1 < x < 10',\n        'membership': 'x in list',\n        'enumerate': 'for i, x in enumerate(list)',\n        'zip': 'zip(list1, list2)',\n        'comprehension': '[x for x in list if ...]'\n    }\n    \n    return {\n        'swapped': swapped,\n        'assigned': assigned,\n        'unpacked': unpacked,\n        'chained': chained,\n        'can_write': can_write,\n        'indexed': indexed,\n        'paired': paired,\n        'pythonic': pythonic,\n        'patterns': patterns\n    }",
  "hints": [
    "Use set for membership testing - O(1) vs O(n)",
    "Use dict for lookups - O(1) vs O(n)",
    "Comprehensions for simple transforms, loops for complex logic",
    "Plural names for lists, singular in loops",
    "Iterate directly, use enumerate when you need index",
    "Never use mutable default arguments"
  ],
  "testCases": [
    {
      "id": "tc1",
      "description": "Set faster check",
      "input": "choosing_lists()['set_faster']",
      "expectedOutput": "True",
      "isHidden": false
    },
    {
      "id": "tc2",
      "description": "Good comprehension",
      "input": "comprehension_guidelines()['good_simple']",
      "expectedOutput": "[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]",
      "isHidden": false
    },
    {
      "id": "tc3",
      "description": "Active users",
      "input": "naming_conventions()['active_users']",
      "expectedOutput": "['alice', 'charlie']",
      "isHidden": false
    },
    {
      "id": "tc4",
      "description": "Iteration equal",
      "input": "iteration_best_practices()['results_equal']",
      "expectedOutput": "True",
      "isHidden": true
    },
    {
      "id": "tc5",
      "description": "Pitfall fixed",
      "input": "common_pitfalls()['pitfall1_fixed']",
      "expectedOutput": "[1, 3, 5]",
      "isHidden": true
    },
    {
      "id": "tc6",
      "description": "Pythonic swap",
      "input": "pythonic_patterns()['swapped']",
      "expectedOutput": "(2, 1)",
      "isHidden": true
    }
  ]
}