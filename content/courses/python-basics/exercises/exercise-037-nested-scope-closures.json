{
  "id": "exercise-037-nested-scope-closures",
  "lessonId": "lesson-023-nested-scope-closures",
  "title": "Nested Functions and Closure Creation",
  "description": "Master nested functions and closures. Learn how inner functions access enclosing scope variables.\n\nYour program should:\n1. Create nested functions (functions inside functions)\n2. Access enclosing scope variables from inner functions\n3. Use nonlocal keyword to modify enclosing variables\n4. Understand closure creation and behavior\n5. Build simple function factories\n6. Apply LEGB (Local, Enclosing, Global, Built-in) rule\n\nImplement these functions:\n- `outer_with_inner()`: Nested function demonstration\n- `make_adder(n)`: Function factory returning closure\n- `counter_closure()`: Closure with state using nonlocal\n- `enclosing_access()`: Access enclosing scope variable\n- `make_greeter(greeting)`: Create personalized greeter\n- `create_multiplier_pair(factor)`: Return multiple closures\n\nExample:\n```python\nadd_five = make_adder(5)\nprint(add_five(10))  # 15\n```",
  "difficulty": "intermediate",
  "points": 20,
  "language": "python",
  "starterCode": "def outer_with_inner():\n    \"\"\"Demonstrate nested function.\n    \n    Returns:\n        Result from calling inner function.\n    \"\"\"\n    # TODO: Create nested function and call it\n    # message = \"Hello from outer\"\n    # \n    # def inner():\n    #     return message  # Access enclosing variable\n    # \n    # return inner()\n    \n    pass\n\ndef make_adder(n):\n    \"\"\"Create function that adds n (closure).\n    \n    Args:\n        n: Value to add.\n    \n    Returns:\n        Function that adds n to its argument.\n    \"\"\"\n    # TODO: Return nested function (closure)\n    # def add(x):\n    #     return x + n  # n from enclosing scope\n    # return add\n    \n    pass\n\ndef counter_closure():\n    \"\"\"Create counter using closure with nonlocal.\n    \n    Returns:\n        Function that increments and returns count.\n    \"\"\"\n    # TODO: Use nonlocal to modify enclosing variable\n    # count = 0  # Enclosing scope\n    # \n    # def increment():\n    #     nonlocal count  # Modify enclosing count\n    #     count += 1\n    #     return count\n    # \n    # return increment\n    \n    pass\n\ndef enclosing_access():\n    \"\"\"Demonstrate accessing enclosing scope.\n    \n    Returns:\n        Dictionary with local and enclosing values.\n    \"\"\"\n    # TODO: Show LEGB rule\n    # outer_var = \"Enclosing\"\n    # \n    # def inner():\n    #     inner_var = \"Local\"\n    #     return {\n    #         'local': inner_var,\n    #         'enclosing': outer_var  # Access enclosing\n    #     }\n    # \n    # return inner()\n    \n    pass\n\ndef make_greeter(greeting):\n    \"\"\"Create personalized greeting function.\n    \n    Args:\n        greeting: Greeting phrase (e.g., 'Hello', 'Hi').\n    \n    Returns:\n        Function that greets with the phrase.\n    \"\"\"\n    # TODO: Return closure that remembers greeting\n    # def greet(name):\n    #     return f\"{greeting}, {name}!\"\n    # return greet\n    \n    pass\n\ndef create_multiplier_pair(factor):\n    \"\"\"Create two related closures.\n    \n    Args:\n        factor: Multiplication factor.\n    \n    Returns:\n        Tuple of (multiply_func, divide_func).\n    \"\"\"\n    # TODO: Return two closures sharing same factor\n    # def multiply(x):\n    #     return x * factor\n    # \n    # def divide(x):\n    #     return x / factor\n    # \n    # return multiply, divide\n    \n    pass\n\n# Test functions\nprint(\"Nested Functions:\")\nprint(\"=\"*60)\nresult = outer_with_inner()\nprint(f\"outer_with_inner(): {result}\")\nprint(\"Inner function accessed enclosing scope variable\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Closure - Function Factory:\")\nprint(\"=\"*60)\nadd_five = make_adder(5)\nadd_ten = make_adder(10)\n\nprint(\"add_five = make_adder(5)\")\nprint(f\"  add_five(10): {add_five(10)}\")\nprint(f\"  add_five(20): {add_five(20)}\")\n\nprint(\"\\nadd_ten = make_adder(10)\")\nprint(f\"  add_ten(10): {add_ten(10)}\")\nprint(f\"  add_ten(20): {add_ten(20)}\")\n\nprint(\"\\nEach closure remembers its own 'n' value!\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Closure with nonlocal (Stateful Function):\")\nprint(\"=\"*60)\ncounter = counter_closure()\nprint(\"counter = counter_closure()\")\nprint(f\"  counter(): {counter()}\")\nprint(f\"  counter(): {counter()}\")\nprint(f\"  counter(): {counter()}\")\nprint(\"Closure maintains state across calls!\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Enclosing Scope Access:\")\nprint(\"=\"*60)\nresult = enclosing_access()\nprint(f\"Result: {result}\")\nprint(\"Inner function accessed both local and enclosing scope\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Greeter Factory:\")\nprint(\"=\"*60)\nsay_hello = make_greeter(\"Hello\")\nsay_hi = make_greeter(\"Hi\")\nsay_hey = make_greeter(\"Hey\")\n\nprint(f\"say_hello('Alice'): {say_hello('Alice')}\")\nprint(f\"say_hi('Bob'): {say_hi('Bob')}\")\nprint(f\"say_hey('Charlie'): {say_hey('Charlie')}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Multiple Related Closures:\")\nprint(\"=\"*60)\nmultiply, divide = create_multiplier_pair(4)\n\nprint(\"multiply, divide = create_multiplier_pair(4)\")\nprint(f\"  multiply(20): {multiply(20)}\")\nprint(f\"  divide(20): {divide(20)}\")\n\nmultiply2, divide2 = create_multiplier_pair(10)\nprint(\"\\nmultiply2, divide2 = create_multiplier_pair(10)\")\nprint(f\"  multiply2(20): {multiply2(20)}\")\nprint(f\"  divide2(20): {divide2(20)}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Key Concepts:\")\nprint(\"=\"*60)\nprint(\"1. Nested function: Function defined inside another\")\nprint(\"2. Enclosing scope: Variables from outer function\")\nprint(\"3. Closure: Inner function remembers enclosing variables\")\nprint(\"4. nonlocal: Modify enclosing scope variables\")\nprint(\"5. LEGB rule: Local → Enclosing → Global → Built-in\")\nprint(\"6. Function factories: Functions that create functions\")\nprint(\"\\nClosures enable:\")\nprint(\"  - Data privacy (encapsulation)\")\nprint(\"  - Stateful functions\")\nprint(\"  - Function customization\")\nprint(\"  - Callback functions with context\")",
  "solution": "def outer_with_inner():\n    \"\"\"Demonstrate nested function.\"\"\"\n    message = \"Hello from outer\"\n    \n    def inner():\n        return message\n    \n    return inner()\n\ndef make_adder(n):\n    \"\"\"Create function that adds n (closure).\"\"\"\n    def add(x):\n        return x + n\n    return add\n\ndef counter_closure():\n    \"\"\"Create counter using closure with nonlocal.\"\"\"\n    count = 0\n    \n    def increment():\n        nonlocal count\n        count += 1\n        return count\n    \n    return increment\n\ndef enclosing_access():\n    \"\"\"Demonstrate accessing enclosing scope.\"\"\"\n    outer_var = \"Enclosing\"\n    \n    def inner():\n        inner_var = \"Local\"\n        return {\n            'local': inner_var,\n            'enclosing': outer_var\n        }\n    \n    return inner()\n\ndef make_greeter(greeting):\n    \"\"\"Create personalized greeting function.\"\"\"\n    def greet(name):\n        return f\"{greeting}, {name}!\"\n    return greet\n\ndef create_multiplier_pair(factor):\n    \"\"\"Create two related closures.\"\"\"\n    def multiply(x):\n        return x * factor\n    \n    def divide(x):\n        return x / factor\n    \n    return multiply, divide\n\n# Test code as provided",
  "hints": [
    "Nested function: Define function inside another function",
    "Closure: Inner function 'remembers' enclosing variables",
    "Access enclosing: Just use the variable name, no keyword needed",
    "Modify enclosing: Use 'nonlocal variable_name' before modifying",
    "Return function: Return the function object (no parentheses)",
    "Each closure instance has its own copy of enclosing variables"
  ],
  "testCases": [
    {
      "id": "tc1",
      "description": "Nested function access",
      "input": "outer_with_inner()",
      "expectedOutput": "'Hello from outer'",
      "isHidden": false
    },
    {
      "id": "tc2",
      "description": "Closure function factory",
      "input": "make_adder(10)(5)",
      "expectedOutput": "15",
      "isHidden": false
    },
    {
      "id": "tc3",
      "description": "Stateful closure with nonlocal",
      "input": "c = counter_closure(); c(); c()",
      "expectedOutput": "2",
      "isHidden": false
    },
    {
      "id": "tc4",
      "description": "Enclosing scope access",
      "input": "enclosing_access()['enclosing']",
      "expectedOutput": "'Enclosing'",
      "isHidden": true
    },
    {
      "id": "tc5",
      "description": "Greeter closure",
      "input": "make_greeter('Hello')('World')",
      "expectedOutput": "'Hello, World!'",
      "isHidden": true
    },
    {
      "id": "tc6",
      "description": "Multiple related closures",
      "input": "m, d = create_multiplier_pair(2); m(10) + d(10)",
      "expectedOutput": "25.0",
      "isHidden": true
    }
  ]
}