{
  "id": "exercise-115-variable-lifetime",
  "lessonId": "lesson-105-variable-lifetime",
  "title": "Variable Lifetime and Memory Management",
  "description": "Understand when variables are created and destroyed. Learn about Python's memory management and garbage collection.\n\nYour program should:\n1. Understand variable lifetime matching scope\n2. See how closure variables persist\n3. Learn about reference counting\n4. Understand garbage collection basics\n5. Know when objects are destroyed\n6. Manage object lifecycle\n\nImplement these functions:\n- `local_lifetime_demo()`: Show local variable lifecycle\n- `closure_lifetime_demo()`: Variables persist in closures\n- `multiple_references()`: Demonstrate reference counting\n- `scope_determines_lifetime()`: Lifetime matches scope\n- `closure_keeps_alive()`: Closure prevents destruction\n- `cleanup_demo()`: Show when variables are cleaned up\n\nExample:\n```python\nclosure_lifetime_demo()  # Variable persists\n```",
  "difficulty": "intermediate",
  "points": 20,
  "language": "python",
  "starterCode": "def local_lifetime_demo():\n    \"\"\"Demonstrate local variable lifetime.\n    \n    Returns:\n        String showing lifecycle.\n    \"\"\"\n    # TODO: Local variables created and destroyed\n    # x = \"Created\"  # x created\n    # result = f\"x exists: {x}\"\n    # # x destroyed when function returns\n    # return result\n    \n    pass\n\ndef closure_lifetime_demo():\n    \"\"\"Variables persist in closures.\n    \n    Returns:\n        Function that accesses persisted variable.\n    \"\"\"\n    # TODO: Closure variable persists\n    # data = \"Persisted in closure\"\n    # \n    # def access():\n    #     return data  # data still exists!\n    # \n    # return access\n    \n    pass\n\ndef multiple_references():\n    \"\"\"Demonstrate multiple references.\n    \n    Returns:\n        Dict showing reference behavior.\n    \"\"\"\n    # TODO: Multiple names referencing same object\n    # original = [1, 2, 3]\n    # reference = original  # Same object\n    # reference.append(4)\n    # return {\n    #     'original': original,  # Modified!\n    #     'reference': reference,\n    #     'same_object': original is reference\n    # }\n    \n    pass\n\ndef scope_determines_lifetime():\n    \"\"\"Lifetime matches scope.\n    \n    Returns:\n        Dict showing different lifetimes.\n    \"\"\"\n    # TODO: Different scopes, different lifetimes\n    # global_exists = \"Exists until program ends\"\n    # \n    # def inner():\n    #     local_exists = \"Exists until function returns\"\n    #     return local_exists\n    # \n    # return {\n    #     'global_lifetime': \"Until program ends\",\n    #     'local_lifetime': \"Until function returns\",\n    #     'closure_lifetime': \"Until closure destroyed\"\n    # }\n    \n    pass\n\ndef closure_keeps_alive():\n    \"\"\"Closure keeps variables alive.\n    \n    Returns:\n        Function accessing outer variable.\n    \"\"\"\n    # TODO: Variable lives as long as closure exists\n    # expensive_data = \"Kept alive by closure\"\n    # \n    # def access_data():\n    #     return expensive_data\n    # \n    # # expensive_data not destroyed\n    # # Lives as long as access_data exists\n    # return access_data\n    \n    pass\n\ndef cleanup_demo():\n    \"\"\"Show when variables are cleaned up.\n    \n    Returns:\n        String explaining cleanup.\n    \"\"\"\n    # TODO: Explain cleanup timing\n    # return (\n    #     \"Local variables: Destroyed at function end\\n\"\n    #     \"Global variables: Destroyed at program end\\n\"\n    #     \"Closure variables: Destroyed when closure destroyed\\n\"\n    #     \"Objects: Destroyed when reference count reaches 0\"\n    # )\n    \n    pass\n\n# Test functions\nprint(\"Variable Lifetime and Memory Management:\")\nprint(\"=\"*60)\n\nprint(\"\\nLocal Variable Lifetime:\")\nprint(\"-\"*60)\nresult = local_lifetime_demo()\nprint(f\"Inside function: {result}\")\nprint(\"After function returns: x no longer exists\")\nprint(\"Lifetime: Function call duration\")\n\nprint(\"\\nClosure Variable Lifetime:\")\nprint(\"-\"*60)\naccess_func = closure_lifetime_demo()\nprint(\"Closure created, outer function returned\")\nprint(f\"Calling closure: {access_func()}\")\nprint(f\"Calling again: {access_func()}\")\nprint(\"Variable 'data' still exists in closure!\")\nprint(\"Lifetime: As long as closure exists\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Multiple References (Same Object):\")\nprint(\"=\"*60)\nrefs = multiple_references()\nprint(f\"Original: {refs['original']}\")\nprint(f\"Reference: {refs['reference']}\")\nprint(f\"Same object: {refs['same_object']}\")\nprint(\"Both names point to same object in memory\")\nprint(\"Object destroyed when ALL references removed\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Scope Determines Lifetime:\")\nprint(\"=\"*60)\nlifetimes = scope_determines_lifetime()\nfor scope, lifetime in lifetimes.items():\n    print(f\"{scope}: {lifetime}\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Closure Keeps Variables Alive:\")\nprint(\"=\"*60)\nclosure_func = closure_keeps_alive()\nprint(\"Outer function returned, but...\")\nprint(f\"Data still accessible: {closure_func()}\")\nprint(\"Closure 'captures' and preserves outer variables\")\nprint(\"Variables live as long as closure exists\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Cleanup Explanation:\")\nprint(\"=\"*60)\nprint(cleanup_demo())\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Key Concepts:\")\nprint(\"=\"*60)\nprint(\"1. Lifetime: How long variable exists\")\nprint(\"2. Scope determines lifetime:\")\nprint(\"   - Local: Function duration\")\nprint(\"   - Global: Program duration\")\nprint(\"   - Closure: Closure object duration\")\nprint(\"3. Reference counting: Tracks object users\")\nprint(\"4. Garbage collection: Frees unused memory\")\nprint(\"5. Multiple references: Same object, multiple names\")\nprint(\"6. Cleanup: When reference count hits 0\")\nprint(\"\\nPractical implications:\")\nprint(\"  - Closures preserve variables\")\nprint(\"  - Be aware of memory usage\")\nprint(\"  - Circular references need special handling\")\nprint(\"  - Python manages memory automatically\")",
  "solution": "def local_lifetime_demo():\n    \"\"\"Demonstrate local variable lifetime.\"\"\"\n    x = \"Created\"\n    result = f\"x exists: {x}\"\n    return result\n\ndef closure_lifetime_demo():\n    \"\"\"Variables persist in closures.\"\"\"\n    data = \"Persisted in closure\"\n    \n    def access():\n        return data\n    \n    return access\n\ndef multiple_references():\n    \"\"\"Demonstrate multiple references.\"\"\"\n    original = [1, 2, 3]\n    reference = original\n    reference.append(4)\n    return {\n        'original': original,\n        'reference': reference,\n        'same_object': original is reference\n    }\n\ndef scope_determines_lifetime():\n    \"\"\"Lifetime matches scope.\"\"\"\n    global_exists = \"Exists until program ends\"\n    \n    def inner():\n        local_exists = \"Exists until function returns\"\n        return local_exists\n    \n    return {\n        'global_lifetime': \"Until program ends\",\n        'local_lifetime': \"Until function returns\",\n        'closure_lifetime': \"Until closure destroyed\"\n    }\n\ndef closure_keeps_alive():\n    \"\"\"Closure keeps variables alive.\"\"\"\n    expensive_data = \"Kept alive by closure\"\n    \n    def access_data():\n        return expensive_data\n    \n    return access_data\n\ndef cleanup_demo():\n    \"\"\"Show when variables are cleaned up.\"\"\"\n    return (\n        \"Local variables: Destroyed at function end\\n\"\n        \"Global variables: Destroyed at program end\\n\"\n        \"Closure variables: Destroyed when closure destroyed\\n\"\n        \"Objects: Destroyed when reference count reaches 0\"\n    )\n\n# Test code as provided",
  "hints": [
    "Lifetime: Duration variable exists in memory",
    "Local lifetime: Created at assignment, destroyed at function end",
    "Global lifetime: Exists until program terminates",
    "Closure lifetime: Persists as long as closure function exists",
    "Reference counting: Python tracks how many names reference object",
    "Cleanup: Automatic when reference count reaches zero"
  ],
  "testCases": [
    {
      "id": "tc1",
      "description": "Local lifetime",
      "input": "'Created' in local_lifetime_demo()",
      "expectedOutput": "True",
      "isHidden": false
    },
    {
      "id": "tc2",
      "description": "Closure persistence",
      "input": "'Persisted' in closure_lifetime_demo()()",
      "expectedOutput": "True",
      "isHidden": false
    },
    {
      "id": "tc3",
      "description": "Multiple references",
      "input": "multiple_references()['same_object']",
      "expectedOutput": "True",
      "isHidden": false
    },
    {
      "id": "tc4",
      "description": "Scope lifetime mapping",
      "input": "'closure_lifetime' in scope_determines_lifetime()",
      "expectedOutput": "True",
      "isHidden": true
    },
    {
      "id": "tc5",
      "description": "Closure keeps alive",
      "input": "'alive' in closure_keeps_alive()()",
      "expectedOutput": "True",
      "isHidden": true
    },
    {
      "id": "tc6",
      "description": "Cleanup explanation",
      "input": "'reference count' in cleanup_demo()",
      "expectedOutput": "True",
      "isHidden": true
    }
  ]
}