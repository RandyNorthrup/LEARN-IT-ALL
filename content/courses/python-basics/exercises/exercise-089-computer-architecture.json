{
  "id": "exercise-089-computer-architecture",
  "lessonId": "lesson-081-computer-architecture",
  "title": "Von Neumann Architecture Simulator",
  "description": "Create a Von Neumann architecture simulator that demonstrates how the five main components (CPU, Memory, Input, Output, Control) work together.\n\nYour simulator should:\n1. Model the five Von Neumann components\n2. Demonstrate the stored program concept\n3. Show data flow between components using a system bus\n4. Simulate loading a program from storage to memory and executing it\n\nImplement these classes:\n- `Memory`: Store instructions and data\n- `CPU`: Execute instructions with ALU and Control Unit\n- `InputDevice` and `OutputDevice`: Handle I/O\n- `VonNeumannComputer`: Integrate all components\n\nExample:\n```python\ncomputer = VonNeumannComputer()\nprogram = [\"LOAD 5\", \"LOAD 10\", \"ADD\", \"OUTPUT\"]\ncomputer.load_program(program)\ncomputer.run()\n# [MEMORY] Program loaded at address 0-3\n# [CONTROL] Fetching instruction from address 0\n# [CPU] Executing: LOAD 5\n# [ALU] Loaded value 5\n# ...\n# [OUTPUT] Result: 15\n```",
  "difficulty": "advanced",
  "points": 25,
  "language": "python",
  "starterCode": "class Memory:\n    \"\"\"Simulate computer memory (RAM).\"\"\"\n    \n    def __init__(self, size=256):\n        \"\"\"Initialize memory with given size.\"\"\"\n        # TODO: Create memory array (list) of given size\n        # Initialize all to None\n        self.memory = [None] * size\n        self.size = size\n    \n    def read(self, address):\n        \"\"\"Read value from memory address.\"\"\"\n        # TODO: Check if address is valid\n        \n        # TODO: Print read operation\n        \n        # TODO: Return value at address\n        \n        pass\n    \n    def write(self, address, value):\n        \"\"\"Write value to memory address.\"\"\"\n        # TODO: Check if address is valid\n        \n        # TODO: Write value to address\n        \n        # TODO: Print write operation\n        \n        pass\n\nclass CPU:\n    \"\"\"Simulate CPU with ALU and registers.\"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize CPU.\"\"\"\n        # TODO: Create accumulator register (stores results)\n        self.accumulator = 0\n        \n        # TODO: Create program counter (tracks current instruction)\n        self.program_counter = 0\n        \n        # TODO: Create instruction register (holds current instruction)\n        self.instruction_register = None\n    \n    def fetch(self, memory):\n        \"\"\"Fetch instruction from memory.\"\"\"\n        # TODO: Read instruction from memory at program_counter\n        \n        # TODO: Store in instruction_register\n        \n        # TODO: Increment program_counter\n        \n        # TODO: Print fetch operation\n        \n        pass\n    \n    def execute(self, instruction):\n        \"\"\"Execute instruction.\"\"\"\n        # TODO: Parse instruction (split by space)\n        \n        # TODO: Handle different instructions:\n        # LOAD value: Load value into accumulator\n        # ADD value: Add value to accumulator\n        # SUB value: Subtract value from accumulator\n        # OUTPUT: Return accumulator value for output\n        \n        # TODO: Print execution\n        \n        pass\n\nclass InputDevice:\n    \"\"\"Simulate input device.\"\"\"\n    \n    def __init__(self, data):\n        \"\"\"Initialize with input data.\"\"\"\n        self.data = data\n    \n    def read(self):\n        \"\"\"Read input data.\"\"\"\n        print(f\"[INPUT] Reading data: {self.data}\")\n        return self.data\n\nclass OutputDevice:\n    \"\"\"Simulate output device.\"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize output device.\"\"\"\n        self.output = []\n    \n    def write(self, value):\n        \"\"\"Write value to output.\"\"\"\n        self.output.append(value)\n        print(f\"[OUTPUT] {value}\")\n\nclass VonNeumannComputer:\n    \"\"\"Complete Von Neumann architecture computer.\"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize all components.\"\"\"\n        # TODO: Create Memory, CPU, and Output devices\n        self.memory = Memory(256)\n        self.cpu = CPU()\n        self.output = OutputDevice()\n    \n    def load_program(self, program):\n        \"\"\"Load program into memory.\"\"\"\n        # TODO: Write each instruction to memory starting at address 0\n        \n        # TODO: Print load message\n        \n        pass\n    \n    def run(self):\n        \"\"\"Execute loaded program.\"\"\"\n        # TODO: Print start message\n        print(\"\\n[COMPUTER] Starting program execution\")\n        print(\"=\" * 60)\n        \n        # TODO: Loop until program completes\n        # Fetch instruction, execute it\n        # Handle OUTPUT instruction specially\n        # Stop when program_counter exceeds program length\n        \n        pass\n\n# Test the Von Neumann computer\nprint(\"Von Neumann Architecture Simulator\")\nprint(\"=\" * 60)\n\ncomputer = VonNeumannComputer()\n\nprint(\"\\n1. Simple Addition Program:\")\nprint(\"-\" * 60)\nprogram1 = [\n    \"LOAD 10\",\n    \"ADD 20\",\n    \"ADD 5\",\n    \"OUTPUT\"\n]\ncomputer.load_program(program1)\ncomputer.run()\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"2. Calculation Program:\")\nprint(\"-\" * 60)\ncomputer2 = VonNeumannComputer()\nprogram2 = [\n    \"LOAD 100\",\n    \"SUB 25\",\n    \"ADD 10\",\n    \"SUB 5\",\n    \"OUTPUT\"\n]\ncomputer2.load_program(program2)\ncomputer2.run()\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"Von Neumann Architecture Components:\")\nprint(\"-\" * 60)\nprint(\"\"\"\n1. CPU (Central Processing Unit)\n   - Control Unit: Directs operations\n   - ALU: Performs calculations\n   - Registers: Fast temporary storage\n\n2. Memory (RAM)\n   - Stores both instructions and data\n   - Sequential addresses\n\n3. Input Devices\n   - Keyboard, mouse, sensors\n\n4. Output Devices\n   - Screen, printer, speakers\n\n5. System Bus\n   - Connects all components\n   - Carries data, addresses, control signals\n\"\"\")",
  "solution": "class Memory:\n    \"\"\"Simulate computer memory (RAM).\"\"\"\n    \n    def __init__(self, size=256):\n        \"\"\"Initialize memory with given size.\"\"\"\n        self.memory = [None] * size\n        self.size = size\n    \n    def read(self, address):\n        \"\"\"Read value from memory address.\"\"\"\n        if address < 0 or address >= self.size:\n            raise ValueError(f\"Invalid memory address: {address}\")\n        \n        value = self.memory[address]\n        print(f\"[MEMORY] Read from address {address}: {value}\")\n        return value\n    \n    def write(self, address, value):\n        \"\"\"Write value to memory address.\"\"\"\n        if address < 0 or address >= self.size:\n            raise ValueError(f\"Invalid memory address: {address}\")\n        \n        self.memory[address] = value\n        print(f\"[MEMORY] Write to address {address}: {value}\")\n\nclass CPU:\n    \"\"\"Simulate CPU with ALU and registers.\"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize CPU.\"\"\"\n        self.accumulator = 0\n        self.program_counter = 0\n        self.instruction_register = None\n    \n    def fetch(self, memory):\n        \"\"\"Fetch instruction from memory.\"\"\"\n        self.instruction_register = memory.read(self.program_counter)\n        print(f\"[CONTROL] Fetched instruction from address {self.program_counter}\")\n        self.program_counter += 1\n        return self.instruction_register\n    \n    def execute(self, instruction):\n        \"\"\"Execute instruction.\"\"\"\n        if instruction is None:\n            return None\n        \n        parts = instruction.split()\n        operation = parts[0]\n        \n        print(f\"[CPU] Executing: {instruction}\")\n        \n        if operation == \"LOAD\":\n            value = int(parts[1])\n            self.accumulator = value\n            print(f\"[ALU] Loaded value {value} into accumulator\")\n        \n        elif operation == \"ADD\":\n            value = int(parts[1])\n            self.accumulator += value\n            print(f\"[ALU] Added {value}, accumulator now = {self.accumulator}\")\n        \n        elif operation == \"SUB\":\n            value = int(parts[1])\n            self.accumulator -= value\n            print(f\"[ALU] Subtracted {value}, accumulator now = {self.accumulator}\")\n        \n        elif operation == \"OUTPUT\":\n            print(f\"[ALU] Output accumulator value: {self.accumulator}\")\n            return ('OUTPUT', self.accumulator)\n        \n        return None\n\nclass InputDevice:\n    \"\"\"Simulate input device.\"\"\"\n    \n    def __init__(self, data):\n        \"\"\"Initialize with input data.\"\"\"\n        self.data = data\n    \n    def read(self):\n        \"\"\"Read input data.\"\"\"\n        print(f\"[INPUT] Reading data: {self.data}\")\n        return self.data\n\nclass OutputDevice:\n    \"\"\"Simulate output device.\"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize output device.\"\"\"\n        self.output = []\n    \n    def write(self, value):\n        \"\"\"Write value to output.\"\"\"\n        self.output.append(value)\n        print(f\"[OUTPUT] {value}\")\n\nclass VonNeumannComputer:\n    \"\"\"Complete Von Neumann architecture computer.\"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize all components.\"\"\"\n        self.memory = Memory(256)\n        self.cpu = CPU()\n        self.output = OutputDevice()\n    \n    def load_program(self, program):\n        \"\"\"Load program into memory.\"\"\"\n        for i, instruction in enumerate(program):\n            self.memory.write(i, instruction)\n        \n        print(f\"\\n[MEMORY] Program loaded: {len(program)} instructions (address 0-{len(program)-1})\")\n    \n    def run(self):\n        \"\"\"Execute loaded program.\"\"\"\n        print(\"\\n[COMPUTER] Starting program execution\")\n        print(\"=\" * 60)\n        \n        while True:\n            # Check if program counter is within program bounds\n            if self.memory.memory[self.cpu.program_counter] is None:\n                break\n            \n            # Fetch instruction\n            instruction = self.cpu.fetch(self.memory)\n            print()\n            \n            # Execute instruction\n            result = self.cpu.execute(instruction)\n            \n            # Handle output\n            if result and result[0] == 'OUTPUT':\n                self.output.write(result[1])\n            \n            print()\n        \n        print(\"[COMPUTER] Program execution completed\")\n\n# Test the Von Neumann computer\nprint(\"Von Neumann Architecture Simulator\")\nprint(\"=\" * 60)\n\ncomputer = VonNeumannComputer()\n\nprint(\"\\n1. Simple Addition Program:\")\nprint(\"-\" * 60)\nprogram1 = [\n    \"LOAD 10\",\n    \"ADD 20\",\n    \"ADD 5\",\n    \"OUTPUT\"\n]\ncomputer.load_program(program1)\ncomputer.run()\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"2. Calculation Program:\")\nprint(\"-\" * 60)\ncomputer2 = VonNeumannComputer()\nprogram2 = [\n    \"LOAD 100\",\n    \"SUB 25\",\n    \"ADD 10\",\n    \"SUB 5\",\n    \"OUTPUT\"\n]\ncomputer2.load_program(program2)\ncomputer2.run()\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"Von Neumann Architecture Components:\")\nprint(\"-\" * 60)\nprint(\"\"\"\n1. CPU (Central Processing Unit)\n   - Control Unit: Directs operations\n   - ALU: Performs calculations\n   - Registers: Fast temporary storage\n\n2. Memory (RAM)\n   - Stores both instructions and data\n   - Sequential addresses\n\n3. Input Devices\n   - Keyboard, mouse, sensors\n\n4. Output Devices\n   - Screen, printer, speakers\n\n5. System Bus\n   - Connects all components\n   - Carries data, addresses, control signals\n\"\"\")",
  "hints": [
    "Initialize Memory as a list: self.memory = [None] * size",
    "In CPU, use accumulator to store results, program_counter to track current instruction address",
    "For fetch(), read from memory at program_counter, then increment program_counter",
    "For execute(), use instruction.split() to parse operation and operands",
    "In VonNeumannComputer.run(), loop while memory[program_counter] is not None",
    "Handle OUTPUT instruction by returning a tuple ('OUTPUT', value) so run() can write to output device"
  ],
  "testCases": [
    {
      "id": "tc1",
      "description": "Memory stores and retrieves values correctly",
      "input": "m = Memory(); m.write(0, 'TEST'); print(m.read(0))",
      "expectedOutput": "'TEST'",
      "isHidden": false
    },
    {
      "id": "tc2",
      "description": "CPU accumulator loads value correctly",
      "input": "cpu = CPU(); cpu.execute('LOAD 42'); print(cpu.accumulator)",
      "expectedOutput": "42",
      "isHidden": false
    },
    {
      "id": "tc3",
      "description": "CPU adds to accumulator correctly",
      "input": "cpu = CPU(); cpu.accumulator = 10; cpu.execute('ADD 5'); print(cpu.accumulator)",
      "expectedOutput": "15",
      "isHidden": false
    },
    {
      "id": "tc4",
      "description": "CPU subtracts from accumulator correctly",
      "input": "cpu = CPU(); cpu.accumulator = 20; cpu.execute('SUB 8'); print(cpu.accumulator)",
      "expectedOutput": "12",
      "isHidden": true
    },
    {
      "id": "tc5",
      "description": "Computer executes program sequence correctly",
      "input": "c = VonNeumannComputer(); c.load_program(['LOAD 5', 'ADD 3', 'OUTPUT']); c.run(); print(c.cpu.accumulator)",
      "expectedOutput": "8",
      "isHidden": true
    }
  ]
}