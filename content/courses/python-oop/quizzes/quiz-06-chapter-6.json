{
  "id": "quiz-06-chapter-6",
  "courseId": "python-oop",
  "chapterId": "ch6-polymorphism",
  "title": "Chapter 6: Polymorphism - Quiz",
  "description": "Comprehensive test of polymorphism, duck typing, operator overloading, design patterns, and SOLID principles",
  "passingScore": 75,
  "timeLimit": 3600,
  "questions": [
    {
      "id": "q1",
      "question": "What is polymorphism in OOP?",
      "type": "multiple-choice",
      "points": 10,
      "options": [
        {"id": "a", "text": "Many forms - same interface, different implementations"},
        {"id": "b", "text": "Hiding implementation"},
        {"id": "c", "text": "Inheriting from parent"},
        {"id": "d", "text": "Bundling data"}
      ],
      "correctAnswer": "a",
      "explanation": "Polymorphism means 'many forms' - same interface with different implementations."
    },
    {
      "id": "q2",
      "question": "What is duck typing?",
      "type": "multiple-choice",
      "points": 10,
      "options": [
        {"id": "a", "text": "Type checking ducks"},
        {"id": "b", "text": "If it walks/quacks like duck, it's a duck"},
        {"id": "c", "text": "Strong typing"},
        {"id": "d", "text": "Static typing"}
      ],
      "correctAnswer": "b",
      "explanation": "Duck typing: focus on object's behavior (methods), not explicit type."
    },
    {
      "id": "q3",
      "question": "What does __add__ magic method define?",
      "type": "multiple-choice",
      "points": 10,
      "options": [
        {"id": "a", "text": "Subtraction -"},
        {"id": "b", "text": "Addition +"},
        {"id": "c", "text": "Multiplication *"},
        {"id": "d", "text": "Division /"}
      ],
      "correctAnswer": "b",
      "explanation": "__add__ defines behavior of the + operator."
    },
    {
      "id": "q4",
      "question": "What is operator overloading?",
      "type": "multiple-choice",
      "points": 10,
      "options": [
        {"id": "a", "text": "Using too many operators"},
        {"id": "b", "text": "Defining custom behavior for operators"},
        {"id": "c", "text": "Deleting operators"},
        {"id": "d", "text": "Operator errors"}
      ],
      "correctAnswer": "b",
      "explanation": "Operator overloading lets you define how operators work with custom classes."
    },
    {
      "id": "q5",
      "question": "What does __mul__ define?",
      "type": "multiple-choice",
      "points": 10,
      "options": [
        {"id": "a", "text": "Addition"},
        {"id": "b", "text": "Subtraction"},
        {"id": "c", "text": "Multiplication *"},
        {"id": "d", "text": "Division"}
      ],
      "correctAnswer": "c",
      "explanation": "__mul__ defines multiplication operator * behavior."
    },
    {
      "id": "q6",
      "question": "What does __lt__ define?",
      "type": "multiple-choice",
      "points": 10,
      "options": [
        {"id": "a", "text": "Less than <"},
        {"id": "b", "text": "Greater than >"},
        {"id": "c", "text": "Equal to =="},
        {"id": "d", "text": "Not equal !="}
      ],
      "correctAnswer": "a",
      "explanation": "__lt__ defines less than < comparison operator."
    },
    {
      "id": "q7",
      "question": "What does 'S' in SOLID stand for?",
      "type": "multiple-choice",
      "points": 10,
      "options": [
        {"id": "a", "text": "Single Responsibility Principle"},
        {"id": "b", "text": "Simple Principle"},
        {"id": "c", "text": "Secure Principle"},
        {"id": "d", "text": "Standard Principle"}
      ],
      "correctAnswer": "a",
      "explanation": "S = Single Responsibility Principle - class should have one reason to change."
    },
    {
      "id": "q8",
      "question": "What does 'O' in SOLID stand for?",
      "type": "multiple-choice",
      "points": 10,
      "options": [
        {"id": "a", "text": "Object Principle"},
        {"id": "b", "text": "Open/Closed Principle"},
        {"id": "c", "text": "Operator Principle"},
        {"id": "d", "text": "Optimization Principle"}
      ],
      "correctAnswer": "b",
      "explanation": "O = Open/Closed Principle - open for extension, closed for modification."
    },
    {
      "id": "q9",
      "question": "What does 'L' in SOLID stand for?",
      "type": "multiple-choice",
      "points": 10,
      "options": [
        {"id": "a", "text": "Loop Principle"},
        {"id": "b", "text": "Liskov Substitution Principle"},
        {"id": "c", "text": "Logic Principle"},
        {"id": "d", "text": "Library Principle"}
      ],
      "correctAnswer": "b",
      "explanation": "L = Liskov Substitution Principle - subtypes must be substitutable for base types."
    },
    {
      "id": "q10",
      "question": "What does 'I' in SOLID stand for?",
      "type": "multiple-choice",
      "points": 10,
      "options": [
        {"id": "a", "text": "Interface Segregation Principle"},
        {"id": "b", "text": "Instance Principle"},
        {"id": "c", "text": "Iteration Principle"},
        {"id": "d", "text": "Import Principle"}
      ],
      "correctAnswer": "a",
      "explanation": "I = Interface Segregation - clients shouldn't depend on interfaces they don't use."
    },
    {
      "id": "q11",
      "question": "What does 'D' in SOLID stand for?",
      "type": "multiple-choice",
      "points": 10,
      "options": [
        {"id": "a", "text": "Data Principle"},
        {"id": "b", "text": "Dependency Inversion Principle"},
        {"id": "c", "text": "Design Principle"},
        {"id": "d", "text": "Delete Principle"}
      ],
      "correctAnswer": "b",
      "explanation": "D = Dependency Inversion - depend on abstractions, not concretions."
    },
    {
      "id": "q12",
      "question": "What is the Strategy pattern?",
      "type": "multiple-choice",
      "points": 10,
      "options": [
        {"id": "a", "text": "Game strategy"},
        {"id": "b", "text": "Define family of algorithms, make them interchangeable"},
        {"id": "c", "text": "Military tactics"},
        {"id": "d", "text": "Database strategy"}
      ],
      "correctAnswer": "b",
      "explanation": "Strategy pattern defines family of algorithms and makes them interchangeable."
    },
    {
      "id": "q13",
      "question": "What is the Factory pattern?",
      "type": "multiple-choice",
      "points": 10,
      "options": [
        {"id": "a", "text": "Creating factories"},
        {"id": "b", "text": "Method for creating objects without specifying exact class"},
        {"id": "c", "text": "Manufacturing pattern"},
        {"id": "d", "text": "Building factories"}
      ],
      "correctAnswer": "b",
      "explanation": "Factory pattern creates objects without specifying exact class to instantiate."
    },
    {
      "id": "q14",
      "question": "What is the Observer pattern?",
      "type": "multiple-choice",
      "points": 10,
      "options": [
        {"id": "a", "text": "Watching objects"},
        {"id": "b", "text": "Define one-to-many dependency"},
        {"id": "c", "text": "Security pattern"},
        {"id": "d", "text": "Debugging pattern"}
      ],
      "correctAnswer": "b",
      "explanation": "Observer pattern defines one-to-many dependency - when one changes, dependents notified."
    },
    {
      "id": "q15",
      "question": "What is method overriding related to?",
      "type": "multiple-choice",
      "points": 10,
      "options": [
        {"id": "a", "text": "Compile-time polymorphism"},
        {"id": "b", "text": "Runtime polymorphism"},
        {"id": "c", "text": "Static polymorphism"},
        {"id": "d", "text": "No polymorphism"}
      ],
      "correctAnswer": "b",
      "explanation": "Method overriding is runtime polymorphism - decision made at runtime."
    },
    {
      "id": "q16",
      "question": "What does __getitem__ enable?",
      "type": "multiple-choice",
      "points": 10,
      "options": [
        {"id": "a", "text": "Getting all items"},
        {"id": "b", "text": "Index access with []"},
        {"id": "c", "text": "Getting item count"},
        {"id": "d", "text": "Deleting items"}
      ],
      "correctAnswer": "b",
      "explanation": "__getitem__ enables indexing/subscript notation obj[key]."
    },
    {
      "id": "q17",
      "question": "What does __setitem__ enable?",
      "type": "multiple-choice",
      "points": 10,
      "options": [
        {"id": "a", "text": "Setting all items"},
        {"id": "b", "text": "Assignment with [] notation"},
        {"id": "c", "text": "Creating items"},
        {"id": "d", "text": "Counting items"}
      ],
      "correctAnswer": "b",
      "explanation": "__setitem__ enables assignment using subscript notation obj[key] = value."
    },
    {
      "id": "q18",
      "question": "What is the Singleton pattern?",
      "type": "multiple-choice",
      "points": 10,
      "options": [
        {"id": "a", "text": "Single line of code"},
        {"id": "b", "text": "Ensure class has only one instance"},
        {"id": "c", "text": "Single method"},
        {"id": "d", "text": "Single variable"}
      ],
      "correctAnswer": "b",
      "explanation": "Singleton ensures a class has only one instance with global access point."
    },
    {
      "id": "q19",
      "question": "What does __iter__ enable?",
      "type": "multiple-choice",
      "points": 10,
      "options": [
        {"id": "a", "text": "Iteration with for loop"},
        {"id": "b", "text": "Counting"},
        {"id": "c", "text": "Deletion"},
        {"id": "d", "text": "Creation"}
      ],
      "correctAnswer": "a",
      "explanation": "__iter__ makes object iterable - can be used in for loops."
    },
    {
      "id": "q20",
      "question": "What does __next__ do?",
      "type": "multiple-choice",
      "points": 10,
      "options": [
        {"id": "a", "text": "Gets next item in iteration"},
        {"id": "b", "text": "Skips item"},
        {"id": "c", "text": "Deletes item"},
        {"id": "d", "text": "Counts items"}
      ],
      "correctAnswer": "a",
      "explanation": "__next__ returns next item in iteration, raises StopIteration when done."
    },
    {
      "id": "q21",
      "question": "Polymorphism allows same interface with different implementations.",
      "type": "true-false",
      "points": 10,
      "correctAnswer": true,
      "explanation": "Polymorphism enables same interface to work with different underlying implementations."
    },
    {
      "id": "q22",
      "question": "Duck typing requires explicit type declarations.",
      "type": "true-false",
      "points": 10,
      "correctAnswer": false,
      "explanation": "Duck typing focuses on behavior, not explicit type declarations."
    },
    {
      "id": "q23",
      "question": "Operator overloading uses magic methods.",
      "type": "true-false",
      "points": 10,
      "correctAnswer": true,
      "explanation": "Operator overloading is implemented using magic methods like __add__, __mul__, etc."
    },
    {
      "id": "q24",
      "question": "SOLID principles improve code maintainability.",
      "type": "true-false",
      "points": 10,
      "correctAnswer": true,
      "explanation": "SOLID principles lead to more maintainable, flexible, and robust code."
    },
    {
      "id": "q25",
      "question": "Single Responsibility means one method per class.",
      "type": "true-false",
      "points": 10,
      "correctAnswer": false,
      "explanation": "Single Responsibility means one reason to change, not one method."
    },
    {
      "id": "q26",
      "question": "Open/Closed means open for extension, closed for modification.",
      "type": "true-false",
      "points": 10,
      "correctAnswer": true,
      "explanation": "Open/Closed: software entities should be open for extension but closed for modification."
    },
    {
      "id": "q27",
      "question": "Design patterns are language-specific solutions.",
      "type": "true-false",
      "points": 10,
      "correctAnswer": false,
      "explanation": "Design patterns are general reusable solutions applicable across languages."
    },
    {
      "id": "q28",
      "question": "Strategy pattern enables runtime algorithm selection.",
      "type": "true-false",
      "points": 10,
      "correctAnswer": true,
      "explanation": "Strategy pattern allows selecting algorithm at runtime."
    },
    {
      "id": "q29",
      "question": "Factory pattern hides object creation complexity.",
      "type": "true-false",
      "points": 10,
      "correctAnswer": true,
      "explanation": "Factory pattern encapsulates object creation logic."
    },
    {
      "id": "q30",
      "question": "Liskov Substitution means subtypes must be substitutable for base types.",
      "type": "true-false",
      "points": 10,
      "correctAnswer": true,
      "explanation": "Liskov Substitution: objects of subclass should replace objects of superclass without breaking."
    },
    {
      "id": "q31",
      "question": "Arithmetic operator magic methods? (Select all)",
      "type": "multiple-select",
      "points": 15,
      "options": [
        {"id": "a", "text": "__add__ (+)"},
        {"id": "b", "text": "__sub__ (-)"},
        {"id": "c", "text": "__mul__ (*)"},
        {"id": "d", "text": "__delete__"}
      ],
      "correctAnswers": ["a", "b", "c"],
      "explanation": "__add__, __sub__, __mul__ are arithmetic operators. __delete__ doesn't exist."
    },
    {
      "id": "q32",
      "question": "Comparison magic methods? (Select all)",
      "type": "multiple-select",
      "points": 15,
      "options": [
        {"id": "a", "text": "__eq__ (==)"},
        {"id": "b", "text": "__lt__ (<)"},
        {"id": "c", "text": "__gt__ (>)"},
        {"id": "d", "text": "__compare__"}
      ],
      "correctAnswers": ["a", "b", "c"],
      "explanation": "__eq__, __lt__, __gt__ are comparison operators. __compare__ doesn't exist."
    },
    {
      "id": "q33",
      "question": "SOLID principles? (Select all)",
      "type": "multiple-select",
      "points": 15,
      "options": [
        {"id": "a", "text": "Single Responsibility"},
        {"id": "b", "text": "Open/Closed"},
        {"id": "c", "text": "Liskov Substitution"},
        {"id": "d", "text": "Multiple Inheritance"}
      ],
      "correctAnswers": ["a", "b", "c"],
      "explanation": "S, O, L are SOLID principles. Multiple Inheritance is not."
    },
    {
      "id": "q34",
      "question": "Design patterns covered? (Select all)",
      "type": "multiple-select",
      "points": 15,
      "options": [
        {"id": "a", "text": "Strategy"},
        {"id": "b", "text": "Factory"},
        {"id": "c", "text": "Observer"},
        {"id": "d", "text": "Destructor"}
      ],
      "correctAnswers": ["a", "b", "c"],
      "explanation": "Strategy, Factory, Observer are design patterns. Destructor is not a pattern."
    },
    {
      "id": "q35",
      "question": "Benefits of polymorphism? (Select all)",
      "type": "multiple-select",
      "points": 15,
      "options": [
        {"id": "a", "text": "Flexibility"},
        {"id": "b", "text": "Code reuse"},
        {"id": "c", "text": "Extensibility"},
        {"id": "d", "text": "Automatic optimization"}
      ],
      "correctAnswers": ["a", "b", "c"],
      "explanation": "Polymorphism provides flexibility, reuse, extensibility - not automatic optimization."
    },
    {
      "id": "q36",
      "question": "Complete: Define addition operator",
      "type": "code-completion",
      "points": 15,
      "starterCode": "class Number:\n    ____\n    def ____(self, other):\n        return Number(self.value + other.value)",
      "correctAnswer": "def __add__(self, other):",
      "acceptableAnswers": ["__add__", "def __add__(self, other):"],
      "explanation": "Use __add__ to define + operator behavior.",
      "language": "python"
    },
    {
      "id": "q37",
      "question": "Complete: Define less than operator",
      "type": "code-completion",
      "points": 15,
      "starterCode": "class Number:\n    def ____(self, other):\n        return self.value < other.value",
      "correctAnswer": "def __lt__(self, other):",
      "acceptableAnswers": ["__lt__", "def __lt__(self, other):"],
      "explanation": "Use __lt__ to define < comparison operator.",
      "language": "python"
    },
    {
      "id": "q38",
      "question": "Complete: Make object iterable",
      "type": "code-completion",
      "points": 15,
      "starterCode": "class MyRange:\n    def ____(self):\n        return self",
      "correctAnswer": "def __iter__(self):",
      "acceptableAnswers": ["__iter__", "def __iter__(self):"],
      "explanation": "Use __iter__ to make object iterable.",
      "language": "python"
    },
    {
      "id": "q39",
      "question": "Complete: Enable indexing",
      "type": "code-completion",
      "points": 15,
      "starterCode": "class MyList:\n    def ____(self, index):\n        return self.items[index]",
      "correctAnswer": "def __getitem__(self, index):",
      "acceptableAnswers": ["__getitem__", "def __getitem__(self, index):"],
      "explanation": "Use __getitem__ to enable indexing with [].",
      "language": "python"
    },
    {
      "id": "q40",
      "question": "Complete: Polymorphic method",
      "type": "code-completion",
      "points": 15,
      "starterCode": "def process(animal):\n    # Use duck typing - call speak regardless of type\n    return ____.____",
      "correctAnswer": "return animal.speak()",
      "acceptableAnswers": ["animal.speak()", "animal.speak"],
      "explanation": "Duck typing: call method based on behavior, not type.",
      "language": "python"
    },
    {
      "id": "q41",
      "question": "Operator Overloading",
      "type": "coding-exercise",
      "points": 20,
      "description": "Create Vector class with __add__ and __mul__ for vector operations.",
      "starterCode": "class Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    # Add __add__ for addition\n    \n    # Add __mul__ for scalar multiplication\n",
      "language": "python",
      "testCases": [
        {
          "id": "t1",
          "description": "Vector addition and multiplication",
          "expectedOutput": "7 10",
          "isHidden": false
        }
      ],
      "hints": ["def __add__(self, other):", "return Vector(self.x + other.x, self.y + other.y)", "def __mul__(self, scalar):"]
    },
    {
      "id": "q42",
      "question": "Duck Typing",
      "type": "coding-exercise",
      "points": 20,
      "description": "Create function that accepts any object with speak() method (duck typing).",
      "starterCode": "# Create make_sound function using duck typing\n\n# Test with different classes having speak()\n",
      "language": "python",
      "testCases": [
        {
          "id": "t1",
          "description": "Works with any object having speak",
          "expectedOutput": "Woof! Meow!",
          "isHidden": false
        }
      ],
      "hints": ["def make_sound(animal):", "return animal.speak()", "No type checking needed"]
    },
    {
      "id": "q43",
      "question": "Strategy Pattern",
      "type": "coding-exercise",
      "points": 20,
      "description": "Implement Strategy pattern with different sorting strategies.",
      "starterCode": "# Create strategy interface\n# Create concrete strategies\n# Create context that uses strategies\n",
      "language": "python",
      "testCases": [
        {
          "id": "t1",
          "description": "Different strategies work",
          "expectedOutput": "Ascending Descending",
          "isHidden": false
        }
      ],
      "hints": ["Abstract strategy class", "AscendingSort, DescendingSort", "Context with set_strategy()"]
    },
    {
      "id": "q44",
      "question": "Factory Pattern",
      "type": "coding-exercise",
      "points": 20,
      "description": "Create factory that creates different shape objects based on type.",
      "starterCode": "# Create shape classes\n# Create ShapeFactory with create_shape method\n",
      "language": "python",
      "testCases": [
        {
          "id": "t1",
          "description": "Factory creates different shapes",
          "expectedOutput": "Circle Square",
          "isHidden": false
        }
      ],
      "hints": ["class Circle, Square", "class ShapeFactory:", "def create_shape(self, shape_type):"]
    },
    {
      "id": "q45",
      "question": "Implement Iterator",
      "type": "coding-exercise",
      "points": 20,
      "description": "Create custom iterator class with __iter__ and __next__.",
      "starterCode": "class CountDown:\n    def __init__(self, start):\n        self.current = start\n    \n    # Add __iter__\n    \n    # Add __next__ with StopIteration\n",
      "language": "python",
      "testCases": [
        {
          "id": "t1",
          "description": "Iterator counts down",
          "expectedOutput": "5 4 3 2 1",
          "isHidden": false
        }
      ],
      "hints": ["def __iter__(self): return self", "def __next__(self):", "raise StopIteration"]
    },
    {
      "id": "q46",
      "question": "Polymorphism Basics - Multi-Part",
      "type": "multi-part",
      "points": 20,
      "parts": [
        {
          "id": "q46a",
          "type": "multiple-choice",
          "question": "What is polymorphism?",
          "points": 7,
          "options": [
            {"id": "a", "text": "Many forms"},
            {"id": "b", "text": "One form"},
            {"id": "c", "text": "No forms"},
            {"id": "d", "text": "Two forms"}
          ],
          "correctAnswer": "a",
          "explanation": "Polymorphism means 'many forms'."
        },
        {
          "id": "q46b",
          "type": "true-false",
          "question": "Polymorphism enables code flexibility",
          "points": 7,
          "correctAnswer": true,
          "explanation": "Polymorphism provides flexibility through common interfaces."
        },
        {
          "id": "q46c",
          "type": "multiple-select",
          "question": "Types of polymorphism? (Select all)",
          "points": 6,
          "options": [
            {"id": "a", "text": "Compile-time"},
            {"id": "b", "text": "Runtime"},
            {"id": "c", "text": "Duck typing"},
            {"id": "d", "text": "Static only"}
          ],
          "correctAnswers": ["a", "b", "c"],
          "explanation": "Compile-time, runtime, and duck typing are valid forms."
        }
      ]
    },
    {
      "id": "q47",
      "question": "Operator Overloading - Multi-Part",
      "type": "multi-part",
      "points": 20,
      "parts": [
        {
          "id": "q47a",
          "type": "code-completion",
          "question": "Addition operator",
          "points": 7,
          "starterCode": "def ____(self, other):\n    pass",
          "correctAnswer": "def __add__(self, other):",
          "acceptableAnswers": ["__add__", "def __add__(self, other):"],
          "explanation": "Use __add__ for + operator.",
          "language": "python"
        },
        {
          "id": "q47b",
          "type": "code-completion",
          "question": "Multiplication operator",
          "points": 7,
          "starterCode": "def ____(self, other):\n    pass",
          "correctAnswer": "def __mul__(self, other):",
          "acceptableAnswers": ["__mul__", "def __mul__(self, other):"],
          "explanation": "Use __mul__ for * operator.",
          "language": "python"
        },
        {
          "id": "q47c",
          "type": "true-false",
          "question": "Operator overloading uses magic methods",
          "points": 6,
          "correctAnswer": true,
          "explanation": "Operator overloading implemented via magic methods."
        }
      ]
    },
    {
      "id": "q48",
      "question": "SOLID Principles - Multi-Part",
      "type": "multi-part",
      "points": 20,
      "parts": [
        {
          "id": "q48a",
          "type": "multiple-choice",
          "question": "What is Single Responsibility?",
          "points": 7,
          "options": [
            {"id": "a", "text": "One reason to change"},
            {"id": "b", "text": "One method"},
            {"id": "c", "text": "One attribute"},
            {"id": "d", "text": "One line"}
          ],
          "correctAnswer": "a",
          "explanation": "Single Responsibility: class has one reason to change."
        },
        {
          "id": "q48b",
          "type": "true-false",
          "question": "Open/Closed means open for extension",
          "points": 7,
          "correctAnswer": true,
          "explanation": "Open/Closed: open for extension, closed for modification."
        },
        {
          "id": "q48c",
          "type": "multiple-select",
          "question": "SOLID includes? (Select all)",
          "points": 6,
          "options": [
            {"id": "a", "text": "Single Responsibility"},
            {"id": "b", "text": "Liskov Substitution"},
            {"id": "c", "text": "Dependency Inversion"},
            {"id": "d", "text": "Don't Repeat Yourself"}
          ],
          "correctAnswers": ["a", "b", "c"],
          "explanation": "DRY is not part of SOLID; S, L, D are."
        }
      ]
    },
    {
      "id": "q49",
      "question": "Design Patterns - Multi-Part",
      "type": "multi-part",
      "points": 20,
      "parts": [
        {
          "id": "q49a",
          "type": "multiple-choice",
          "question": "What is Strategy pattern?",
          "points": 7,
          "options": [
            {"id": "a", "text": "Interchangeable algorithms"},
            {"id": "b", "text": "One algorithm"},
            {"id": "c", "text": "No algorithms"},
            {"id": "d", "text": "Random algorithms"}
          ],
          "correctAnswer": "a",
          "explanation": "Strategy pattern makes algorithms interchangeable."
        },
        {
          "id": "q49b",
          "type": "true-false",
          "question": "Factory pattern hides creation logic",
          "points": 7,
          "correctAnswer": true,
          "explanation": "Factory encapsulates object creation complexity."
        },
        {
          "id": "q49c",
          "type": "multiple-select",
          "question": "Common patterns? (Select all)",
          "points": 6,
          "options": [
            {"id": "a", "text": "Singleton"},
            {"id": "b", "text": "Observer"},
            {"id": "c", "text": "Factory"},
            {"id": "d", "text": "Polynomial"}
          ],
          "correctAnswers": ["a", "b", "c"],
          "explanation": "Singleton, Observer, Factory are patterns. Polynomial is not."
        }
      ]
    },
    {
      "id": "q50",
      "question": "Duck Typing - Multi-Part",
      "type": "multi-part",
      "points": 20,
      "parts": [
        {
          "id": "q50a",
          "type": "true-false",
          "question": "Duck typing focuses on behavior",
          "points": 7,
          "correctAnswer": true,
          "explanation": "Duck typing cares about methods/attributes, not type."
        },
        {
          "id": "q50b",
          "type": "multiple-choice",
          "question": "Duck typing principle?",
          "points": 7,
          "options": [
            {"id": "a", "text": "Explicit type checking"},
            {"id": "b", "text": "If it quacks like duck, it's duck"},
            {"id": "c", "text": "Strong typing"},
            {"id": "d", "text": "Type annotations required"}
          ],
          "correctAnswer": "b",
          "explanation": "Duck typing: if it has needed behavior, use it."
        },
        {
          "id": "q50c",
          "type": "true-false",
          "question": "Duck typing requires type declarations",
          "points": 6,
          "correctAnswer": false,
          "explanation": "Duck typing doesn't require explicit type declarations."
        }
      ]
    }
  ]
}
